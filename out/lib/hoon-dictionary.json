[
    {
        "keys": [
            "|"
        ],
        "doc": "<h1>Core <code>|</code> \"bar\"</h1>\n<p>Core hoons are flow hoons. The compiler essentially pins a Nock\nformula, or battery of formulas, to the subject.</p>\n<p>All <code>|</code> hoons are macros around <code>%core</code>. (See the <code>%core</code>\nsection in <a href=\"../../basic#-core-p-type-q-map-term-type\"><code>type</code></a> above.)\n<code>%core</code> uses the subject as the payload of a battery, whose arms are\ncompiled with the core itself as the subject.</p>\n<p>Four of these hoons (<code>|=</code>, <code>|.</code>, <code>|-</code>, and <code>|*</code>) produce a\ncore with a single arm, named <code>$</code>. We can recompute this arm \nwith changes, useful for recursion among other things:</p>\n<blockquote><p><code>$()</code> expands to <code>%=($)</code> (<a href=\"../cen/hep\">\"cenhep\"</a>), accepting \na <em>jogging</em> body containing a list of changes to the subject.</p>\n</blockquote>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "$"
        ],
        "doc": "<h1>Mold <code>$</code> \"buc\"</h1>\n<p>A <em>mold</em> is a <code>gate</code> (function) that helps us build simple and\nrigorous data structures.  (In fact, since \"mold\" sounds nasty,\nwe often call molds and mold builders \"structures.\")</p>\n<h2>Overview</h2>\n<p>A correct mold is a <em>normalizer</em>: an idempotent function across\nall nouns.  If the sample of a gate has type <code>%noun</code>, and its\nbody obeys the constraint that for any x, <code>=((mold x) (mold (mold\nx)))</code>, it's a normalizer and can be used as a mold.</p>\n<p>(Hoon is not dependently typed and so can't check idempotence\nstatically, so we can't actually tell if a mold matches this\ndefinition perfectly.  This is not actually a problem.)</p>\n<p>Runes in the <code>$</code> family are macros designed for making molds.\nBut any hoon may produce a mold. (This is why <code>model</code> is a\nsynonym for <code>hoon</code>).</p>\n<p>Many macros <em>bunt</em> a mold, producing <code>^~(=&gt;(mold $))</code>.  This\nproduces a constant default value.  The formal range of a mold\n(the type of its bunt) is called its <em>icon</em>.</p>\n<p>Molds have two uses: defining simple and rigorous structures, and\nvalidating untrusted input data.  Validation, though very\nimportant, is a rare use case.  Except for direct raw input,\nit's generally a faux pas to rectify nouns at runtime -- or even\nin userspace.</p>\n<p>As a structure definition, a mold has three common uses.  One,\nwe bunt it for a default value (such as the sample in a gate).\nTwo, the product of some computation is cast to its icon, both\nchecking the type and regularizing it.  Three, it's used as a\nbuilding block in other molds.</p>\n<p>In any case, since molds are just functions, we can use\nfunctional programming to assemble interesting molds.  For\ninstance, <code>(map foo bar)</code> is a table from mold <code>foo</code> to mold\n<code>bar</code>.  <code>map</code> is not a mold; it's a function that makes a mold.\nMolds and mold builders are generally described together.</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "%"
        ],
        "doc": "<h1>Call <code>%</code> (\"cen\")</h1>\n<p>We've already covered <a href=\"../limb/wing\"><code>%wing</code></a> and <a href=\"../limb/limb\"><code>%limb</code></a>.  These are simple \nforms of the <em>invocation</em> family of hoons, <code>%</code>, whose general \nform is <code>%=</code> (\"centis\").</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            ":"
        ],
        "doc": "<h1>Cell <code>:</code> (\"col\")</h1>\n<p>The <code>:</code> (\"col\") hoons, <code>:-</code> and friends, are simple and regular.\nAll <code>:</code> hoons expand to <code>:-</code> (\"colhep\"), which makes a pair \n(just like the Lisp <a href=\"https://en.wikipedia.org/wiki/Cons\"><code>cons</code></a> operator).</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "."
        ],
        "doc": "<h1>Nock <code>.</code> (\"dot\")</h1>\n<p>Anything Nock can do, Hoon can do also.</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "^"
        ],
        "doc": "<h1>Cast <code>^</code> (\"ket\")</h1>\n<p><a href=\"./hep/\"><code>^-</code> (\"kethep\")</a>, <a href=\"./lus/\"><code>^+</code> (\"ketlus\")</a>, and \n<a href=\"./tis/\"><code>^=</code> (\"kettis\")</a> let us adjust types without violating type \nconstraints.</p>\n<p>The <code>nest</code> algorithm which tests subtyping is conservative;\nit never allows invalid nests, it sometimes rejects valid nests.</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            ";"
        ],
        "doc": "<h1>Make <code>;</code> (\"sem\")</h1>\n<p>Miscellaneous useful macros.</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "~"
        ],
        "doc": "<h1>Hint <code>~</code> (\"sig\")</h1>\n<p>Runes that use Nock <code>10</code> to pass non-semantic info to the\ninterpreter.</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "="
        ],
        "doc": "<h1>Flow <code>=</code> (\"tis\")</h1>\n<p>Flow hoons change the subject.  (Or more precisely, a flow hoon\ncompiles at least one of its subhoons with a different subject.)\nAll non-flow hoons (except cores) pass the subject down unchanged.</p>\n<h2>Overview</h2>\n<p>The simplest way to change the subject is to compose two hoons, \n<code>p</code> and <code>q</code>.  Let <code>x</code> be <code>(mint subject p)</code>, with product type \n<code>p.x</code> and nock formula <code>q.x</code>.  Let <code>y</code> be <code>(mint p.x q)</code>.  Then\ntheir composition is <code>[p.y [7 q.x q.y]]</code>.</p>\n<p>This composition is the <code>=&gt;</code> (\"tisgar\") rune.  A close relative is \n<code>=+</code> (\"tislus\"), which is <code>=&gt;</code> over <code>[p .]</code>.  The new subject is a \ncell of <code>p</code> and the old subject.  <code>=+</code> is the simplest Hoon equivalent of\n\"declaring a variable\" (introducing new data into the subject).</p>\n<p>Another way to change the subject is to mutate it.  With the\n<code>=.</code> (\"tisdot\") rune, given a wing that resolves to a leg, we can write\ninstead of reading, <em>installing</em> a new value at that leg.  Of\ncourse, we are creating a copy, not modifying the original.</p>\n<p>There are many flow stems, all small variations on these three.</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "?"
        ],
        "doc": "<h1>Test <code>?</code> (\"wut\")</h1>\n<p>Hoon has the usual branches and logical tests.  For pattern\nmatching, it also has a <a href=\"./tis/\"><code>?=</code> (\"wuttis\")</a> rune that tests whether a value\nmatches the icon of a mold.  And it has branch inference,\nlearning from <code>?=</code> tests in the condition of <a href=\"./col/\"><code>?:</code> (\"wutcol\")</a> hoons.</p>\n<h2>Overview</h2>\n<p>All <code>?</code> runes expand to <code>?:</code> and/or <code>?=</code>.</p>\n<p>If the condition of an <code>?:</code> is a <code>?=</code>, <em>and</em> the <code>?=</code> is\ntesting a leg of the subject, the compiler specializes the subject\ntype for the branches of the <code>?:</code>.  Branch inference also works\nfor expressions which expand to <code>?:</code>.</p>\n<p>The test does not have to be a single <code>?=</code>; the compiler can\nanalyze arbitrary boolean logic (<a href=\"./pam/\"><code>?&amp;</code> (\"wutpam\")</a>,\n<a href=\"./bar/\"><code>?|</code> (\"wutbar\")</a>, <a href=\"./zap/\"><code>?!</code> (\"wutzap\")</a>) with full\nshort-circuiting.  Equality tests (<a href=\"../dot/tis/\"><code>.=</code> (\"dottis\")</a>) are <em>not</em>\nanalyzed.</p>\n<p>If the compiler detects that the branch is degenerate (only one\nside is taken), it fails with an error.</p>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "!"
        ],
        "doc": "<h1>Wild <code>!</code> (\"zap\")</h1>\n<h2>Hoons</h2>\n&lt;list dataPreview=\"true\" className=\"runes\"&gt;&lt;/list&gt;"
    },
    {
        "keys": [
            "|_"
        ],
        "doc": "<h1><code>|_ \"barcab\"</code></h1>\n<p><code>[%brcb p=model q=(map term foot)]</code>: form a door, a many-armed core\nwith a sample.</p>\n<h2>Expands to</h2>\n<pre><code>=|  p\n|%  q\n==\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>battery</em>.</p>\n<h2>Discussion</h2>\n<p>A door is the general case of a gate (function).  A gate is a\ndoor with only one arm, the empty name <code>$</code>.</p>\n<p>Other languages have no real equivalent of a door, but we often\nsee the pattern of multiple functions with the same argument\nlist, or with shared argument structure.  In Hoon, this shared\nstructure becomes a door.</p>\n<p>Calling a door is just like calling a gate, but the caller needs\nto specify the arm.  For instance, to call the gate <code>foo</code> as a\ndoor, instead of <code>(foo bar)</code> we would write <code>~($ foo bar)</code>.  This\nis an irregular form for <code>%~($ foo bar)</code>, <a href=\"../../cen/sig\">\"censig\"</a>.</p>\n<h2>Examples</h2>\n<p>A trivial door:</p>\n<pre><code>/~zod:dojo&gt; =mol  |_  a=@ud\n                  ++  succ  +(a)\n                  ++  prev  (dec a)\n                  --\n/~zod:dojo&gt; ~(succ mol 1)\n2\n/~zod:dojo&gt; ~(succ mol ~(succ mol ~(prev mol 5)))\n6\n</code></pre>\n<p>A more interesting door, from the kernel library:</p>\n<pre><code>++  ne\n  |_  tig=@\n  ++  d  (add tig '0')\n  ++  x  ?:((gte tig 10) (add tig 87) d)\n  ++  v  ?:((gte tig 10) (add tig 87) d)\n  ++  w  ?:(=(tig 63) '~' ?:(=(tig 62) '-' ?:((gte tig 36) (add tig 29) x)))\n  --\n</code></pre>\n<p>The <code>ne</code> door prints a digit in base 10, 16, 32 or 64:</p>\n<pre><code>~zod:dojo&gt; `@t`~(x ne 12)\n'c'\n</code></pre>\n"
    },
    {
        "keys": [
            "|%"
        ],
        "doc": "<h1><code>|% \"barcen\"</code></h1>\n<p>[%brcb p=(map term foot)]: Form a core <code>[battery payload]</code> with subject as the payload.</p>\n<h2>Produces</h2>\n<p>A core with battery <code>p</code>.  Payload is the subject.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>battery</em>.</p>\n<h2>Discussion</h2>\n<p>A core is like an \"object\" in a conventional language, but its\nattributes (<em>arms</em>) are functions on the core, not the core and\nan argument.  A \"method\" on a core is an arm producing a gate.</p>\n<h2>Examples</h2>\n<p>A trivial core:</p>\n<pre><code>~zod:dojo&gt; =foo  =+  x=58\n                 |%\n                 ++  n  (add 42 x)\n                 ++  g  |=  b=@\n                        (add b n)\n                 --\n~zod:dojo&gt; n.foo\n100\n~zod:dojo&gt; (g.foo 1)\n101\n</code></pre>\n"
    },
    {
        "keys": [
            "|:"
        ],
        "doc": "<h1><code>|: \"barcol\"</code></h1>\n<p><code>[%brcl p=hoon q=hoon]</code>: form a gate with burnt sample.</p>\n<h2>Expands to</h2>\n<pre><code>=&gt;  ^~  p\n  |.  q\n</code></pre>\n<h2>Discussion</h2>\n<p>Note that <code>p</code> is a hoon, not a model; <code>|:</code> doesn't bunt your sample as\n<a href=\"../tis\"><code>|=</code></a> does.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n"
    },
    {
        "keys": [
            "|."
        ],
        "doc": "<h1><code>|. \"bardot\"</code></h1>\n<p><code>[%brdt p=hoon]</code>: form a trap, a core with one arm <code>$</code>.</p>\n<h2>Expands to</h2>\n<pre><code>|%  ++  $  p\n--\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>A trap is a deferred computation.</p>\n<h2>Examples</h2>\n<p>A trivial trap:</p>\n<pre><code>~zod:dojo&gt; =foo |.(42)\n~zod:dojo&gt; $:foo\n42\n~zod:dojo&gt; (foo)\n42\n</code></pre>\n<p>A more interesting trap:</p>\n<pre><code>~zod:dojo&gt; =foo  =/  reps  10\n                 =/  step  0\n                 =/  outp  0\n                 |.\n                 ?:  =(step reps)\n                   outp\n                 $(outp (add outp 2), step +(step))\n~zod:dojo&gt; (foo)\n20\n</code></pre>\n<p>Note that we can use <code>$()</code> to recurse back into the\ntrap, since it's a core with an <code>$</code> arm.</p>\n<blockquote><p><code>$()</code> expands to <code>%=($)</code> (<a href=\"../../cen/tis\">\"centis\"</a>), \naccepting a <em>jogging</em> body containing a list of changes \nto the subject.</p>\n</blockquote>\n"
    },
    {
        "keys": [
            "|-"
        ],
        "doc": "<h1><code>|- \"barhep\"</code></h1>\n<p><code>[%brhp p=hoon]</code>: form a trap and kick (\"<em>call</em>\") it.</p>\n<h2>Expands to</h2>\n<pre><code>=&lt;($ |.(p))\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>The <code>|-</code> (\"barhep\") rune can be thought of as a \"recursion \npoint\". Since <code>|-</code> makes a <code>|.</code> (<a href=\"../dot\">\"bardot\"</a>, a core \nwith one arm named <code>$</code>, we can recurse back into it with <code>$()</code>.</p>\n<blockquote><p><code>$()</code> expands to <code>%=($)</code> (<a href=\"../../cen/tis\">\"centis\"</a>), \naccepting a <em>jogging</em> body containing a list of changes to \nthe subject.</p>\n</blockquote>\n<h2>Examples</h2>\n<p>A trivial loop doesn't even recurse:</p>\n<pre><code>~zod:dojo&gt; |-(42)\n42\n</code></pre>\n<p>The classic loop is a decrement:</p>\n<pre><code>~zod:dojo&gt; =foo  =/  a  42\n                 =/  b  0\n                 |-\n                 ?:  =(a +(b))\n                   b\n                 $(b +(b))\n~zod:dojo&gt; foo\n41\n</code></pre>\n"
    },
    {
        "keys": [
            "|^"
        ],
        "doc": "<h1><code>|^ \"barket\"</code></h1>\n<p><code>[%brkt p=hoon q=(map term foot)]</code>: form a core with battery and\nanonymous arm <code>$</code> and kick it.</p>\n<h2>Expands to</h2>\n<pre><code>=&gt;  |%\n    ++  $  p\n    q\n    --\n$\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>battery</em>.</p>\n<h2>Examples</h2>\n<p>A trivial cork:</p>\n<pre><code>~zod:dojo&gt; |^\n           (add n g)\n           ++  n  42\n           ++  g  58\n           --\n100\n</code></pre>\n"
    },
    {
        "keys": [
            "|~"
        ],
        "doc": "<h1><code>|~ \"barsig\"</code></h1>\n<p><code>[%brsg p=model q=hoon]</code>: form an iron gate.</p>\n<h2>Expands to</h2>\n<pre><code>^|  |=(p q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>See <a href=\"../../../advanced\">this discussion of core variance models</a></p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =&gt;  ~  ^+(|~(a=@ *@) |=(a=* *@))\n&lt;1|usl {a/@ $~}&gt;\n</code></pre>\n"
    },
    {
        "keys": [
            "|*"
        ],
        "doc": "<h1><code>|* \"bartar\"</code></h1>\n<p><code>[%brtr p=model q=hoon]</code>: form a gill, a wet one-armed \ncore with sample.</p>\n<h2>Expands to</h2>\n<pre><code>=|  p\n|%\n+-  $\n  q\n--\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>In a normal (dry) gate, your argument is converted into the\nsample type.  In a generic (wet) gate or gill, your argument type\npasses through the function, rather as if it was a macro (there\nis still only one copy of the code, however).</p>\n<p>Genericity is a powerful and dangerous tool.  Use gills only if\nyou think you know what you're doing.</p>\n<p>Just as with a <a href=\"../tis\">gate</a>, we can recurse back into a gill \nwith <code>$()</code>.</p>\n<blockquote><p><code>$()</code> expands to <code>%=($)</code> (<a href=\"../../cen/tis\">\"centis\"</a>), accepting \na <em>jogging</em> body containing a list of changes to the subject.</p>\n</blockquote>\n<h2>Examples</h2>\n<p>Wet and dry gates in a nutshell:</p>\n<pre><code>~zod:dojo&gt; =foo |=([a=* b=*] [b a])\n~zod:dojo&gt; =bar |*([a=* b=*] [b a])\n~zod:dojo&gt; (foo %cat %dog)\n[6.778.724 7.627.107]\n~zod:dojo&gt; (bar %cat %dog)\n[%dog %cat]\n</code></pre>\n<p>The dry gate does not preserve the type of <code>a</code> and <code>b</code>; the wet\ngate does.</p>\n"
    },
    {
        "keys": [
            "|="
        ],
        "doc": "<h1><code>|= \"bartis\"</code></h1>\n<p><code>[%brts p=model q=hoon]</code>: form a gate, a dry one-armed core with sample.</p>\n<h2>Expands to</h2>\n<pre><code>=|  p\n|%  ++  $  q\n--\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>A gate is a core with one arm named <code>$</code>, so, just as with \n<a href=\"../hep\"><code>|-</code> (\"barhep\")</a>, we can recurse back into it with <code>$()</code>.</p>\n<blockquote><p><code>$()</code> expands to <code>%=($)</code> (<a href=\"../../cen/tis\">\"centis\"</a>), accepting \na <em>jogging</em> body containing a list of changes to the subject.</p>\n</blockquote>\n<h2>Examples</h2>\n<p>A trivial gate:</p>\n<pre><code>~zod:dojo&gt; =foo |=(a=@ +(a))\n~zod:dojo&gt; (foo 20)\n21\n</code></pre>\n<p>A slightly less trivial gate:</p>\n<pre><code>~zod:dojo&gt; =foo  |=  [a=@ b=@]\n                 (add a b)\n~zod:dojo&gt; (foo 20 400)\n420\n</code></pre>\n"
    },
    {
        "keys": [
            "|?"
        ],
        "doc": "<h1><code>|? \"barwut\"</code></h1>\n<p><code>[%brwt p=hoon]</code>: form a lead trap.</p>\n<h2>Expands to</h2>\n<pre><code>^?  |.  p\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>See this <a href=\"../../../advanced\">discussion of the core variance model</a>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =&gt;  ~  ^+  |?(%a)  |.(%a)\n&lt;1?pqz $~&gt;\n~zod:dojo&gt; =&gt;  ~  ^+  |?(%a)  |.(%b)\nnest-fail\n</code></pre>\n"
    },
    {
        "keys": [
            "Base"
        ],
        "doc": "<h1>Base molds</h1>\n<p><code>[%base p=$@(?(%noun %cell %bean %null) [%atom p=aura])]</code>: trivial molds.</p>\n<h2>Produces</h2>\n<p>A mold for the base in <code>p</code>. <code>%noun</code> is any noun; <code>%atom</code> is any\natom; <code>%cell</code> is a cell of nouns; <code>%bean</code> is a loobean, <code>?(`@f`0\n`@f`1)</code>. <code>%null</code> is zero with aura <code>@n</code>.</p>\n<h2>Syntax</h2>\n<p>Irregular: <code>*</code> makes <code>,%noun</code>, <code>^</code> makes <code>,%cell</code>, <code>?</code> makes\n<code>,%bean</code>, <code>,~</code> makes <code>,%null</code>, <code>@aura</code> makes atom <code>aura</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; (* %foo)\n7.303.014\n~zod:dojo&gt; (,~ 0)\n~\n~zod:dojo&gt; (^ 0)\n^\n~zod:dojo&gt; (@ux [1 1])\n0x0\n</code></pre>\n"
    },
    {
        "keys": [
            "$_"
        ],
        "doc": "<h1><code>$_ \"buccab\"</code></h1>\n<p><code>[%bccb p=hoon]</code>: mold which normalizes to an example.</p>\n<h2>Expands to</h2>\n<pre><code>|=(* p)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<p>Irregular: <code>_foo</code> is <code>$_(foo)</code>.</p>\n<h2>Discussion</h2>\n<p><code>$_</code> (\"buccab\") discards the sample it's supposedly normalizing \nand produces its <em>example</em> instead.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo $_([%foobar %moobaz])\n\n~zod:dojo&gt; (foo %foo %bar)\n[%foobar %moobaz]\n\n~zod:dojo&gt; `foo`[%foobar %moobaz]\n[%foobar %moobaz]\n\n~zod:dojo $:foo\n[%foobar %moobaz]\n</code></pre>\n"
    },
    {
        "keys": [
            "$%"
        ],
        "doc": "<h1><code>$% \"buccen\"</code></h1>\n<p><code>[%bccn p=(list [[aura @] model])]</code>: mold which recognizes a union tagged by head atom.</p>\n<h2>Normalizes to</h2>\n<p>For any item <code>i</code> in <code>p</code>, a cell whose head is the atom <code>q.p.i.p</code>,\nand whose tail recognizes <code>q.i.p</code>.</p>\n<p>Void if <code>p</code> is empty.</p>\n<h2>Defaults to</h2>\n<p>For the first item <code>i</code> in <code>p</code>, the cell <code>[q.p.i.p $:q.i.p]</code>.\nCrashes if <code>p</code> is empty.</p>\n<h2>Syntax</h2>\n<p>Regular form: <em>2-running</em>.</p>\n<h2>Discussion</h2>\n<p>A <code>$%</code> (\"buccen\") is a tagged union, an extremely common data model.</p>\n<p>Make sure the first item in your <code>$%</code> terminates, or the default will \nbe an infinite loop!</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo $%([%foo p=@ud q=@ud] [%bar p=@ud])\n\n~zod:dojo&gt; (foo [%bar 37])\n[%bar p=37]\n\n~zod:dojo&gt; $:foo\n[%foo p=0 q=0]~\n</code></pre>\n"
    },
    {
        "keys": [
            "$:"
        ],
        "doc": "<h1><code>$: \"buccol\"</code></h1>\n<p><code>[%bccl p=(list model)]</code>: form a mold which recognizes a tuple.</p>\n<h2>Normalizes</h2>\n<p>The tuple the length of <code>p</code>, normalizing each item, defaulting\nwhere the tuple does not match.</p>\n<p>Void if <code>p</code> is empty.</p>\n<h2>Defaults to</h2>\n<p>The tuple the length of <code>p</code>, defaulting each items.</p>\n<p>Crashes if <code>p</code> is empty.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<p>Irregular (noun mode): <code>,[a b c]</code> is <code>$:(a b c)</code>.\nIrregular (mold mode): <code>[a b c]</code> is <code>$:(a b c)</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo $:(p=@ud q=@tas)\n\n~zod:dojo&gt; (foo 33 %foo)\n[p=33 q=%foo]\n\n~zod:dojo&gt; `foo`[33 %foo]\n[p=33 q=%foo]\n\n~zod:dojo&gt; $:foo\n[p=0 q=%$]\n</code></pre>\n"
    },
    {
        "keys": [
            "$-"
        ],
        "doc": "<h1><code>$- \"buchep\"</code></h1>\n<p><code>[%bchp p=model q=model]</code>: mold which normalizes to an example gate.</p>\n<h2>Expands to</h2>\n<pre><code>$_  ^|\n|=(p $:q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>Since a <code>$-</code> (\"buchep\") is a <a href=\"../cab/\"><code>$_</code> (\"buccab\")</a>, it is not useful for \nnormalizing, just for typechecking.  In particular, the existence of <code>$-</code>s does \n<em>not</em> let us send gates or other cores over the network!</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo $-(%foo %bar)\n\n~zod:dojo&gt; ($:foo %foo)\n%bar\n</code></pre>\n"
    },
    {
        "keys": [
            "$^"
        ],
        "doc": "<h1><code>$^ \"bucket\"</code></h1>\n<p><code>[%bckt p=model q=model]</code>: mold which normalizes a union tagged by head depth (cell).</p>\n<h2>Normalizes to</h2>\n<p>Default, if the sample is an atom; <code>p</code>, if the head of the sample\nis an atom; <code>q</code> otherwise.</p>\n<h2>Defaults to</h2>\n<p>The default of <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =a $%([%foo p=@ud q=@ud] [%bar p=@ud])\n\n~zod:dojo&gt; =b $^([a a] a)\n\n~zod:dojo&gt; (b [[%bar 33] [%foo 19 22]])\n[[%bar p=33] [%foo p=19 q=22]]\n\n~zod:dojo&gt; (b [%foo 19 22])\n[%foo p=19 q=22]\n\n~zod:dojo&gt; $:b \n[%bar p=0]\n</code></pre>\n"
    },
    {
        "keys": [
            "$@"
        ],
        "doc": "<h1><code>$@ \"bucpat\"</code></h1>\n<p><code>[%bcpt p=model q=model]</code>: mold which normalizes a union tagged by head depth (atom).</p>\n<h2>Normalizes to</h2>\n<p>Default, if the sample is an atom; <code>p</code>, if the head of the sample\nis an atom; <code>q</code> otherwise.</p>\n<h2>Defaults to</h2>\n<p>The default of <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Product: a mold which applies <code>p</code> if its sample is an atom, \n<code>q</code> if its sample is a cell.</p>\n<p>Regular form: <em>2-fixed</em>.</p>\n<p>Example:</p>\n<pre><code>~zod:dojo&gt; =a $@(%foo $:(p=%bar q=@ud))\n\n~zod:dojo&gt; (a %foo)\n%foo\n\n~zod:dojo&gt; `a`[%bar 99]\n[p=%bar q=99]\n\n~zod:dojo&gt; $:a\n[%foo p=0 q=0]\n</code></pre>\n"
    },
    {
        "keys": [
            "$="
        ],
        "doc": "<h1><code>$= \"buctis\"</code></h1>\n<p><code>[%bcts p=@tas q=model]</code>: mold which wraps a face around another mold.</p>\n<h2>Expands to</h2>\n<pre><code>|=  *\n^=(p %-(q +6))\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular (mold mode): <code>foo=bar</code> is <code>$=(foo bar)</code>.</p>\n<h2>Discussion</h2>\n<p>Note that the Hoon compiler is at least slightly clever about\ncompiling molds, and almost never has to actually put in a gate\nlayer (as seen in the expansion above) to apply a <code>$=</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =a $=(p %foo)\n\n~zod:dojo&gt; (a %foo)\np=%foo\n\n~zod:dojo&gt; (a %bar)\np=%foo\n</code></pre>\n"
    },
    {
        "keys": [
            "$?"
        ],
        "doc": "<h1><code>$? \"bucwut\"</code></h1>\n<p><code>[%bcwt p=(list model)]</code>: mold which normalizes a general union.</p>\n<h2>Normalizes to</h2>\n<p>The first item in <code>p</code> which normalizes the sample to itself;\notherwise, default.</p>\n<p>Void, if <code>p</code> is empty.</p>\n<h2>Defaults to</h2>\n<p>The first item in <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<p>Irregular: <code>?(%foo %bar)</code> is <code>$?(%foo %bar)</code>.</p>\n<h2>Discussion</h2>\n<p>For a union of atoms, a <code>$?</code> (\"bucwut\") is fine.  For more complex nouns,\nalways try to use a <a href=\"../cen/\"><code>$%</code> (\"buccen\")</a>, <a href=\"../pat/\"><code>$@</code> (\"bucpat\")</a> or \n<a href=\"../ket/\"><code>$^</code> (\"bucket\")</a>, at least if you expect your mold to be used as a \nnormalizer.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =a ?(%foo %bar %baz)\n\n~zod:dojo&gt; (a %baz)\n%baz\n\n~zod:dojo&gt; (a [37 45])\n%baz\n\n~zod:dojo&gt; $:a\n%baz\n</code></pre>\n"
    },
    {
        "keys": [
            "%_"
        ],
        "doc": "<h1><code>%_ \"cencab\"</code></h1>\n<p><code>[%cncb p=wing q=(list (pair wing hoon))]</code>: take a wing with changes,\npreserving type.</p>\n<h2>Expands to</h2>\n<pre><code>^+(p %=(p q))\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>jogging</em>.</p>\n<h2>Discussion</h2>\n<p><code>%_</code> (\"cencab\") is different from <code>%=</code> (\"centis\") because <code>%=</code> \ncan change the type of a limb with mutations.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo [p=42 q=6]\n~zod:dojo&gt; foo(p %bar)\n[p=%bar q=6]\n~zod:dojo&gt; foo(p [55 99])\n[p=[55 99] q=6]\n~zod:dojo&gt; %_(foo p %bar)\n[p=7.496.034 99]\n~zod:dojo&gt; %_(foo p [55 99])\n! nest-fail\n</code></pre>\n"
    },
    {
        "keys": [
            "%."
        ],
        "doc": "<h1><code>%. \"cendot\"</code></h1>\n<p><code>[%cndt p=hoon q=hoon]</code>: call a gate (function), reversed.</p>\n<h2>Expands to</h2>\n<pre><code>%-(q p)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =add-triple |=([a=@ b=@ c=@] :(add a b c))\n~zod:dojo&gt; %.([1 2 3] add-triple)\n6\n</code></pre>\n"
    },
    {
        "keys": [
            "%-"
        ],
        "doc": "<h1><code>%- \"cenhep\"</code></h1>\n<p><code>[%cnhp p=hoon q=hoon]</code>: call a gate (function).</p>\n<h2>Expands to</h2>\n<pre><code>%~($ p q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>(a)</code> is <code>$:a</code>; <code>(a b c d)</code> is <code>%-(a [b c d])</code>.</p>\n<h2>Discussion</h2>\n<p><code>%-</code> (\"cenhep\") is a function call; <code>p</code> is the function (<a href=\"../../bar/tis\"><code>gate</code></a>, \n<code>q</code> the argument. <code>%-</code> is a special case of <a href=\"../sig\"><code>%~</code> (\"censig\")</a>, and a gate \nis a special case of a <a href=\"../../bar/cab\">door</a>.</p>\n<p>In a gate, the modified core has only one anonymous arm; in a\ndoor it gets a full battery.  Intuitively, a gate defines one\nalgorithm it can compute upon its sample, <code>+6</code>. A door defines\nmany such algorithms.</p>\n<p>In classical languages, doors correspond to groups of functions \nwith the same argument list, or at least sharing a prefix.  In\nHoon, this shared sample is likely to be pulled into a door.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =add-triple |=([a=@ b=@ c=@] :(add a b c))\n~zod:dojo&gt; (add-triple 1 2 3)\n6\n~zod:dojo&gt; %-(add-triple [1 2 3])\n6\n</code></pre>\n"
    },
    {
        "keys": [
            "%^"
        ],
        "doc": "<h1><code>%^ \"cenket\"</code></h1>\n<p><code>[%cnkt p=hoon q=hoon r=hoon s=hoon]</code>: call with triple sample.</p>\n<h2>Expands to</h2>\n<pre><code>%-(p [q r s])\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =add-triple |=([a/@ b/@ c/@] :(add a b c))\n~zod:dojo&gt; %^(add-triple 1 2 3)\n6\n</code></pre>\n"
    },
    {
        "keys": [
            "%+"
        ],
        "doc": "<h1><code>%+ \"cenlus\"</code></h1>\n<p><code>[%cnls p=hoon q=hoon r=hoon]</code>: call with pair sample.</p>\n<h2>Expands to</h2>\n<pre><code>%-(p [q r])\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =add-triple |=([a=@ b=@ c=@] :(add a b c))\n~zod:dojo&gt; %+(add-triple 1 [2 3])\n6\n</code></pre>\n"
    },
    {
        "keys": [
            "%~"
        ],
        "doc": "<h1><code>%~ \"censig\"</code></h1>\n<p><code>[%cnsg p=wing q=hoon r=hoon]</code>: call with multi-armed door.</p>\n<h2>Expands to</h2>\n<pre><code>=+  a=q\n=&lt;(p %=(a +6 r))\n</code></pre>\n<blockquote><p>Note: the expansion implementation is hygienic -- it doesn't actually add the\n<code>a</code> face to the subject. It's shown here because <code>%=</code> (\"centis\") requires a <code>wing</code>.</p>\n</blockquote>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<p>Irregular: <code>~(a b c)</code> is <code>%~(a b c)</code>; <code>~(a b c d e)</code> is <code>%~(a b\n[c d e])</code>.</p>\n<h2>Discussion</h2>\n<p><code>%~</code> (\"censig\") is the general case of a function call, <code>%-</code> (\"cenhep\").  In\nboth, we replace the sample (<code>+6</code>) of a core.  In <code>%-</code> the\ncore is a gate and we pull the <code>$</code> arm. In <code>%~</code> the\ncore is a door and we can pull any of its arms.</p>\n<p>Most languages do not have cores, doors, or <code>%~</code>.  \"Just\nlearn to step outside your linear, Western way of thinking.\"</p>\n<h2>Examples</h2>\n<p>See <a href=\"../../bar/cab\"><code>|_</code></a>.</p>\n"
    },
    {
        "keys": [
            "%*"
        ],
        "doc": "<h1><code>%* \"centar\"</code></h1>\n<p><code>[%cntr p=wing q=hoon r=(list (pair wing hoon))]</code>: make\nwith arbitrary hoon.</p>\n<h2>Expands to</h2>\n<pre><code>=+  q\n%=  p\nr\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>, then <em>jogging</em>.</p>\n<h2>Discussion</h2>\n<p><code>%*</code> makes a limb from a hoon, with changes. It's useful when you want\nevaluate a hoon, pull out a single limb from the result,\nand then change some parts of the limb before using it.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; %*($ add a 2, b 3)\n5\n~zod:dojo&gt; =foo [a=1 b=2 c=3 d=4]\n~zod:dojo&gt; %*(+ foo c %hello, d %world)\n[b=2 c=%hello d=%world]\n~zod:dojo&gt; =+(foo=[a=1 b=2 c=3] foo(b 7, c 10))\n[a=1 b=7 c=10]\n~zod:dojo&gt; %*(foo [foo=[a=1 b=2 c=3]] b 7, c 10)\n[a=1 b=7 c=10]\n</code></pre>\n"
    },
    {
        "keys": [
            "%="
        ],
        "doc": "<h1><code>%= \"centis\"</code></h1>\n<p><code>[%cnts p=wing q=(list (pair wing hoon))]</code>: take a wing with changes.</p>\n<h2>Produces</h2>\n<p><code>p</code>, modified by the change list <code>q</code>.</p>\n<p>If <code>p</code> resolves to a leg, <code>q</code> is a list of changes to that leg.\nIf <code>p</code> resolves to an arm, <code>q</code> is a list of changes to the core\ncontaining that arm.  We compute the arm on the modified core.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>jogging</em>.</p>\n<p>Irregular: <code>foo(x 1, y 2, z 3)</code> is <code>%=(foo x 1, y 2, z 3)</code>.</p>\n<h2>Discussion</h2>\n<p>Note that <code>p</code> is a wing, not a hoon.  Knowing that a function\ncall <code>(foo bar)</code> involves making <code>foo</code>, replacing its sample \nat slot <code>+6</code> with <code>bar</code>, and taking the <code>$</code> limb, you might think\n<code>(foo bar)</code> would mean <code>%=(foo +6 bar)</code>.</p>\n<p>But it's actually <code>=+(foo =&gt;(%=(+2 +6 bar) $))</code>. Even if <code>foo</code> is\na wing, we would just be mutating <code>+6</code> within the core that defines the\n<code>foo</code> arm.  Instead we want to modify the <em>product</em> of <code>foo</code> -- the gate\n-- so we have to pin it into the subject.</p>\n<p>Here's that again in tall form:</p>\n<pre><code>=+  foo\n=&gt;  %=  +2\n      +6  bar\n    ==\n  $\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo [p=5 q=6]\n~zod:dojo&gt; foo(p 42)\n[p=42 q=6]\n~zod:dojo&gt; foo(+3 99)\n[p=5 99]\n</code></pre>\n"
    },
    {
        "keys": [
            ":_"
        ],
        "doc": "<h1><code>:_ \"colcab\"</code></h1>\n<p><code>[%clcb p=hoon q=hoon]</code>; construct a cell, inverted.</p>\n<h3>Expands to</h3>\n<pre><code>:-(q p)\n</code></pre>\n<h3>Syntax</h3>\n<p>Regular: <em>2-fixed</em>.</p>\n<h3>Examples</h3>\n<pre><code>~zod:dojo&gt; :_(1 2)\n[2 1]\n</code></pre>\n"
    },
    {
        "keys": [
            ":-"
        ],
        "doc": "<h1><code>:- \"colhep\"</code></h1>\n<p><code>[%clhp p=hoon q=hoon]</code>: construct a cell (2-tuple).</p>\n<h2>Produces</h2>\n<p>The cell of <code>p</code> and <code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>[a b]</code> is <code>:-(a b)</code>.</p>\n<p>Irregular: <code>[a b c]</code> is <code>[a [b c]]</code>.</p>\n<p>Irregular: <code>a^b^c</code> is <code>[a b c]</code>.</p>\n<p>Irregular: <code>a/b</code> is <code>[%a b]</code>.</p>\n<p>Irregular: <code>`a</code> is <code>[~ a]</code>.</p>\n<p>Irregular: <code>~[a b]</code> is <code>[a b ~]</code>.</p>\n<p>Irregular: <code>[a b c]~</code> is <code>[[a b c] ~]</code>.</p>\n<h2>Discussion</h2>\n<p>Hoon hoons actually use the same \"autocons\" pattern as Nock \nformulas.  If you're assembling hoons (which usually only the\ncompiler does), <code>[a b]</code> is the same as <code>[%clhp a b]</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; :-(1 2)\n[1 2]\n~zod:dojo&gt; 1^2\n[1 2]\n~zod:dojo&gt; 1/2\n[%1 2]\n~zod:dojo&gt; `1\n[~ 1]\n</code></pre>\n"
    },
    {
        "keys": [
            ":^"
        ],
        "doc": "<h1><code>:^ \"colket\"</code></h1>\n<p><code>[%clkt p=hoon q=hoon r=hoon s=hoon]</code>: construct a quadruple (4-tuple).</p>\n<h2>Expands to</h2>\n<pre><code>:-(p :-(q :-(r s)))\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>/~zod:dojo&gt; :^(1 2 3 4)\n[1 2 3 4]\n/~zod:dojo&gt; :^     5\n                 6\n               7\n             8\n[5 6 7 8]\n</code></pre>\n"
    },
    {
        "keys": [
            ":+"
        ],
        "doc": "<h1><code>:+ \"collus\"</code></h1>\n<p><code>[%clls p=hoon q=hoon r=hoon]</code>: construct a triple (3-tuple).</p>\n<h2>Expands to:</h2>\n<pre><code>:-(p :-(q r))\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>/~zod:dojo&gt; :+  1\n              2\n            3\n[1 2 3]\n/~zod:dojo&gt; :+(%a ~ 'b')\n[%a ~ 'b']\n</code></pre>\n"
    },
    {
        "keys": [
            ":~"
        ],
        "doc": "<h1><code>:~ \"colsig\"</code></h1>\n<p><code>[%clsg p=(list hoon)]</code>: construct a null-terminated list.</p>\n<h2>Expands to</h2>\n<p><em>Pseudocode</em>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>p</code>:</p>\n<pre><code>:-(a :-(b :-(c :-(... :-(z ~)))))\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>|-\n?~  p\n  ~\n:-  i.p\n$(p t.p)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; :~(5 3 4 2 1)\n[5 3 4 2 1 ~]\n~zod:dojo&gt; ~[5 3 4 2 1]\n[5 3 4 2 1 ~]\n~zod:dojo&gt; :~  5\n               3\n               4\n               2\n               1\n           ==\n[5 3 4 2 1 ~]\n</code></pre>\n"
    },
    {
        "keys": [
            ":*"
        ],
        "doc": "<h1><code>:* \"coltar\"</code></h1>\n<p><code>[%cltr p=(list hoon)]</code>: construct an n-tuple.</p>\n<h2>Expands to</h2>\n<p><em>Pseudocode</em>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>p</code>:</p>\n<pre><code>:-(a :-(b :-(c :-(... z)))))\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>|-\n?~  p\n  !!\n?~  t.p\n  i.p\n:-  i.p\n$(p t.p)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<h2>Examples</h2>\n<pre><code>/~zod:dojo&gt; :*(5 3 4 1 4 9 0 ~ 'a')\n[5 3 4 1 4 9 0 ~ 'a']\n/~zod:dojo&gt; [5 3 4 1 4 9 0 ~ 'a']\n[5 3 4 1 4 9 0 ~ 'a']\n/~zod:dojo&gt; :*  5\n                3\n                4 \n                1\n                4\n                9\n                0\n                ~\n                'a'\n            ==\n[5 3 4 1 4 9 0 ~ 'a']\n</code></pre>\n"
    },
    {
        "keys": [
            ".^"
        ],
        "doc": "<h1><code>.^ \"dotket\"</code></h1>\n<p><code>[%dtkt p=model q=value]</code>: load from the Arvo namespace with Nock <code>11</code>.</p>\n<h2>Produces</h2>\n<p>The noun whose name is <code>q</code>, cast to the icon of <code>p</code>.</p>\n<h2>Discussion</h2>\n<p>Nock has no <code>11</code> instruction, of course.  But the virtual Nock\nused to run userspace code does.  Nock <code>11</code> loads from a\ntyped immutable namespace defined by its virtual context.</p>\n<p>We don't remold dynamically nouns in a <code>.^</code>, but we do check\nthat the type of the value nests in <code>p</code>.</p>\n"
    },
    {
        "keys": [
            ".+"
        ],
        "doc": "<h1><code>.+ \"dotlus\"</code></h1>\n<p><code>[%dtls p=atom]</code>: increment an atom with Nock <code>4</code>.</p>\n<h2>Produces</h2>\n<p><code>p</code> plus <code>1</code> if <code>p</code> is an atom; otherwise, crashes.  The product\natom has no aura.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<p>Irregular: <code>+(6)</code> is <code>.+(6)</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; .+(6)\n7\n~zod:dojo&gt; +(6)\n7\n~zod:dojo&gt; +(%foo)\n7.303.015\n~zod:dojo&gt; +([1 2])\n! nest-fail\n</code></pre>\n"
    },
    {
        "keys": [
            ".*"
        ],
        "doc": "<h1><code>.* \"dottar\"</code></h1>\n<p><code>[%dttr p=hoon q=hoon]</code>: evaluate with Nock <code>2</code>.</p>\n<h2>Produces</h2>\n<p>Nock of formula <code>q</code> and subject <code>p</code>, with type <code>%noun</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>Note that <code>.*</code> (\"dottar\") can be used to bypass the type system,\nthough its product contains no type information.  It's\nperfectly practical to use Hoon as a typeless language.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; .*([20 30] [0 2])\n20\n~zod:dojo&gt; .*(33 [4 0 1])\n34\n~zod:dojo&gt; .*(|.(50) [9 2 0 1])\n50\n~zod:dojo&gt; .*(12 [7 [`1 [4 `1]] [`2 `3 `2]])\n[12 13 12]\n~zod:dojo&gt; .*(~ [5 1^4 [4 1^3]])\n0\n~zod:dojo&gt; .*(~ [5 1^5 [4 1^3]])\n1\n</code></pre>\n"
    },
    {
        "keys": [
            ".="
        ],
        "doc": "<h1><code>.=  \"dottis\"</code></h1>\n<p><code>[%dtts p=hoon q=hoon]</code>: test for equality with Nock <code>5</code>.</p>\n<h2>Produces</h2>\n<p><code>&amp;</code>, <code>%.y</code>, <code>0</code> if <code>p</code> equals <code>q</code>; otherwise <code>|</code>, <code>%.n</code>, <code>1</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>=(a b)</code> is <code>.=(a b)</code>.</p>\n<h2>Discussion</h2>\n<p>Like Nock equality, <code>.=</code> (\"dottis\") tests if two nouns are the same,\nignoring invisible pointer structure.  Because in a conventional\nnoun implementation each noun has a lazy short hash, comparisons \nare fast unless the hash needs to be computed, or we are comparing\nseparate copies of identical nouns.  (Comparing large duplicates \nis a common cause of performance bugs.)</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; .=(0 0)\n%.y\n~zod:dojo&gt; =(0 0)\n%.y\n~zod:dojo&gt; .=(1 2)\n%.n\n~zod:dojo&gt; =(1 2)\n%.n\n</code></pre>\n"
    },
    {
        "keys": [
            ".?"
        ],
        "doc": "<h1><code>.? \"dotwut\"</code></h1>\n<p><code>[%dtwt p=hoon]</code>: test for cell or atom with Nock <code>3</code>.</p>\n<h2>Produces</h2>\n<p><code>&amp;</code>, <code>%.y</code>, <code>0</code> if <code>p</code> is a cell; otherwise <code>|</code>, <code>%.n</code>, <code>1</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; .?(42)\n%.n\n~zod:dojo&gt; .?([42 43])\n%.y\n</code></pre>\n"
    },
    {
        "keys": [
            "^|"
        ],
        "doc": "<h1><code>^| \"ketbar\"</code></h1>\n<p><code>[%ktbr p=hoon]</code>: convert a gold core to an iron core (contravariant).</p>\n<h2>Produces</h2>\n<p><code>p</code> as an iron core; crash if not a gold core.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>An iron core is an opaque function (gate or door).</p>\n<p>Theorem: if type <code>x</code> nests within type <code>a</code>, and type <code>y</code> nests\nwithin type <code>b</code>, a core accepting <code>b</code> and producing <code>x</code> nests\nwithin a iron core accepting <code>y</code> and producing <code>a</code>.</p>\n<p>Informally, a function fits an interface if the function has a\nmore specific result and/or a less specific argument than the\ninterface.</p>\n<h2>Examples</h2>\n<p>The prettyprinter shows the core metal (<code>.</code> gold, <code>|</code> iron):</p>\n<pre><code>~zod:dojo&gt; |=(@ 1)\n&lt;1.gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151&gt;]&gt;\n~zod:dojo&gt; ^|(|=(@ 1))\n&lt;1|gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151&gt;]&gt;\n</code></pre>\n"
    },
    {
        "keys": [
            "^-"
        ],
        "doc": "<h1><code>^- \"kethep\"</code></h1>\n<p><code>[%kthp p=model q=value]</code>: typecast by mold.</p>\n<h2>Expands to</h2>\n<pre><code>^+(*p q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>`foo`bar</code> is <code>^-(foo bar)</code>.</p>\n<h2>Discussion</h2>\n<p>It's a good practice to put a <code>^-</code> (\"kethep\") at the top of every arm\n(including gates, loops, etc).  This cast is strictly necessary\nonly in the presence of head recursion (otherwise you'll get a\n<code>rest-loop</code> error, or if you really screw up spectacularly an \ninfinite loop in the compiler).</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; (add 90 7)\n97\n~zod:dojo&gt; `@t`(add 90 7)\n'a'\n~zod:dojo&gt; ^-(@t (add 90 7))\n'a'\n/~zod:dojo&gt; =foo  |=  a=@tas\n                  ^-  (unit @ta)\n                  `a\n/~zod:dojo&gt; (foo 97)\n[~ ~.a]\n</code></pre>\n"
    },
    {
        "keys": [
            "^+"
        ],
        "doc": "<h1><code>^+ \"ketlus\"</code></h1>\n<p><code>[%ktls p=value q=value]</code>: typecast by example (hoon).</p>\n<h2>Produces</h2>\n<p>The value of <code>q</code> with the type of <code>p</code>, if the type of <code>q</code> nests\nwithin the type of <code>p</code>.  Otherwise, <code>nest-fail</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ^+('text' %a)\n'a'\n</code></pre>\n"
    },
    {
        "keys": [
            "^~"
        ],
        "doc": "<h1><code>^~ \"ketsig\"</code></h1>\n<p><code>[%ktsg p=hoon]</code>: fold constant at compile time.</p>\n<h2>Produces</h2>\n<p><code>p</code>, folded as a constant if possible.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; (make '|-(42)')\n[%8 p=[%1 p=[1 42]] q=[%9 p=2 q=[%0 p=1]]]\n~zod:dojo&gt; (make '^~(|-(42))')\n[%1 p=42]\n</code></pre>\n"
    },
    {
        "keys": [
            "^="
        ],
        "doc": "<h1><code>^= \"kettis\"</code></h1>\n<p><code>[%ktts p=toga q=value]</code>: name a value.</p>\n<h2>Produces</h2>\n<p>If <code>p</code> is a term, the product <code>q</code> with type <code>[%face p q]</code>.  <code>p</code>\nmay also be a tuple of terms, or a term-toga pair; the type of \n<code>q</code> must divide evenly into cells to match it.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>foo=bar</code> is <code>^=(foo bar)</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; a=1\na=1\n~zod:dojo&gt; ^=  a\n           1\na=1\n~zod:dojo&gt; ^=(a 1)\na=1\n~zod:dojo&gt; [b c d]=[1 2 3 4]\n[b=1 c=2 d=[3 4]]\n~zod:dojo&gt; [b c d=[x y]]=[1 2 3 4]\n[b=1 c=2 d=[x=3 y4]]\n</code></pre>\n"
    },
    {
        "keys": [
            "^?"
        ],
        "doc": "<h1><code>^? \"ketwut\"</code></h1>\n<p><code>[%ktwt p=hoon]</code>: convert any core to a lead core (bivariant).</p>\n<h2>Produces</h2>\n<p><code>p</code> as a lead core; crash if not a core.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>A lead core is an opaque generator; the payload can't be read or \nwritten.</p>\n<p>Theorem: if type <code>x</code> nests within type <code>a</code>, a lead core producing\n<code>x</code> nests within a lead core producing <code>a</code>.</p>\n<p>Informally, a more specific generator can be used as a less\nspecific generator.</p>\n<h2>Examples</h2>\n<p>The prettyprinter shows the core metal (<code>.</code> gold, <code>?</code> lead):</p>\n<pre><code>~zod:dojo&gt; |=(@ 1)\n&lt;1.gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151&gt;]&gt;\n~zod:dojo&gt; ^?(|=(@ 1))\n&lt;1?gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151&gt;]&gt;\n</code></pre>\n"
    },
    {
        "keys": [
            ";:"
        ],
        "doc": "<h1><code>;: \"semcol\"</code></h1>\n<p><code>[%smcl p=hoon q=(list hoon)]</code>: call a binary function as an n-ary function.</p>\n<h2>Expands to</h2>\n<p><em>Pseudocode</em>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>q</code>:</p>\n<p>Regular form:</p>\n<pre><code>%-(p a %-(p b %-(p c ...)))\n</code></pre>\n<p>Irregular form:</p>\n<pre><code>(p a (p b (p c ...)))\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>|-\n?~  q  !!\n?~  t.q  !!\n?~  t.t.q\n  (p i.q i.t.q)\n(p i.q $(q t.q))\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>running</em>.</p>\n<p>Irregular: <code>:(add a b c)</code> is <code>;:(add a b c)</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; (add 3 (add 4 5))\n12\n~zod:dojo&gt; ;:(add 3 4 5)\n12\n~zod:dojo&gt; :(add 3 4 5)\n12\n</code></pre>\n"
    },
    {
        "keys": [
            ";/"
        ],
        "doc": "<h1><code>;/ \"semfas\"</code></h1>\n<p><code>[%smfs p=hoon]</code>: tape as XML element.</p>\n<h2>Expands to</h2>\n<pre><code>~[%$ ~[%$ 'p']]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; :/\"foo\"\n[[%~. [%~. \"foo] ~] ~]\n</code></pre>\n"
    },
    {
        "keys": [
            ";;"
        ],
        "doc": "<h1><code>;; \"semsem\"</code></h1>\n<p><code>[%smsm p=model q=value]</code>: normalize with a mold, asserting fixpoint.</p>\n<h2>Expands to</h2>\n<pre><code>=+  a=(p q)\n?&gt;  =(`*`a `*`q)\na\n</code></pre>\n<blockquote><p>Note: the expansion implementation is hygienic -- it doesn't actually add the\n<code>a</code> face to the subject.</p>\n</blockquote>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p>Fails because of auras:</p>\n<pre><code>~zod:dojo&gt; ^-(tape ~[97 98 99])\n! nest-fail\n! exit\n</code></pre>\n<p>Succeeds because molds don't care about auras:</p>\n<pre><code>~zod:dojo&gt; ;;(tape ~[97 98 99])\n\"abc\"\n</code></pre>\n<p>Succeeds because the mold normalizes:</p>\n<pre><code>~zod:dojo&gt; (tape [50 51 52])\n\"23\"\n</code></pre>\n<p>Fails because not a fixpoint:</p>\n<pre><code>~zod:dojo&gt; ;;(tape [50 51 52])\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            ";~"
        ],
        "doc": "<h1><code>;~ \"semsig\"</code></h1>\n<p><code>[%smsg p=hoon q=(list hoon)]</code>: glue a pipeline together with a \nproduct-sample adapter.</p>\n<h2>Produces</h2>\n<p>The gates in <code>q</code> connected together using the gate <code>p</code>, which \ntransforms a <code>q</code> product and a <code>q</code> gate into a <code>q</code> sample.</p>\n<h2>Expands to</h2>\n<p><em>Note: these are structurally correct, but elide some type-system complexity.</em></p>\n<p><code>;~(a b)</code> reduces to <code>b</code>.</p>\n<p><code>;~(a b c)</code> expands to</p>\n<pre><code>|=  arg=*\n(a (b arg) c(+6 arg))\n</code></pre>\n<p><code>;~(a b c d)</code> expands to</p>\n<pre><code>|=  arg=*\n%+  a (b arg)\n=+  arg=arg\n|.  (a (c arg) d(+6 arg))\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>?~  q  !!\n|-\n?~  t.q  i.q\n=/  a  $(q t.q)\n=/  b  i.q\n=/  c  ,.+6.b\n|.  (p (b c) a(,.+6 c))\n</code></pre>\n<h2>Discussion</h2>\n<p>Apparently <code>;~</code> (\"semsig\") is a \"Kleisli arrow.\"  Whatevs.  It's also \na close cousin of the infamous \"monad.\"  Don't let that bother\nyou either.  Hoon doesn't know anything about category theory,\nso you don't need to either.</p>\n<p><code>;~</code> is often used in parsers, but is not only for parsers.</p>\n<p>This can be thought of as user-defined function composition; instead of simply\nnesting the gates in <code>q</code>, each is passed individually to <code>p</code> with the product\nof the previous gate, allowing arbitrary filtering, transformation, or\nconditional application.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>running</em>.</p>\n<h2>Examples</h2>\n<p>A simple \"parser.\"  <code>trip</code> converts a <code>cord</code> (atomic string) to\na <code>tape</code> (linked string).</p>\n<pre><code>~zod:dojo&gt; =cmp |=([a=tape b=$-(char tape)] `tape`?~(a ~ (weld (b i.a) t.a)))\n~zod:dojo&gt; ;~(cmp trip)\n&lt;1.zje {a/@ &lt;409.yxa 110.lxv 1.ztu $151&gt;}&gt;\n~zod:dojo&gt; (;~(cmp trip) 'a')\n\"a\"\n</code></pre>\n<p>With just one gate in the pipeline <code>q</code>, the glue <code>p</code> is unused:</p>\n<pre><code>~zod:dojo&gt; (;~(cmp trip |=(a=@ ~[a a])) 'a')\n\"aa\"\n~zod:dojo&gt; (;~(cmp trip |=(a=@ ~[a a])) '')\n\"\"\n</code></pre>\n<p>But for multiple gates, we need it to connect the pipeline:</p>\n<pre><code>~zod:dojo&gt; (;~(cmp trip ;~(cmp |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;))) 'b')\n\"97b\"\n~zod:dojo&gt; (;~(cmp trip |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;)) 'b')\n\"97b\"\n~zod:dojo&gt; (;~(cmp trip |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;)) '')\n\"\"\n~zod:dojo&gt; (;~(cmp trip |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;)) 'a')\n\"96a\"\n~zod:dojo&gt; (;~(cmp trip |=(a=@ ~[a a]) |=(a=@ &lt;(dec a)&gt;)) 'acd')\n\"96acd\"\n</code></pre>\n"
    },
    {
        "keys": [
            "~|"
        ],
        "doc": "<h1><code>~| \"sigbar\"</code></h1>\n<p><code>[%sgbr p=hoon q=hoon]</code>: tracing printf.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>Prettyprints <code>p</code> in stack trace if <code>q</code> crashes.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ~|('sample error message' !!)\n'sample error message'\nford: build failed\n\n~zod:dojo&gt; ~|  'sample error message' \n           !!\n'sample error message'\nford: build failed\n</code></pre>\n"
    },
    {
        "keys": [
            "~$"
        ],
        "doc": "<h1><code>~$ \"sigbuc\"</code></h1>\n<p><code>[%sgbc p=term q=hoon]</code>: profiling hit counter.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>If profiling is on, adds 1 to the hit counter for <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ~$(%foo 3)\n3\n</code></pre>\n"
    },
    {
        "keys": [
            "~_"
        ],
        "doc": "<h1><code>~_ \"sigcab\"</code></h1>\n<p><code>[%sgcb p=hoon q=hoon]</code>: user-formatted tracing printf.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>Shows <code>p</code> in stacktrace if <code>q</code> crashes.</p>\n<h2>Discussion</h2>\n<p><code>p</code> must produce a <code>tank</code> (prettyprint source).</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ~_([%leaf \"sample error message\"] !!)\n\"sample error message\"\nford: build failed\n\n~zod:dojo&gt; ~_  [%leaf \"sample error message\"] \n           !!\n\"sample error message\"\nford: build failed\n</code></pre>\n"
    },
    {
        "keys": [
            "~%"
        ],
        "doc": "<h1><code>~% \"sigcen\"</code></h1>\n<p><code>[%sgcn p=term q=wing r=(list [term hoon]) s=hoon]</code>: jet registration.</p>\n<h2>Expands to</h2>\n<p><code>s</code>.</p>\n<h2>Convention</h2>\n<p>Register a core with name <code>p</code>, with parent at leg <code>q</code>, exporting\nthe named formulas <code>r</code>, constructed by <code>s</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.  For <code>r</code>, use <code>~</code> if empty.  Otherwise, <em>jogging</em> \nbetween opening and closing <code>==</code>.</p>\n<h2>Discussion</h2>\n<p><code>~%</code> (\"sigcen\" is for registering cores.  A registered core declares its\nformal identity to the interpreter, which may or may not be able\nto recognize and/or accelerate it.</p>\n<p>Registered cores are organized in a containment hierarchy.\nThe parent core is at any leg within the child core.  When we\nregister a core, we state the leg to its parent, in the form of\nwing <code>q</code>.  We assume the parent is already registered -- as it\nmust be, if (a) we registered it on creation, (b) the child was\ncreated by an arm defined on the parent.</p>\n<p>(Cores are actually managed by their formula/battery.  Any\nfunction call will create a new core with a new sample, but\nbatteries are constant.  But it is not sufficient to match the\nbattery -- matching the semantics constrains the payload as well,\nsince the semantics of a battery may depend on any parent core\nand/or payload constant.)</p>\n<p>The purpose of registration is always performance-related.  It\nmay involve (a) a special-purpose optimizer or \"jet\", written\nfor a specific core and checked with a Merkle hash; (b) a\ngeneral-purpose hotspot optimizer or \"JIT\"; or (c) merely a\nhotspot declaration for profiling.</p>\n<p>As always with hints, the programmer has no idea which of (a),\n(b), and (c) will be applied.  She should use <code>~%</code>\nindiscriminately on all hotspots, bottlenecks, etc, real or\nsuspected.</p>\n<p>The list <code>r</code> is a way for the Hoon programmer to help jet\nimplementors with named Nock formulas that act on the core.\nIn complex systems, jet implementations are often partial and\nwant to call back into userspace.</p>\n<p>The child core contains the parent, of course.  When we register\na core, we state the leg to its parent, in the form of wing <code>q</code>.\nWe assume that the parent -- any core within the payload -- is\nalready registered.</p>\n<p>must already be registered.\nThe interpreter can thus</p>\n<p><code>p</code> is the name of this core within its parent; <code>q</code> is a the leg</p>\n<p>Registers a jet in core <code>s</code> so that it can be called when that code is run.</p>\n<p>Regularm form: <em>4-fixed</em></p>\n<h2>Examples</h2>\n<p>Here's the AES</p>\n<pre><code>++  aesc                                                ::  AES-256\n  ~%  %aesc  +  ~\n  |%\n  ++  en                                                ::  ECB enc\n    ~/  %en\n    |=  [a=@I b=@H]  ^-  @uxH\n    =+  ahem\n    (be &amp; (ex a) b)\n  ++  de                                                ::  ECB dec\n    ~/  %de\n    |=  [a=@I b=@H]  ^-  @uxH\n    =+  ahem\n    (be | (ix (ex a)) b)\n  --\n</code></pre>\n<p>Here we label the entire <code>++aesc</code> core for optimization. You can see the\njet in <code>jets/e/aesc.c</code>.</p>\n"
    },
    {
        "keys": [
            "~/"
        ],
        "doc": "<h1><code>~/ \"sigfas\"</code></h1>\n<p><code>[%sgfs p=term q=hoon]</code>: jet registration for gate with\nregistered context.</p>\n<h2>Expands to</h2>\n<pre><code>~%(p +7 ~ q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p>From the kernel:</p>\n<pre><code>++  add\n  ~/  %add\n  |=  [a=@ b=@]\n  ^-  @\n  ?:  =(0 a)  b\n  $(a (dec a), b +(b))\n</code></pre>\n"
    },
    {
        "keys": [
            "~<"
        ],
        "doc": "<h1><code>~&lt; \"siggal\"</code></h1>\n<p><code>[%sggl p=$@(term [p=term q=hoon]) q=hoon]</code>: raw hint, applied to \nproduct.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.  For the dynamic form, write <code>%term.hoon</code>.</p>\n<h2>Discussion</h2>\n<p><code>~&lt;</code> (\"siggal\") is only used for jet hints (<a href=\"../fas/\"><code>~/</code> (\"sigfas\")</a> \nand <a href=\"../cen/\"><code>~%</code> (\"sigcen\")</a>) at the moment; we are not telling the \ninterpreter something about the computation we're about to perform, but \nrather about its product.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; (make '~&lt;(%a 42)')\n[%7 p=[%1 p=42] q=[%10 p=97 q=[%0 p=1]]]\n~zod:dojo&gt; (make '~&lt;(%a.+(.) 42)')\n[%7 p=[%1 p=42] q=[%10 p=[p=97 q=[%4 p=[%0 p=1]]] q=[%0 p=1]]]\n</code></pre>\n"
    },
    {
        "keys": [
            "~>"
        ],
        "doc": "<h1><code>~&gt; \"siggar\"</code></h1>\n<p><code>[%sggr p=$@(term [p=term q=hoon]) q=hoon]</code>: raw hint, applied\nto computation.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.  For the dynamic form, write <code>%term.hoon</code>.</p>\n<h2>Discussion</h2>\n<p>Hoon has no way of telling what hints are used and what aren't.\nHints are all conventions at the interpreter level.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ~&gt;(%a 42)\n42\n</code></pre>\n<p>Running the compiler:</p>\n<pre><code>~zod:dojo&gt; (make '~&gt;(%a 42)')\n[%10 p=97 q=[%1 p=42]]\n\n~zod:dojo&gt; (make '~&gt;(%a.+(2) 42)')\n[%10 p=[p=97 q=[%4 p=[%1 p=2]]] q=[%1 p=42]]\n</code></pre>\n"
    },
    {
        "keys": [
            "~+"
        ],
        "doc": "<h1><code>~+ \"siglus\"</code></h1>\n<p><code>[%sgls p=hoon]</code>: cache a computation.</p>\n<h2>Expands to</h2>\n<p><code>p</code>.</p>\n<h2>Convention</h2>\n<p>Caches the formula and subject of <code>p</code> in a local cache (generally \ntransient in the current event).</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<p>This may pause for a second:</p>\n<pre><code>~zod:dojo&gt; %.(25 |=(a=@ ?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a))))))\n121.393\n</code></pre>\n<p>This may make you want to press <code>ctrl-c</code>:</p>\n<pre><code>~zod:dojo&gt; %.(30 |=(a=@ ?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a))))))\n1.346.269\n</code></pre>\n<p>This should work fine:</p>\n<pre><code>~zod:dojo&gt; %.(100 |=(a=@ ~+(?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a)))))))\n573.147.844.013.817.084.101\n</code></pre>\n"
    },
    {
        "keys": [
            "~&"
        ],
        "doc": "<h1><code>~&amp; \"sigpam\"</code></h1>\n<p><code>[%sgpm p=hoon q=hoon]</code>: debugging printf.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>Prettyprints <code>p</code> on the console before computing <code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ~&amp;('halp' ~)\n'halp'\n~\n\n~zod:dojo&gt; ~&amp;  'halp' \n           ~\n'halp'\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "~="
        ],
        "doc": "<h1><code>~= \"sigtis\"</code></h1>\n<p><code>[%sgts p=hoon q=hoon]</code>: detect duplicate.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>If <code>p</code> equals <code>q</code>, produce <code>p</code> instead of <code>q</code>.</p>\n<h2>Discussion</h2>\n<p>Duplicates are especially bad news in Hoon, because comparing them\ntakes O(n) time.  Use <code>~=</code> (\"sigtis\") to kill them as they breed.</p>\n<h2>Examples</h2>\n<p>This code traverses a tree and replaces all instances of <code>42</code> with\n<code>420</code>:</p>\n<pre><code>~zod:dojo&gt; =foo |=  a=(tree) \n                ?~(a ~ ~=(a [?:(=(n.a 42) 420 n.a) $(a l.a) $(a r.a)]))\n~zod:dojo&gt; (foo 42 ~ ~)\n[420 ~ ~]\n</code></pre>\n<p>Without <code>~=</code>, it would build a copy of a completely unchanged tree.  Sad!</p>\n"
    },
    {
        "keys": [
            "~?"
        ],
        "doc": "<h1><code>~? \"sigwut\"</code></h1>\n<p><code>[%sgwt p=hoon q=hoon r=hoon]</code>: conditional debug printf.</p>\n<h2>Expands to</h2>\n<p><code>r</code>.</p>\n<h2>Convention</h2>\n<p>If <code>p</code> is true, prettyprints <code>q</code> on the console before computing <code>r</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ~?((gth 1 2) 'oops' ~)\n~\n\n~zod:dojo&gt; ~?((gth 1 0) 'oops' ~)\n'oops'\n~\n\n~zod:dojo&gt; ~?  (gth 1 2) \n             'oops' \n           ~\n~\n\n~zod:dojo&gt; ~?  (gth 1 0) \n             'oops'\n           ~\n'oops'\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "~!"
        ],
        "doc": "<h1><code>~! \"sigzap\"</code></h1>\n<p><code>[%sgzp p=hoon q=hoon]</code>: print type on compilation fail.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>If compilation of <code>q</code> fails, prints the type of <code>p</code> in the trace.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; a\n! -find.a\n\n~zod:dojo&gt; ~!('foo' a)\n! @t\n! find.a\n\n~zod:dojo&gt; ~!  'foo' \n           a\n! @t\n! find.a\n</code></pre>\n"
    },
    {
        "keys": [
            "=|"
        ],
        "doc": "<h1><code>=| \"tisbar\"</code></h1>\n<p><code>[%tsbr p=model q=value]</code>: combine a defaulted mold with the subject.</p>\n<h2>Expands to</h2>\n<pre><code>=+(*p q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>=|</code> \"declares a variable\" which is \"uninitialized,\" presumably \nbecause you'll set it in a loop or similar.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo  |=  a=@\n                 =|  b=@\n                 =-  :(add a b c)\n                 c=2 \n~zod:dojo&gt; (foo 5)\n7\n</code></pre>\n"
    },
    {
        "keys": [
            "=:"
        ],
        "doc": "<h1><code>=: \"tiscol\"</code></h1>\n<p><code>[%tscl p=(list (pair wing hoon)) q=hoon]</code>: change multiple legs in the subject.</p>\n<h2>Expands to</h2>\n<pre><code>=&gt;(%_(. p) q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>jogging</em>, then <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =+  a=[b=1 c=2]\n           =:  c.a  4\n               b.a  3\n             ==\n           a\n[b=3 c=4]\n</code></pre>\n"
    },
    {
        "keys": [
            "=."
        ],
        "doc": "<h1><code>=. \"tisdot\"</code></h1>\n<p><code>[%tsdt p=wing q=hoon r=hoon]</code>: change one leg in the subject.</p>\n<h2>Expands to</h2>\n<pre><code>=&gt;(%_(. p q) r)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>As usual, we are not actually mutating the subject, just creating\na new subject with a changed value.  Note that the mutation uses\n<a href=\"../../cen/cab/\"><code>%_</code> (\"cencab\")</a>, so the type doesn't change.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =+  a=[b=1 c=2]\n           =.  b.a  3\n           a\n[b=3 c=2]\n\n~zod:dojo&gt; =+  a=[b=1 c=2]\n           =.(b.a 3 a)\n[b=3 c=2]\n</code></pre>\n"
    },
    {
        "keys": [
            "=/"
        ],
        "doc": "<h1><code>=/ \"tisfas\"</code></h1>\n<p><code>[%tsfs p=taco q=hoon r=hoon]</code>: combine a named and/or typed \nnoun with the subject.</p>\n<h2>Expands to</h2>\n<p><em>if <code>p</code> is a symbol</em>:</p>\n<pre><code>=+(^=(p q) r)\n</code></pre>\n<p><em>if <code>p</code> is a symbol with a mold</em>:</p>\n<pre><code>=+(^-(p q) r)\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>?@  p\n  =+  p=q\n  r\n=+  ^-($=(p.p q.p) q)\nr\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>p</code> can be either a symbol or a symbol/mold.  If it's just a symbol,\n<code>=/</code> (\"tisfas\") \"declares a type-inferred variable.\"  If it has a mold, <code>=/</code>\n\"declares a type-checked variable.\"</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo  |=  a=@\n                 =/  b  1\n                 =/  c=@  2\n                 :(add a b c)\n~zod:dojo&gt; (foo 5)\n8\n</code></pre>\n"
    },
    {
        "keys": [
            "=<"
        ],
        "doc": "<h1><code>=&lt; \"tisgal\"</code></h1>\n<p><code>[%tsgl p=hoon q=hoon]</code>: compose two hoons, inverted.</p>\n<h2>Expands to</h2>\n<pre><code>=&gt;(q p)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>foo:bar</code> is <code>=&lt;(foo bar)</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =&lt;(b [a=1 b=2 c=3])\n2\n\n~zod:dojo&gt; =&lt;  b \n           [a=1 b=2 c=3]\n2\n\n~zod:dojo&gt; b:[a=1 b=2 c=3]\n2\n\n~zod:dojo&gt; [. .]:(add 2 4)\n[6 6]\n</code></pre>\n"
    },
    {
        "keys": [
            "=>"
        ],
        "doc": "<h1><code>=&gt; \"tisgar\"</code></h1>\n<p><code>[%tsgr p=hoon q=hoon]</code>: compose two hoons.</p>\n<h2>Produces</h2>\n<p><code>q</code>, compiled against the product of <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =&gt;([a=1 b=2 c=3] b)\n2\n~zod:dojo&gt; =&gt;((add 2 4) [. .])\n[6 6]\n</code></pre>\n"
    },
    {
        "keys": [
            "=-"
        ],
        "doc": "<h1><code>=- \"tishep\"</code></h1>\n<p><code>[%tshp p=hoon q=hoon]</code>: combine a new noun with the subject, inverted.</p>\n<h2>Expands to</h2>\n<pre><code>=&gt;([q .] p)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>=-</code> looks better than <code>=+</code> when the hoon you're pinning \nis much smaller than the hoon that uses it.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo  |=  a=@\n                 =+  b=1\n                 =-  (add a b c)\n                 c=2 \n~zod:dojo&gt; (foo 5)\n8\n</code></pre>\n"
    },
    {
        "keys": [
            "=^"
        ],
        "doc": "<h1><code>=^ \"tisket\"</code></h1>\n<p><code>[%tskt p=taco q=wing r=hoon s=hoon]</code>: pin the head of a pair; change \na leg with the tail.</p>\n<h2>Expands to</h2>\n<pre><code>=/(p -.r =.(q +.r s))\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>We use <code>=^</code> (\"tisket\" when we have a state machine with a function that\nproduces a cell, whose head is a result and whose tail is a new\nstate.  We want to use the head as a new variable, and stuff the\ntail back into wherever we stored the old state.</p>\n<p>This may also remind you of Haskell's State monad.</p>\n<h2>Examples</h2>\n<p>The <code>og</code> core is a stateful pseudo-random number generator.\nWe have to change the core state every time we generate a\nrandom number, so we use <code>=^</code>:</p>\n<pre><code>~zod:dojo&gt; =+  rng=~(. og 420)\n           =^  r1  rng  (rads:rng 100)\n           =^  r2  rng  (rads:rng 100)\n           [r1 r2]\n[99 46]\n</code></pre>\n"
    },
    {
        "keys": [
            "=+"
        ],
        "doc": "<h1><code>=+ \"tislus\"</code></h1>\n<p><code>[%tsls p=hoon q=hoon]</code>: combine a new noun with the subject.</p>\n<h2>Expands to</h2>\n<pre><code>=&gt;([p .] q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>=+</code> (\"tislus\") is the simplest way of \"declaring a variable.\"</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo  |=  a=@\n                 =+  b=1\n                 =+  c=2\n                 :(add a b c)\n~zod:dojo&gt; (foo 5)\n8\n</code></pre>\n"
    },
    {
        "keys": [
            "=;"
        ],
        "doc": "<h1><code>=; \"tissem\"</code></h1>\n<p><code>[%tssm p=taco q=hoon r=hoon]</code>: combine a named and/or typed noun with the\nsubject, inverted.</p>\n<h2>Expands to</h2>\n<pre><code>=/(p r q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo  |=  a=@\n                 =/   b  1\n                 =;   c=@  :(add a b c)\n                 2\n~zod:dojo&gt; (foo 5)\n8\n</code></pre>\n"
    },
    {
        "keys": [
            "=~"
        ],
        "doc": "<h1><code>=~ \"tissig\"</code></h1>\n<p><code>[%tssg p=(list hoon)]</code>: compose many hoons.</p>\n<h2>Produces</h2>\n<p>The product of the chain composition.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo =|  n=@ \n                =&lt;  =~  increment\n                        increment\n                        increment\n                        n\n                    ==\n                |%\n                ++  increment\n                  |-  \n                  ..increment(n +(n))\n                --\n~zod:dojo&gt; foo\n3\n</code></pre>\n"
    },
    {
        "keys": [
            "=*"
        ],
        "doc": "<h1><code>=* \"tistar\"</code></h1>\n<p><code>[%tstr p=term q=hoon r=hoon]</code>: define an alias.</p>\n<h2>Produces</h2>\n<p><code>r</code>, compiled with a subject in which <code>p</code> is aliased to <code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>The difference between aliasing and pinning is that the subject\nnoun stays the same; the alias is just recorded in its type.\n<code>q</code> is calculated every time you use the <code>p</code> alias, of course.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt;\n    =+  a=1\n    =*  b  a\n    [a b]\n[1 1]\n\n~zod:dojo&gt;\n    =+  a=1\n    =*  b  a\n    =.  a  2\n    [a b]\n[2 2]\n</code></pre>\n"
    },
    {
        "keys": [
            "?|"
        ],
        "doc": "<h1><code>?| \"wutbar\"</code></h1>\n<p><code>[%wtbr p=(list hoon)]</code>: logical or.</p>\n<h2>Expands to</h2>\n<p><em>Pseudocode</em>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>p</code>:</p>\n<pre><code>?:(a &amp; ?:(b &amp; ?:(c &amp; ?:(... ?:(z &amp; |)))))\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>|-\n?~  p\n  |\n?:  i.p\n  &amp;\n$(p t.p)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<p>Irregular: <code>|(foo bar baz)</code> is <code>?|(foo bar baz)</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; |(=(6 42) =(42 42))\n%.y\n\n~zod:dojo&gt; |(=(6 42) =(42 43))\n%.n\n</code></pre>\n"
    },
    {
        "keys": [
            "?:"
        ],
        "doc": "<h1><code>?: \"wutcol\"</code></h1>\n<p><code>[%wtcl p=hoon q=hoon r=hoon]</code>: branch on a boolean test.</p>\n<h2>Produces</h2>\n<p>If <code>p</code> produces yes, then <code>q</code>. If <code>p</code> produces no, <code>r</code>.\nIf <code>p</code> is not a boolean, compiler yells at you.</p>\n<p>The subjects of <code>q</code> and <code>r</code> are constrained to match any\npattern-matching algebra in <code>p</code>.  The analysis, which is\nconservative, understands any combination of <a href=\"../tis/\"><code>?=</code> (\"wuttis\")</a>, \n<a href=\"../pam/\"><code>?&amp;</code> (\"wutpam\")</a>, <a href=\"../bar/\"><code>?|</code> (\"wutbar\")</a>, and \n<a href=\"../zap/\"><code>?!</code> (\"wutzap\")</a>, and reduces the subject appropriately when \ncompiling.</p>\n<p>If test analysis reveals that either branch is not taken,\nor if <code>p</code> is not a boolean, compilation fails.  However,\nan untaken branch can be indicated with the <code>%lost</code> hoon.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>Short-circuiting in boolean tests works as you'd expect\nand includes the expected inference.  For instance,\nif you write <code>?&amp;(a b)</code>, <code>b</code> is only executed if <code>a</code> is\npositive, and compiled with that assumption.</p>\n<p>Note also that all other branching hoons reduce to <code>?:</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ?:((gth 1 0) 3 4)\n3\n\n~zod:dojo&gt; ?:  (gth 1 0) \n             3 \n           4\n3\n\n~zod:dojo&gt; ?:((gth 1 2) 3 4)\n4\n\n~zod:dojo&gt; ?:  (gth 1 2) \n             3 \n           4\n4\n</code></pre>\n"
    },
    {
        "keys": [
            "?."
        ],
        "doc": "<h1><code>?. \"wutdot\"</code></h1>\n<p><code>[%wtdt p=hoon q=hoon r=hoon]</code>: branch on a boolean test, inverted.</p>\n<h2>Expands to</h2>\n<pre><code>?:(p r q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>As usual with inverted forms, use <code>?.</code> (\"wutdot\") when the positive\nhoon of an <code>?:</code> (\"wutcol\") is much heavier than the negative hoon.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ?.((gth 1 2) 3 4)\n3\n\n~zod:dojo&gt; ?.(?=(%a 'a') %not-a %yup)\n%yup\n\n~zod:dojo&gt; ?.  %.y\n             'this false case is less heavy than the true case'\n           ?:  =(2 3)\n             'two not equal to 3'\n           'but see how \\'r is much heavier than \\'q?'\n'but see how \\'r is much heavier than \\'q?'\n</code></pre>\n"
    },
    {
        "keys": [
            "?<"
        ],
        "doc": "<h1><code>?&lt; \"wutgal\"</code></h1>\n<p><code>[%wtgl p=hoon q=hoon]</code>: negative assertion.</p>\n<h2>Expands to</h2>\n<pre><code>?:(p !! q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ?&lt;(=(3 4) %foo)\n%foo\n\n~zod:dojo&gt; ?&lt;(=(3 3) %foo)\nford: build failed\n</code></pre>\n"
    },
    {
        "keys": [
            "?>"
        ],
        "doc": "<h1><code>?&gt; \"wutgar\"</code></h1>\n<p><code>[%wtgr p=hoon q=hoon]</code>: positive assertion.</p>\n<h2>Expands to</h2>\n<pre><code>?.(p !! q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ?&gt;(=(3 3) %foo)\n%foo\n\n~zod:dojo&gt; ?&gt;(=(3 4) %foo)\nford: build failed\n</code></pre>\n"
    },
    {
        "keys": [
            "?-"
        ],
        "doc": "<h1><code>?- \"wuthep\"</code></h1>\n<p><code>[%wthp p=wing q=(list (pair model value))]</code>: switch against a \nunion, with no default.</p>\n<h2>Expands to</h2>\n<p><em>Pseudocode</em>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>q</code>:</p>\n<pre><code>?:  ?=(p.a)  q.a\n?:  ?=(p.b)  q.b\n?:  ?=(p.c)  q.c\n...\n~|(%mint-lost !!)\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>|-\n?.  q\n  ~|(%mint-lost !!)\n?:  ?=(p.i.q p)\n  q.i.q\n$(q t.q)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>jogging</em>.</p>\n<h2>Discussion</h2>\n<p>The compiler makes sure that your code neither misses a case of\nthe union, nor includes a double case that isn't there.  This is\nnot special handling for <code>?-</code> (\"wuthep\"), just a consequence of the\nsemantics of <code>?:</code> (\"wutcol\"), which <code>?-</code> reduces to.</p>\n<p>A missing case will throw the <code>mint-lost</code> error.  An extra case\nwill throw <code>mint-vain</code>.  (Ecclesiastes did nothing wrong.)</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =cor  |=  vat=?($a $b)\n                 ?-  vat\n                   $a  20\n                   $b  42\n                 ==\n~zod:dojo&gt; (cor %a)\n20\n~zod:dojo&gt; (cor %b)\n42\n~zod:dojo&gt; (cor %c)\n! nest-fail\n</code></pre>\n"
    },
    {
        "keys": [
            "?^"
        ],
        "doc": "<h1><code>?^ \"wutket\"</code></h1>\n<p><code>[%wtkt p=wing q=hoon r=hoon]</code>: branch on whether a wing \nof the subject is a cell.</p>\n<h2>Expands to</h2>\n<pre><code>?:(?=(^ p) q r)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>Regular form: <em>3-fixed</em></p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ?^(0 1 2)\n! mint-vain\n! exit\n\n~zod:dojo&gt; ?^(`*`0 1 2)\n2\n\n~zod:dojo&gt; ?^(`*`[1 2] 3 4)\n3\n</code></pre>\n"
    },
    {
        "keys": [
            "?+"
        ],
        "doc": "<h1><code>?+ \"wutlus\"</code></h1>\n<p><code>[%wtls p=wing q=value r=(list (pair model value))]</code>: switch against \na union, with a default.</p>\n<h2>Expands to</h2>\n<p><em>Pseudocode</em>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>r</code>:</p>\n<pre><code>?:  ?=(p.a)  q.a\n?:  ?=(p.b)  q.b\n?:  ?=(p.c)  q.c\n...\nq\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>|-\n?.  r\n  q\n?:  ?=(p.i.r p)\n  q.i.r\n$(r t.r)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>, then <em>jogging</em>.</p>\n<h2>Discussion</h2>\n<p>An extra case will throw <code>mint-vain</code>.  A lost case defaults.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =cor  |=  vat=?($a $b)\n                 ?+  vat  240\n                   $a  20\n                   $b  42\n                 ==\n~zod:dojo&gt; (cor %a)\n20\n~zod:dojo&gt; (cor %b)\n42\n~zod:dojo&gt; (cor %c)\n240\n</code></pre>\n"
    },
    {
        "keys": [
            "?&"
        ],
        "doc": "<h1><code>?&amp; \"wutpam\"</code></h1>\n<p><code>[%wtpm p=(list hoon)]</code>: logical and.</p>\n<h2>Expands to</h2>\n<p><em>Pseudocode</em>: <code>a</code>, <code>b</code>, <code>c</code>, ... as elements of <code>p</code>:</p>\n<pre><code>?.(a | ?.(b | ?.(c | ?.(... ?.(z | &amp;)))))\n</code></pre>\n<h3>Compiler macro</h3>\n<pre><code>|-\n?~  p\n  &amp;\n?.  i.p\n  |\n$(p t.p)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<p>Irregular: <code>&amp;(foo bar baz)</code> is <code>?&amp;(foo bar baz)</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; &amp;(=(6 6) =(42 42))\n%.y\n\n~zod:dojo&gt; &amp;(=(6 7) =(42 43))\n%.n\n</code></pre>\n"
    },
    {
        "keys": [
            "?@"
        ],
        "doc": "<h1><code>?@ \"wutpat\"</code></h1>\n<p><code>[%wtpt p=wing q=hoon r=hoon]</code>: branch on whether a wing \nof the subject is an atom.</p>\n<h2>Expands to</h2>\n<pre><code>?:(?=(@ p) q r)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ?@(0 1 2)\n! mint-vain\n! exit\n~zod:dojo&gt; ?@(`*`0 1 2)\n1\n~zod:dojo&gt; ?@(`*`[1 2] 3 4)\n4\n</code></pre>\n"
    },
    {
        "keys": [
            "?~"
        ],
        "doc": "<h1><code>?~ \"wutsig\"</code></h1>\n<p><code>[%wtsg p=wing q=hoon r=hoon]</code>: branch on whether a wing \nof the subject is null.</p>\n<h2>Expands to</h2>\n<pre><code>?:(?=($~ p) q r)\n</code></pre>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>It's bad style to use <code>?~</code> to test for any zero atom.  Use it\nonly for a true null, <code>~</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =foo \"\"\n~zod:dojo&gt; ?~(foo 1 2)\n1\n</code></pre>\n"
    },
    {
        "keys": [
            "?="
        ],
        "doc": "<h1><code>?= \"wuttis\"</code></h1>\n<p><code>[%wtts p=model q=wing]</code>: test pattern match.</p>\n<h2>Produces</h2>\n<p><code>&amp;</code> (yes) if the noun at <code>q</code> is in the icon of <code>p</code>;\n<code>|</code> (no) otherwise.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>?=</code> (\"wuttis\") is not as powerful as it might seem.  For instance, it\ncan't generate a loop -- you cannot (and should not) use it to \ntest whether a <code>*</code> is a <code>(list @)</code>.  Nor can it validate atomic \nauras.</p>\n<p>Patterns should be as weak as possible.  Unpack one layer of\nunion at a time.  Don't confirm things the type system knows.</p>\n<p>For example, when matching a book containing a page <code>[%foo p=@\nq=[@ @]]</code>, the proper pattern is <code>[%foo *]</code>.  You have one\nquestion, which is whether the head of the noun is <code>%foo</code>.</p>\n<p>A common error is <code>find.$</code>, meainng <code>p</code> is not a mold.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; =bar [%foo %bar %baz]\n~zod:dojo&gt; ?=([%foo *] bar)\n%.y\n</code></pre>\n"
    },
    {
        "keys": [
            "?!"
        ],
        "doc": "<h1><code>?! \"wutzap\"</code></h1>\n<p><code>[%wtzp p=hoon]</code>: logical not.</p>\n<h2>Expands to</h2>\n<pre><code>.=(| p)\n</code></pre>\n<p>Produces the logical \"not\" of <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<p>Irregular: <code>!foo</code> is <code>?!(foo)</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; ?!(.=(1 2))\n%.y\n\n~zod:dojo&gt; !&amp;\n%.n\n\n~zod:dojo&gt; !|\n%.y\n\n~zod:dojo&gt; !(gth 5 6)\n%.y\n</code></pre>\n"
    },
    {
        "keys": [
            "!>"
        ],
        "doc": "<h1><code>!&gt; \"zapgar\"</code></h1>\n<p><code>[%zpgr p=hoon]</code>: wrap a noun in its type.</p>\n<h2>Produces</h2>\n<p>A cell whose tail is <code>p</code>, and whose head is the static type of p.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>In Hoon, dynamic type is static type compiled at runtime.  This\ntype-noun cell is generally called a <code>vase</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; !&gt;(1)\n[p=#t/@ud q=1]\n</code></pre>\n"
    },
    {
        "keys": [
            "!="
        ],
        "doc": "<h1><code>!= \"zaptis\"</code></h1>\n<p><code>[%zpts p=hoon]</code>: make the Nock formula for a hoon.</p>\n<h2>Produces</h2>\n<p>The Nock generated by <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; !=(20)\n[1 20]\n~zod:dojo&gt; !=(~zod)\n[1 0]\n~zod:dojo&gt; !=((add 2 2))\n[8 [9 3.110.356 0 31] 9 2 [0 4] [7 [0 3] 1 2 2] 0 11]\n</code></pre>\n"
    },
    {
        "keys": [
            "!?"
        ],
        "doc": "<h1><code>!? \"zapwut\"</code></h1>\n<p><code>[%zpwt p=@ q=hoon]</code>: restrict Hoon version.</p>\n<h2>Produces</h2>\n<p><code>q</code>, if <code>p</code> is greater than or equal to the Hoon kelvin version.\n(Versions count down; the current version is 143.)</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; !?(264 (add 2 2))\n4\n~zod:dojo&gt; !?(164 (add 2 2))\n4\n~zod:dojo&gt; !?(64 (add 2 2))\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "!!"
        ],
        "doc": "<h1><code>!! \"zapzap\"</code></h1>\n<p><code>[%zpzp ~]</code>: crash.</p>\n<h2>Produces</h2>\n<p>Nothing.  Always crashes, with type <code>%void</code>.</p>\n<h2>Syntax</h2>\n<p><code>!!</code></p>\n<h2>Discussion</h2>\n<p><code>%void</code> nests in every other type, so you can stub out anything with <code>!!</code>.</p>\n<h2>Examples</h2>\n<pre><code>~zod:dojo&gt; !!\nford: build failed\n</code></pre>\n"
    },
    {
        "keys": [
            "add"
        ],
        "doc": "<h1><code>++add</code></h1>\n<p>Add</p>\n<p>Produces the sum of <code>a</code> and <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  add                                                 ::  add\n  ~/  %add\n  |=  [a/@ b/@]\n  ^-  @\n  ?:  =(0 a)  b\n  $(a (dec a), b +(b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (add 2 2)\n4\n&gt; (add 1 1.000.000)\n1.000.001\n&gt; (add 1.333 (mul 2 2))\n1.337\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dec"
        ],
        "doc": "<h1><code>++dec</code></h1>\n<p>Decrement</p>\n<p>Decrements <code>a</code> by <code>1</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  dec                                                 ::  decrement\n  ~/  %dec\n  |=  a/@\n  ~|  %decrement-underflow\n  ?&lt;  =(0 a)\n  =+  b=0\n  |-  ^-  @\n  ?:  =(a +(b))  b\n  $(b +(b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (dec 7)\n6\n&gt; (dec 0)\n! decrement-underflow\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "div"
        ],
        "doc": "<h1><code>++div</code></h1>\n<p>Divide</p>\n<p>Computes <code>a</code> divided by <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  div                                                 ::  divide\n  ~/  %div\n  |=  [a/@ b/@]\n  ^-  @\n  ~|  'div'\n  ?&lt;  =(0 b)\n  =+  c=0\n  |-\n  ?:  (lth a b)  c\n  $(a (sub a b), c +(c))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (div 4 2)\n2\n&gt; (div 17 8)\n2\n&gt; (div 20 30)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gte"
        ],
        "doc": "<h1><code>++gte</code></h1>\n<p>Greater-than/equal</p>\n<p>Tests whether <code>a</code> is greater than a number <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>++  gte                                                 ::  greater-equal\n  ~/  %gte\n  |=  {a/@ b/@}\n  ^-  ?\n  !(lth a b)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (gte 100 10)\n%.y\n&gt; (gte 4 4)\n%.y\n&gt; (gte 3 4)\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gth"
        ],
        "doc": "<h1><code>++gth</code></h1>\n<p>Greater-than</p>\n<p>Tests whether <code>a</code> is greater than <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>++  gth                                                 ::  greater-than\n  ~/  %gth\n  |=  {a/@ b/@}\n  ^-  ?\n  !(lte a b)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (gth 'd' 'c')\n%.y\n&gt; (gth ~h1 ~m61)\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lte"
        ],
        "doc": "<h1><code>++lte</code></h1>\n<p>Less-than/equal</p>\n<p>Tests whether <code>a</code> is less than or equal to <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>++  lte                                                 ::  less-equal\n  ~/  %lte\n  |=  {a/@ b/@}\n  |(=(a b) (lth a b))\n\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (lte 4 5)\n%.y\n&gt; (lte 5 4)\n%.n\n&gt; (lte 5 5)\n%.y\n&gt; (lte 0 0)\n%.y\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lth"
        ],
        "doc": "<h1><code>++lth</code></h1>\n<p>Less-than</p>\n<p>Tests whether <code>a</code> is less than <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>++  lth                                                 ::  less-than\n  ~/  %lth\n  |=  {a/@ b/@}\n  ^-  ?\n  ?&amp;  !=(a b)\n      |-\n      ?|  =(0 a)\n          ?&amp;  !=(0 b)\n              $(a (dec a), b (dec b))\n  ==  ==  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (lth 4 5)\n%.y\n&gt; (lth 5 4)\n%.n\n&gt; (lth 5 5)\n%.n\n&gt; (lth 5 0)\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "max"
        ],
        "doc": "<h1><code>++max</code></h1>\n<p>Maximum</p>\n<p>Computes the greater of <code>a</code> and <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  max                                                 ::  maximum\n  ~/  %max\n  |=  {a/@ b/@}\n  ^-  @\n  ?:  (gth a b)  a\n  b\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (max 10 100)\n100\n&gt; (max 10.443 9)\n10.443\n&gt; (max 0 1)\n1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "min"
        ],
        "doc": "<h1><code>++min</code></h1>\n<p>Minimum</p>\n<p>Computes the lesser of <code>a</code> and <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  min                                                 ::  minimum\n  ~/  %min\n  |=  {a/@ b/@}\n  ^-  @\n  ?:  (lth a b)  a\n  b\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (min 10 100)\n10\n&gt; (min 10.443 9)\n9\n&gt; (min 0 1)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mod"
        ],
        "doc": "<h1><code>++mod</code></h1>\n<p>Modulus</p>\n<p>Computes the remainder of dividing <code>a</code> by <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  mod                                                 ::  remainder\n  ~/  %mod\n  |:  [a=`@`1 b=`@`1]\n  ^-  @\n  ?&lt;  =(0 b)\n  (sub a (mul b (div a b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mod 5 2)\n1\n&gt; (mod 5 5)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mul"
        ],
        "doc": "<h1><code>++mul</code></h1>\n<p>Multiply</p>\n<p>Multiplies <code>a</code> by <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  mul                                                 ::  multiply\n  ~/  %mul\n  |:  [a=`@`1 b=`@`1]\n  ^-  @\n  =+  c=0\n  |-\n  ?:  =(0 a)  c\n  $(a (dec a), c (add b c))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mul 3 4)\n 12 \n&gt; (mul 0 1) \n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sub"
        ],
        "doc": "<h1><code>++sub</code></h1>\n<p>Subtract</p>\n<p>Subtracts <code>b</code> from <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>    ++  sub                                                 ::  subtract\n      ~/  %sub\n      |=  [a/@ b/@]\n      ~|  %subtract-underflow\n      ^-  @\n      ?:  =(0 b)  a\n      $(a (dec a), b (dec b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (sub 10 5)\n5\n&gt; (sub 243 44)\n199\n&gt; (sub 5 0)\n5\n&gt; (sub 0 5)\n! subtract-underflow\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cap"
        ],
        "doc": "<h1><code>++cap</code></h1>\n<p>Tree head</p>\n<p>Tests whether an <code>a</code> is in the head or tail of a noun. Produces the\ncube <code>%2</code> if it is within the head, or the cube <code>%3</code> if it is\nwithin the tail.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A cube.</p>\n<h2>Source</h2>\n<pre><code>    ++  cap                                                 ::  tree head\n      ~/  %cap\n      |=  a=@\n      ^-  ?(%2 %3)\n      ?-  a\n        %2        %2\n        %3        %3\n        ?(%0 %1)  !!\n        *         $(a (div a 2))\n      ==\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (cap 4)\n%2\n&gt; (cap 6)\n%3\n&gt; (cap (add 10 9))\n%2\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mas"
        ],
        "doc": "<h1><code>++mas</code></h1>\n<p>Axis within head/tail?</p>\n<p>Computes the axis of <code>a</code> within either the head or tail of a noun (depends whether <code>a</code> lies within the the head or tail).</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an <a href=\"\">atom</a>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>    ++  mas                                                 ::  tree body\n      ~/  %mas\n      |=  a=@\n      ^-  @\n      ?-  a\n        1   !!\n        2   1\n        3   1\n        *   (add (mod a 2) (mul $(a (div a 2)) 2))\n      ==\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mas 3)\n1\n&gt; (mas 4)\n2\n&gt; (mas 5)\n3\n&gt; (mas 6)\n2\n&gt; (mas 0)\n! exit\n&gt; (mas 1)\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "peg"
        ],
        "doc": "<h1><code>++peg</code></h1>\n<p>Axis within axis</p>\n<p>Computes the axis of <code>b</code> within axis <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  peg                                                 ::  tree connect\n  ~/  %peg\n  |=  {a/@ b/@}\n  ^-  @\n  ?-  b\n    $1  a\n    $2  (mul a 2)\n    $3  +((mul a 2))\n    *   (add (mod b 2) (mul $(b (div b 2)) 2))\n  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt;  (peg 4 1)\n4\n&gt;  (peg 4 2)\n8\n&gt;  (peg 8 45)\n269\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bloq"
        ],
        "doc": "<h1><code>++bloq</code></h1>\n<p>Blocksize</p>\n<p>Atom representing a blocksize, by convention expressed as a power of 2.</p>\n<h2>Source</h2>\n<pre><code>++  bloq  @                                            ::  blockclass\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; :: ++met measures how many bloqs long an atom is\n&gt; (met 3 256)\n2\n&gt; :: 256 is 2 bloqs of 2^3\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "each"
        ],
        "doc": "<h1><code>++each</code></h1>\n<p>Mold of fork between two</p>\n<p>mold generator: produces a discriminated fork between two types.</p>\n<h2>Source</h2>\n<pre><code>    ++  each\n      |*  {a/$-(* *) b/$-(* *)}                     ::  either a or b\n      $%({$&amp; p/a} {$| p/b})                         ::    a default\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ? *(each cord time)\n  ?({$.y p/@t} {$.n p/@da})\n[%.y p='']\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gate"
        ],
        "doc": "<h1><code>++gate</code></h1>\n<p>Function</p>\n<p>A core with one arm, <code>$</code>--the empty name--which transforms a sample noun into a product\nnoun. If used dryly as a type, the subject must have a sample type of <code>*</code>.</p>\n<h2>Source</h2>\n<pre><code>++  gate  $-(* *)                                       ::  general gate\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++lift</code>, <code>++cork</code></p>\n<pre><code>&gt; ? gate\n  &lt;1.ybc {* &lt;110.jyx 1.ztu $151&gt;}&gt;\n&lt;1.ybc {* &lt;110.jyx 1.ztu $151&gt;}&gt;\n\n&gt; (`gate`|=(a/* [a 'b']) 1)\n[1 'b']\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "list"
        ],
        "doc": "<h1><code>++list</code></h1>\n<p>List</p>\n<p>mold generator. <code>++list</code> generates a mold of a null-termanated list of a\nhomogenous type.</p>\n<h2>Source</h2>\n<pre><code>++  list  |*  a/$-(* *)                                 ::  null-term list\n          $@($~ {i/a t/(list a)})                       ::\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++turn</code>, <code>++snag</code></p>\n<pre><code>&gt; *(list)\n~\n&gt; `(list @)`\"abc\"\n~[97 98 99]\n&gt; (snag 0 \"abc\")\n'a'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lone"
        ],
        "doc": "<h1><code>++lone</code></h1>\n<p><code>++lone</code> puts face of <code>p</code> on something.</p>\n<p>XX unused</p>\n<h2>Source</h2>\n<pre><code>++  lone  |*(a/$-(* *) p/a)                             ::  just one thing\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pair"
        ],
        "doc": "<h1><code>++pair</code></h1>\n<p>Mold of pair of types</p>\n<p>mold generator. Produces a tuple of two of the types passed in.</p>\n<h2>Source</h2>\n<pre><code>++  pair  |*({a/$-(* *) b/$-(* *)} {p/a q/b})           ::  just a pair\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *(pair bean cord)\n[p=%.y q='']\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pole"
        ],
        "doc": "<h1><code>++pole</code></h1>\n<p>Faceless list</p>\n<p>A <code>++list</code> without the faces <code>i</code> and <code>t</code>.</p>\n<h2>Source</h2>\n<pre><code>++  pole  |*  a/$-(* *)                                 ::  nameless list\n          $@($~ {a (pole a)})                           ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `(pole char)`\"asdf\"\n[~~a [~~s [~~d [~~f ~]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qual"
        ],
        "doc": "<h1><code>++qual</code></h1>\n<p>Mold of 4 type tuple</p>\n<p>A <code>++qual</code> is a tuple of four of the types passed in.</p>\n<h2>Source</h2>\n<pre><code>++  qual  |*  {a/$-(* *) b/$-(* *) c/$-(* *) d/$-(* *)} ::  just a quadruple\n          {p/a q/b r/c s/d}                             ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *(qual date time tape cord)\n[p=[[a=%.y y=0] m=0 t=[d=0 h=0 m=0 s=0 f=~]] q=~292277024401-.1.1 r=\"\" s='']\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "quid"
        ],
        "doc": "<h1><code>++quid</code></h1>\n<p>For use with <code>=^</code> <code>:sip</code>.</p>\n<p>Mold generator. Produces a tuple of <code>a</code> and the mold of <code>b</code>.</p>\n<h2>Source</h2>\n<pre><code>++  quid  |*({a/mold b/*} {a _b})                       ::  mixed for sip\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *(quid @ 'hi')\n[0 'hi']\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "quip"
        ],
        "doc": "<h1><code>++quip</code></h1>\n<p>For use with <code>=^</code> <code>:sip</code>.</p>\n<p>Mold generator. Produces a tuple of a list of <code>a</code> and the mold of <code>b</code>.</p>\n<h2>Source</h2>\n<pre><code>++  quip  |*({a/mold b/*} {(list a) _b})                ::  list-mixed for sip\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *(quip @ 'hi')\n[~ 'hi']\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "trap"
        ],
        "doc": "<h1><code>++trap</code></h1>\n<p>Core with one arm <code>$</code></p>\n<p>A trap is a core with one arm <code>++$</code>.</p>\n<h2>Source</h2>\n<pre><code>++  trap  |*(a/_* _|?(*a))                        ::  makes perfect sense\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *trap\n&lt;1.mws 101.jzo 1.ypj %164&gt;\n&gt; (*trap)\n0\n&gt; (|.(42))\n42\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tree"
        ],
        "doc": "<h1><code>++tree</code></h1>\n<p>Tree mold generator</p>\n<p>A <code>++tree</code> can be empty, or contain a node of a type and\nleft/right sub <code>++tree</code> of the same type. Pretty-printed with <code>{}</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tree  |*  a/$-(* *)                                 ::  binary tree\n          $@($~ {n/a l/(tree a) r/(tree a)})            ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `(tree {@ tape})`[[1 \"hi\"] [[2 \"bye\"] ~ ~] ~]\n{[2 \"bye\"] [1 \"hi\"]}\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "trel"
        ],
        "doc": "<h1><code>++trel</code></h1>\n<p>Mold of three types</p>\n<p><code>++mold</code> of the tuple of the three types passed in.</p>\n<h2>Source</h2>\n<pre><code>++  trel  |*  {a/$-(* *) b/$-(* *) c/$-(* *)}           ::  just a triple\n          {p/a q/b r/c}                                 ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *(trel @ud @t @s)\n[p=0 q='' r=--0]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "unit"
        ],
        "doc": "<h1><code>++unit</code></h1>\n<p>Maybe</p>\n<p>mold generator. A <code>++unit</code> is either <code>~</code> or <code>[~ u=a]</code> where <code>a</code> is the\ntype that was passed in.</p>\n<h2>Source</h2>\n<pre><code>++  unit  |*  a/$-(* *)                                 ::  maybe\n          $@($~ {$~ u/a})                               ::\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++bind</code></p>\n<pre><code>&gt; ? *(unit time)\n?({$~ u/@da} $~)\n~\n\n &gt; &gt; =a |=  a/@\n  ^-  (unit @)\n  ?~  a  ~\n  [~ a]\n&gt; (a 2)\n[~ u=2]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "biff"
        ],
        "doc": "<h1><code>++biff</code></h1>\n<p>Unit as argument</p>\n<p>Applies a function <code>b</code> that produces a unit to the unwrapped value of ++unit\n<code>a</code> (<code>u.a</code>). If <code>a</code> is empty, <code>~</code> is produced.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a unit.</p>\n<p><code>b</code> is a function that accepts a noun and produces a unit.</p>\n<h2>Produces</h2>\n<p>A unit.</p>\n<h2>Source</h2>\n<pre><code>++  biff                                                ::  apply\n  |*  {a/(unit) b/$-(* (unit))}\n  ?~  a  ~\n  (b u.a)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (biff (some 5) |=(a/@ (some (add a 2))))\n[~ u=7]\n&gt; (biff ~ |=(a/@ (some (add a 2))))\n~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bind"
        ],
        "doc": "<h1><code>++bind</code></h1>\n<p>Non-unit function to unit, producing unit</p>\n<p>Applies a function <code>b</code> to the value (<code>u.a</code>) of a ++unit <code>a</code>, producing\na unit. Used when you want a function that does not accept or produce a\nunit to both accept and produce a unit.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a unit.</p>\n<p><code>b</code> is a function.</p>\n<h2>Produces</h2>\n<p>A unit.</p>\n<h2>Source</h2>\n<pre><code>++  bind                                                ::  argue\n  |*  {a/(unit) b/gate}\n  ?~  a  ~\n  [~ u=(b u.a)]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (bind ((unit @) [~ 97]) ,@t)\n[~ `a`]\n&gt; =a |=(a/@ (add a 1))\n&gt; (bind ((unit @) [~ 2]) a)\n[~ 3]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bond"
        ],
        "doc": "<h1><code>++bond</code></h1>\n<p>Replace null</p>\n<p>Replaces an empty ++unit <code>b</code> with the product of a called trap\n<code>a</code>. If the unit is not empty, then the original unit is produced.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a trap.</p>\n<p><code>b</code> is a unit.</p>\n<h2>Produces</h2>\n<p>Either the product of <code>a</code> or the value inside of unit <code>b</code>.</p>\n<h2>Source</h2>\n<pre><code>++  bond                                                ::  replace\n  |*  a/(trap)\n  |*  b/(unit)\n  ?~  b  $:a\n  u.b\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (bex 10)\n1.024\n&gt; ((bond |.((bex 10))) ~)\n1.024\n&gt; ((bond |.((bex 10))) (slaw %ud '123'))\n123\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "both"
        ],
        "doc": "<h1><code>++both</code></h1>\n<p>Group unit values into pair</p>\n<p>Produces <code>~</code> if either <code>a</code> or <code>b</code> are empty. Otherwise, produces a\n++unit whose value is a cell of the values of two input units <code>a</code> and\n<code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a unit.</p>\n<p><code>b</code> is a unit.</p>\n<h2>Produces</h2>\n<p>A unit of the two initial values.</p>\n<h2>Source</h2>\n<pre><code>++  both                                                ::  all the above\n  |*  {a/(unit) b/(unit)}\n  ?~  a  ~\n  ?~  b  ~\n  [~ u=[u.a u.b]]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (both (some 1) (some %b))\n[~ u=[1 %b]]\n&gt; (both ~ (some %b))\n~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "clap"
        ],
        "doc": "<h1><code>++clap</code></h1>\n<p>Apply function to two units</p>\n<p>Applies a binary function <code>c</code>--which does not usually accept or produce a <code>++unit</code>--\nto the values of two units, <code>a</code> and <code>b</code>, producing a unit.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a unit.</p>\n<p><code>b</code> is a unit.</p>\n<p><code>c</code> is a function that performs a binary operation.</p>\n<h2>Produces</h2>\n<p>A unit.</p>\n<h2>Source</h2>\n<pre><code>++  clap                                                ::  combine\n  |*  {a/(unit) b/(unit) c/_|=(^ +&lt;-)}\n  ?~  a  b\n  ?~  b  a\n  [~ u=(c u.a u.b)]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =u ((unit @t) [~ 'a'])\n&gt; =v ((unit @t) [~ 'b'])\n&gt; (clap u v |=([a=@t b=@t] (welp (trip a) (trip b))))\n[~ u=\"ab\"] \n&gt; =a ((unit @u) [~ 1])\n&gt; =b ((unit @u) [~ 2])\n&gt; =c |=([a=@ b=@] (add a b))\n&gt; (clap a b c)\n[~ 3]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "drop"
        ],
        "doc": "<h1><code>++drop</code></h1>\n<p>Unit to list</p>\n<p>Makes a ++list of the unwrapped value (<code>u.a</code>) of a <code>++unit</code> <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a unit.</p>\n<h2>Produces</h2>\n<p>A list.</p>\n<h2>Source</h2>\n<pre><code>++  drop                                                ::  enlist\n  |*  a/(unit)\n  ?~  a  ~\n  [i=u.a t=~]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a ((unit @) [~ 97])\n&gt; (drop a)\n[i=97 t=~] \n&gt; =a ((unit @) [~])\n&gt; (drop a)\n~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fall"
        ],
        "doc": "<h1><code>++fall</code></h1>\n<p>Give unit a default value</p>\n<p>Produces a default value <code>b</code> for a <code>++unit</code> <code>a</code> in cases where <code>a</code> is null.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a unit.</p>\n<p><code>b</code> is a noun that's used as the default value.</p>\n<h2>Produces</h2>\n<p>Either a noun <code>b</code> or the unwrapped value of unit <code>a</code>.</p>\n<h2>Source</h2>\n<pre><code>++  fall                                                ::  default\n  |*  {a/(unit) b/*}\n  ?~(a b u.a)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (fall ~ `a`)\n`a`\n&gt; (fall [~ u=0] `a`)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lift"
        ],
        "doc": "<h1><code>++lift</code></h1>\n<p>Curried bind</p>\n<p>Accepts a <code>++gate</code> <code>a</code> and produces a function that accepts <code>++unit</code>\n<code>b</code> to which it applies <code>a</code>. Used when you want a function that does not accept\nor produce a unit to both accept and produce a unit.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a gate.</p>\n<p><code>b</code> is a unit.</p>\n<h2>Produces</h2>\n<p>A unit.</p>\n<h2>Source</h2>\n<pre><code>++  lift                                                ::  lift gate (fmap)\n  |*  a/gate                                            ::  flipped\n  |*  b/(unit)                                          ::  curried\n  (bind b a)                                            ::  bind\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((lift dec) `(unit @)`~)\n~\n&gt; ((lift dec) `(unit @)`[~ 20])\n[~ 19]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mate"
        ],
        "doc": "<h1><code>++mate</code></h1>\n<p>Choose</p>\n<p>Accepts two units <code>a</code> and <code>b</code> whose values are expected to be\nequivalent. If either is empty, then the value of the other is produced.\nIf neither are empty, it asserts that both values are the same and\nproduces that value. If the assertion fails, <code>++mate</code> crashes with\n<code>'mate'</code> in the stack trace.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a unit.</p>\n<p><code>b</code> is a unit.</p>\n<h2>Produces</h2>\n<p>A unit or crash.</p>\n<h2>Source</h2>\n<pre><code>++  mate                                                ::  choose\n  |*  {a/(unit) b/(unit)}\n  ?~  b  a\n  ?~  a  b\n  ?.(=(u.a u.b) ~|('mate' !!) a)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a ((unit @) [~ 97])\n&gt; =b ((unit @) [~ 97])\n&gt; (mate a b)\n[~ 97]\n&gt; =a ((unit @) [~ 97])\n&gt; =b ((unit @) [~])\n&gt; (mate a b)\n[~ 97]\n&gt; =a ((unit @) [~ 97])\n&gt; =b ((unit @) [~ 98])\n&gt; (mate a b)\n! 'mate'\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "need"
        ],
        "doc": "<h1><code>++need</code></h1>\n<p>Unwrap unit</p>\n<p>Retrieve the value from a <code>++unit</code> and crash if the unit is null.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a unit.</p>\n<h2>Produces</h2>\n<p>Either the unwrapped value of <code>a</code> (<code>u.a</code>), or crash.</p>\n<h2>Source</h2>\n<pre><code>++  need                                                ::  demand\n  |*  a/(unit)\n  ?~  a  ~|(%need !!)\n  u.a\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a ((unit [@t @t]) [~ ['a' 'b']])\n&gt; (need a)\n['a' 'b']\n&gt; =a ((unit @ud) [~ 17])\n&gt; (need a)\n17\n&gt; =a ((unit @) [~])\n&gt; (need a)\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "some"
        ],
        "doc": "<h1><code>++some</code></h1>\n<p>Wrap value in a unit</p>\n<p>Takes any atom <code>a</code> and produces a <a href=\"\"><code>++unit</code></a> with the value set to <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <a href=\"\">noun</a>.</p>\n<h2>Produces</h2>\n<p>A unit.</p>\n<h2>Source</h2>\n<pre><code>++  some                                                ::  lift (pure)\n  |*  a=*\n  [~ u=a]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (some [`a` `b`])\n[~ u=[`a` `b`]]\n&gt; (some &amp;)\n[~ u=%.y]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "flop"
        ],
        "doc": "<h1><code>++flop</code></h1>\n<p>Produces the list <code>a</code> in reverse order.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a list.</p>\n<h2>Produces</h2>\n<p>A list.</p>\n<h2>Source</h2>\n<pre><code>++  flop                                                ::  reverse\n  ~/  %flop\n  |*  a/(list)\n  =&gt;  .(a (homo a))\n  ^+  a\n  =+  b=`_a`~\n  |-\n  ?~  a  b\n  $(a t.a, b [i.a b])\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a (limo [1 2 3 ~])\n&gt; (flop a)\n~[3 2 1]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "homo"
        ],
        "doc": "<h1><code>++homo</code></h1>\n<p>Homogenize</p>\n<p>Produces a <code>++list</code> whose type is a fork of all the contained types in the\nlist <code>a</code>. Used when you want to make all the types of the elements of a list the same.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a list.</p>\n<h2>Produces</h2>\n<p>a list.</p>\n<h2>Source</h2>\n<pre><code>++  homo                                                ::  homogenize\n  |*  a/(list)\n  ^+  =&lt;  $\n    |%  +-  $  ?:(*? ~ [i=(snag 0 a) t=$])\n    --\n  a\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; lyst\n[i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]\n&gt; (homo lyst)\n~[1 97 2 98 [~ u=10]]\n&gt; =a (limo [1 2 3 ~])\n&gt; a\n[i=1 t=[i=2 t=[i=3 t=~]]]\n&gt; (homo a)\n~[1 2 3]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lent"
        ],
        "doc": "<h1><code>++lent</code></h1>\n<p>List length</p>\n<p>Produces the length of any <code>++list</code> <code>a</code> as an atom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a list.</p>\n<h2>Produces</h2>\n<p>an atom.</p>\n<h2>Source</h2>\n<pre><code>++  lent                                                ::  length\n  ~/  %lent\n  |=  a/(list)\n  ^-  @\n  =+  b=0\n  |-\n  ?~  a  b\n  $(a t.a, b +(b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (lent (limo [1 2 3 4 ~]))\n4\n&gt; (lent (limo [1 'a' 2 'b' (some 10) ~]))\n5\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "find"
        ],
        "doc": "<h1><code>++find</code></h1>\n<p>First index in list</p>\n<p>Produces the index of the first occurrence of <code>++list</code> <code>nedl</code> in\n<code>++list</code> <code>hstk</code> as the <code>++unit</code> of an atom.</p>\n<h2>Accepts</h2>\n<p><code>nedl</code> is a list.</p>\n<p><code>hstk</code> is a list.</p>\n<h2>Produces</h2>\n<p>The <code>++unit</code> of an atom.</p>\n<h2>Source</h2>\n<pre><code>++  find                                                ::  first index\n  ~/  %find\n  |=  {nedl/(list) hstk/(list)}\n  =|  i/@ud\n  |-   ^-  (unit @ud)\n  =+  [n=nedl h=hstk]\n  |-\n  ?:  |(?=($~ n) ?=($~ h))\n     ~\n  ?:  =(i.n i.h)\n    ?~  t.n\n      `i\n    $(n t.n, h t.h)\n  ^$(i +(i), hstk +.hstk)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (find [3]~ ~[1 2 3])\n[~ 2]\n&gt; (find [4]~ ~[1 2 3])\n~\n&gt; (find ['a']~ \"cbabab\")\n[~ 2]\n&gt; (find \"ab\" \"cbabab\")\n[~ 2]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fand"
        ],
        "doc": "<h1><code>++fand</code></h1>\n<p>All indices in list</p>\n<p>Produces the indices of all occurrences of <code>++list</code> <code>nedl</code> in\n<code>++list</code> <code>hstk</code> as a <code>++list</code> of atoms.</p>\n<h2>Accepts</h2>\n<p><code>nedl</code> is a list.</p>\n<p><code>hstk</code> is a list.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code> of atoms.</p>\n<h2>Source</h2>\n<pre><code>++  fand                                                ::  all indices\n  ~/  %fand\n  |=  {nedl/(list) hstk/(list)}\n  =|  i/@ud\n  =|  fnd/(list @ud)\n  |-  ^+  fnd\n  =+  [n=nedl h=hstk]\n  |-\n  ?:  |(?=($~ n) ?=($~ h))\n    (flop fnd)\n  ?:  =(i.n i.h)\n    ?~  t.n\n      ^$(i +(i), hstk +.hstk, fnd [i fnd])\n    $(n t.n, h t.h)\n  ^$(i +(i), hstk +.hstk)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (fand [3]~ ~[1 2 3])\n~[2]\n&gt; (fand [4]~ ~[1 2 3])\n~\n&gt; (fand ['a']~ \"cbabab\")\n~[2 4]\n&gt; (fand \"ab\" \"cbabab\")\n~[2 4]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "levy"
        ],
        "doc": "<h1><code>++levy</code></h1>\n<p>Logical \"and\" on list</p>\n<p>Computes the Boolean logical \"and\" on the results of gate <code>b</code> applied to each individual element in <code>++list</code> <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a list.</p>\n<p><code>b</code> is a gate.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>++  levy\n  ~/  %levy                                             ::  all of\n  |*  {a/(list) b/$-(* ?)}\n  |-  ^-  ?\n  ?~  a  &amp;\n  ?.  (b i.a)  |\n  $(a t.a)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a |=(a/@ (lte a 1))\n&gt; (levy (limo [0 1 2 1 ~]) a)\n%.n\n&gt; =a |=(a/@ (lte a 3))\n&gt; (levy (limo [0 1 2 1 ~]) a)\n%.y\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lien"
        ],
        "doc": "<h1><code>++lien</code></h1>\n<p>Logical \"or\" on list</p>\n<p>Computes the Boolean logical \"or\" on the results of applying <a href=\"\">gate</a> <code>b</code> to every element of <a href=\"\"><code>++list</code></a> <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a list.</p>\n<p><code>b</code> is a gate.</p>\n<h2>Source</h2>\n<pre><code>++  lien                                                ::  some of\n  ~/  %lien\n  |*  {a/(list) b/$-(* ?)}\n  |-  ^-  ?\n  ?~  a  |\n  ?:  (b i.a)  &amp;\n  $(a t.a)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a |=(a=@ (gte a 1))\n&gt; (lien (limo [0 1 2 1 ~]) a)\n%.y\n&gt; =a |=(a=@ (gte a 3))\n&gt; (lien (limo [0 1 2 1 ~]) a)\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "limo"
        ],
        "doc": "<h1><code>++limo</code></h1>\n<p>List Constructor</p>\n<p>Turns a null-terminated tuple into a <a href=\"\"><code>++list</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a null-terminated tuple.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code>.</p>\n<h2>Source</h2>\n<pre><code>++  limo                                                ::  listify\n  |*  a=*\n  ^+  =&lt;  $\n    |%  +-  $  ?~(a ~ ?:(_? i=-.a t=$ $(a +.a)))\n    --\n  a\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (limo [1 2 3 ~])\n[i=1 t=[i=2 t=[i=3 t=~]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "murn"
        ],
        "doc": "<h1><code>++murn</code></h1>\n<p>Maybe transform</p>\n<p>Passes each member of <code>++list</code> <code>a</code> to gate <code>b</code>, which must produce a\n<code>++unit</code>.  Produces a new list with all the results that do not produce\n<code>~</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a list.</p>\n<p><code>b</code> is a gate that produces a unit.</p>\n<h2>Produces</h2>\n<p>A unit.</p>\n<h2>Source</h2>\n<pre><code>++  murn                                                ::  maybe transform\n  ~/  %murn\n  |*  {a/(list) b/$-(* (unit))}\n  |-\n  ?~  a  ~\n  =+  c=(b i.a)\n  ?~  c\n    $(a t.a)\n  [i=u.c t=$(a t.a)]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a |=(a=@ ?.((gte a 2) ~ (some (add a 10))))\n&gt; (murn (limo [0 1 2 3 ~]) a)\n[i=12 t=[i=13 t=~]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "oust"
        ],
        "doc": "<h1><code>++oust</code></h1>\n<p>Remove</p>\n<p>Removes elements from list <code>c</code> beginning at inclusive index <code>a</code>, removing <code>b</code> number of elements.</p>\n<h2>Accepts</h2>\n<p><code>c</code> is a list.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code>.</p>\n<h2>Source</h2>\n<pre><code>++  oust                                                ::  remove\n  ~/  %oust\n  |*  {{a/@ b/@} c/(list)}\n  (weld (scag a c) (slag (add a b) c))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (oust [4 5] \"good day, urbit!\")\n\"good urbit!\"\n&gt; (oust [2 2] (limo [1 2 3 4 ~]))\n[i=1 t=[i=2 t=~]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "reap"
        ],
        "doc": "<h1><code>++reap</code></h1>\n<p>Replicate</p>\n<p>Replicate: produces a <code>++list</code> containing <code>a</code> copies of <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a noun.</p>\n<h2>Produces</h2>\n<p>A list.</p>\n<h2>Source</h2>\n<pre><code>++  reap                                                ::  replicate\n  ~/  %reap\n  |*  {a/@ b/*}\n  |-  ^-  (list _b)\n  ?~  a  ~\n  [b $(a (dec a))]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (reap 20 %a)\n~[%a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a]\n&gt; (reap 5 ~s1)\n~[~s1 ~s1 ~s1 ~s1 ~s1]\n&gt; `@dr`(roll (reap 5 ~s1) add)\n~s5\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "reel"
        ],
        "doc": "<h1><code>++reel</code></h1>\n<p>Right fold</p>\n<p>Right fold: moves right to left across a <code>++list</code> <code>a</code>, recursively slamming\na binary gate <code>b</code> with an element from <code>a</code> and an accumulator, producing\nthe final value of the accumulator.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a binary gate.</p>\n<h2>Produces</h2>\n<p>The accumulator, which is a noun.</p>\n<h2>Source</h2>\n<pre><code>++  reel                                                ::  right fold\n  ~/  %reel\n  |*  {a/(list) b/_|=({* *} +&lt;+)}\n  |-  ^+  +&lt;+.b\n  ?~  a\n    +&lt;+.b\n  (b i.a $(a t.a))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =sum =|([p=@ q=@] |.((add p q)))\n&gt; (reel (limo [1 2 3 4 5 ~]) sum)\n15\n&gt; =a =|([p=@ q=@] |.((sub p q)))\n&gt; (reel (limo [6 3 1 ~]) a)\n4\n&gt; (reel (limo [3 6 1 ~]) a)\n! subtract-underflow\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "roll"
        ],
        "doc": "<h1><code>++roll</code></h1>\n<p>Left fold</p>\n<p>Left fold: moves left to right across a list <code>a</code>, recursively slamming a\nbinary <a href=\"\">gate</a> <code>b</code> with an element from the <a href=\"\"><code>++list</code></a> and an accumulator,\nproducing the final value of the accumulator.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a binary <a href=\"\">gate</a>.</p>\n<h2>Produces</h2>\n<p>The accumulator, which is a <a href=\"\">noun</a>.</p>\n<h2>Source</h2>\n<pre><code>++  roll                                                ::  left fold\n  ~/  %roll\n  |*  [a=(list) b=_|=([* *] +&lt;+)]\n  |-  ^+  +&lt;+.b\n  ?~  a\n    +&lt;+.b\n  $(a t.a, b b(+&lt;+ (b i.a +&lt;+.b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =sum =|([p=@ q=@] |.((add p q)))\n&gt; (roll (limo [1 2 3 4 5 ~]) sum)\nq=15\n&gt; =a =|([p=@ q=@] |.((sub p q)))\n&gt; (roll (limo [6 3 1 ~]) a)\n! subtract-underflow\n! exit\n&gt; (roll (limo [1 3 6 ~]) a)\nq=4\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "scag"
        ],
        "doc": "<h1><code>++scag</code></h1>\n<p>Prefix</p>\n<p>Accepts an atom <code>a</code> and <a href=\"\">list</a> <code>b</code>, producing the first <code>a</code> elements of\nthe front of the list.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a list.</p>\n<h2>Produces</h2>\n<p>A list of the same type as <code>b</code>.</p>\n<h2>Source</h2>\n<pre><code>++  scag                                                ::  prefix\n  ~/  %scag\n  |*  [a=@ b=(list)]\n  |-  ^+  b\n  ?:  |(?=(~ b) =(0 a))  ~\n  [i.b $(b t.b, a (dec a))]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scag 2 (limo [0 1 2 3 ~]))\n[i=0 t=[i=1 t=~]]\n&gt; (scag 10 (limo [1 2 3 4 ~]))\n[i=1 t=[i=2 t=[i=3 t=[i=4 t=~]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "skid"
        ],
        "doc": "<h1><code>++skid</code></h1>\n<p>Separate</p>\n<p>Separates a <code>++list</code> <code>a</code> into two lists - Those elements of <code>a</code> who produce\ntrue when slammed to gate <code>b</code> and those who produce <code>%.n</code>.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a gate that accepts one argument and produces a loobean.</p>\n<h2>Produces</h2>\n<p>A cell of two lists.</p>\n<h2>Source</h2>\n<pre><code>++  skid                                                ::  separate\n  ~/  %skid\n  |*  {a/(list) b/$-(* ?)}\n  |-  ^+  [p=a q=a]\n  ?~  a  [~ ~]\n  =+  c=$(a t.a)\n  ?:((b i.a) [[i.a p.c] q.c] [p.c [i.a q.c]])\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a |=(a/@ (gth a 1))\n&gt; (skid (limo [0 1 2 3 ~]) a)\n[p=[i=2 t=[i=3 t=~]] q=[i=0 t=[i=1 t=~]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "skim"
        ],
        "doc": "<h1><code>++skim</code></h1>\n<p>Suffix</p>\n<p>Cycles through the members of a list <code>a</code>, passing them to a gate <code>b</code> and\nproducing a list of all of the members that produce <code>%.y</code>. Inverse of\n<code>++skip</code>.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a gate that accepts one argument and produces a boolean.</p>\n<h2>Produces</h2>\n<p>A boolean</p>\n<h2>Source</h2>\n<pre><code>++  skim                                                ::  only\n  ~/  %skim\n  |*  {a/(list) b/$-(* ?)}\n  |-\n  ^+  a\n  ?~  a  ~\n  ?:((b i.a) [i.a $(a t.a)] $(a t.a))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a |=(a/@ (gth a 1))\n&gt; (skim (limo [0 1 2 3 ~]) a)\n[i=2 t=[i=3 t=~]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "skip"
        ],
        "doc": "<h1><code>++skip</code></h1>\n<p>Except</p>\n<p>Cycles through the members of <code>++list</code> <code>a</code>, passing them to a gate <code>b</code>. \nProduces a list of all of the members that produce <code>%.n</code>. Inverse of\n<code>++skim</code>.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a gate that accepts one argument and produces a loobean.</p>\n<h2>Produces</h2>\n<p>A list of the same type as <code>a</code>.</p>\n<h2>Source</h2>\n<pre><code>++  skip                                                ::  except\n  ~/  %skip\n  |*  {a/(list) b/$-(* ?)}\n  |-\n  ^+  a\n  ?~  a  ~\n  ?:((b i.a) $(a t.a) [i.a $(a t.a)])\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =a |=(a/@ (gth a 1))\n&gt; (skip (limo [0 1 2 3 ~]) a)\n[i=0 t=[i=1 t=~]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "slag"
        ],
        "doc": "<h1><code>++slag</code></h1>\n<p>Suffix</p>\n<p>Accepts an atom <code>a</code> and list <code>b</code>, producing the remaining elements from\n<code>b</code> starting at <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a list.</p>\n<h2>Produces</h2>\n<p>A list of the same type as <code>b</code>.</p>\n<h2>Source</h2>\n<pre><code>++  slag                                                ::  suffix\n  ~/  %slag\n  |*  {a/@ b/(list)}\n  |-  ^+  b\n  ?:  =(0 a)  b\n  ?~  b  ~\n  $(b t.b, a (dec a))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (slag 2 (limo [1 2 3 4 ~]))\n[i=3 t=[i=4 t=~]]\n&gt; (slag 1 (limo [1 2 3 4 ~]))\n[i=2 t=[i=3 t=[i=4 t=~]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "snag"
        ],
        "doc": "<h1><code>++snag</code></h1>\n<p>Index</p>\n<p>Accepts an atom <code>a</code> and a <code>++list</code> <code>b</code>, producing the element at the index\nof <code>a</code>and failing if the list is null. Lists are 0-indexed.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a list.</p>\n<h2>Produces</h2>\n<p>Produces an element of <code>b</code>, or crashes if no element exists at that index.</p>\n<h2>Source</h2>\n<pre><code>++  snag                                                ::  index\n  ~/  %snag\n  |*  {a/@ b/(list)}\n  |-\n  ?~  b\n    ~|('snag-fail' !!)\n  ?:  =(0 a)  i.b\n  $(b t.b, a (dec a))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (snag 2 \"asdf\")\n~~d\n&gt; (snag 0 `(list @ud)`~[1 2 3 4])\n1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sort"
        ],
        "doc": "<h1><code>++sort</code></h1>\n<p>Quicksort</p>\n<p>Quicksort: accepts a <code>++list</code> <code>a</code> and a gate <code>b</code> which accepts two nouns and\nproduces a loobean. <code>++sort</code> then produces a list of the elements of <code>a</code>,\nsorted according to <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a gate that accepts two nouns and produces a boolean.</p>\n<h2>Produces</h2>\n<p>A list</p>\n<h2>Source</h2>\n<pre><code>++  sort   !.                                           ::  quicksort\n  ~/  %sort\n  |*  {a/(list) b/$-([* *] ?)}\n  =&gt;  .(a ^.(homo a))\n  |-  ^+  a\n  ?~  a  ~\n  %+  weld\n    $(a (skim t.a |=(c/_i.a (b c i.a))))\n  ^+  t.a\n  [i.a $(a (skim t.a |=(c/_i.a !(b c i.a))))]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; =a =|({p/@ q/@} |.((gth p q)))\n    &gt; (sort (limo [0 1 2 3 ~]) a)\n    ~[3 2 1 0]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "swag"
        ],
        "doc": "<h1><code>++swag</code></h1>\n<p>Infix</p>\n<p>Similar to <code>substr</code> in Javascript: extracts a string infix, beginning at\ninclusive index <code>a</code>, producing <code>b</code> number of characters.</p>\n<h2>Accepts</h2>\n<p><code>c</code> is a list.</p>\n<h2>Produces</h2>\n<p>A list of the same type as <code>c</code>.</p>\n<h2>Source</h2>\n<pre><code>++  swag                                                ::  infix\n  |*  {{a/@ b/@} c/(list)}\n  (scag +&lt;-&gt; (slag +&lt;-&lt; c))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (swag [2 5] \"roly poly\")\n\"ly po\"\n&gt; (swag [2 2] (limo [1 2 3 4 ~]))\n[i=3 t=[i=4 t=~]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "turn"
        ],
        "doc": "<h1><code>++turn</code></h1>\n<p>Gate to list</p>\n<p>Accepts a <code>++list</code> <code>a</code> and a gate <code>b</code>. Produces a list with the gate applied\nto each element of the original list.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a gate.</p>\n<h2>Produces</h2>\n<p>A list.</p>\n<h2>Source</h2>\n<pre><code>++  turn                                                ::  transform\n  ~/  %turn\n  |*  {a/(list) b/gate}\n  |-\n  ?~  a  ~\n  [i=(b i.a) t=$(a t.a)]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (turn (limo [104 111 111 110 ~]) @t)\n&lt;|h o o n|&gt;\n&gt; =a |=(a/@ (add a 4))\n&gt; (turn (limo [1 2 3 4 ~]) a)\n~[5 6 7 8]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "spin"
        ],
        "doc": "<h1><code>++spin</code></h1>\n<p>Gate to list, with state</p>\n<p>Accepts a <code>++list</code> <code>a</code>, a gate <code>b</code>, and some state <code>c</code>. Produces a list with\nthe gate applied to each element of the original list. <code>b</code> is called with\na tuple -- the head is an element of <code>a</code> and the tail is the state <code>c</code>, and\nshould produce a tuple of the transformed element and the (potentially\nmodified) state <code>c</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++list</code>.</p>\n<p><code>b</code> is a gate.</p>\n<p><code>c</code> is a noun.</p>\n<h2>Produces</h2>\n<p>A list.</p>\n<h2>Source</h2>\n<pre><code>++  spin\n  |*  {a/(list) b/_|=({* *} [** +&lt;+]) c/*}\n  ::  ?&lt;  ?=($-([_?&lt;(?=($~ a) i.a) _c] [* _c]) b)\n  |-\n  ?~  a\n    ~\n  =+  v=(b i.a c)\n  [i=-.v t=$(a t.a, c +.v)]\n</code></pre>\n<h2>Examples</h2>\n<p>A trivial example -- does nothing with the state:</p>\n<pre><code>&gt; %^  spin  (limo ~[4 5 6])\n    |=({n/@ a/@} [n a])\n  0\n~[4 5 6]\n</code></pre>\n<p>Create a list of pairs, <code>p</code> as the index and <code>q</code> as the list element:</p>\n<pre><code>&gt; %^  spin  (limo ~[4 5 6])\n    |=({n/@ a/@} [`(pair)`[a n] +(a)])\n  0\n~[[p=0 q=4] [p=1 q=5] [p=2 q=6]]\n</code></pre>\n<p>Create 10 random numbers less than <code>10</code>:</p>\n<pre><code>&gt; %^  spin  (reap 10 0)\n    |=({n/@ rng/_og} (rads:rng 10))\n  ~(. og eny)\n~[5 5 9 4 1 7 9 9 9 6]\n</code></pre>\n<p><em>Notes</em>:</p>\n<p><code>(~(rads og eny) 2)</code> creates a random number less than <code>2</code>, seeding the RNG\nwith entropy (<code>eny</code>). The head of the product is the random number, the tail\nis the continuation of the RNG.</p>\n<hr>\n"
    },
    {
        "keys": [
            "spun"
        ],
        "doc": "<h1><code>++spun</code></h1>\n<p>Gate to list, with state</p>\n<p>Accepts a <code>++list</code> <code>a</code> and a gate <code>b</code>. <code>c</code> is internal state, initially\nderived by <em>bunting</em> the tail of the sample of gate <code>b</code>, instead of\nbeing passed in explicitly as in <code>++spin</code>. Produces a list with the\ngate applied to each element of the original list. <code>b</code> is called with a tuple\n-- the head is an element of <code>a</code> and the tail is the state <code>c</code>, and should\nproduce a tuple of the transformed element and the (potentially modified)\nstate <code>c</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++list</code>.</p>\n<p><code>b</code> is a gate.</p>\n<h2>Produces</h2>\n<p>A list.</p>\n<h2>Source</h2>\n<pre><code>++  spun\n  |*  {a/(list) b/_|=({* *} [** +&lt;+])}\n  =|  c/_+&lt;+.b\n  |-\n  ?~  a\n    ~\n  =+  v=(b i.a c)\n  [i=-.v t=$(a t.a, c +.v)]\n</code></pre>\n<h2>Examples</h2>\n<p>Create a list of pairs, <code>p</code> as the index and <code>q</code> as the list element:</p>\n<pre><code>&gt; %+  spun  (limo ~[4 5 6])\n  |=({n/@ a/@} [`(pair)`[a n] +(a)])\n~[[p=0 q=4] [p=1 q=5] [p=2 q=6]]\n</code></pre>\n<p>Join two lists into a list of pairs, <code>p</code> from <code>l</code> and <code>q</code> from the sample:</p>\n<pre><code>&gt; =l (limo ~[7 8 9])\n&gt; %+  spun  (limo ~[4 5 6])\n  |=({n/@ a/@} [`(pair)`[(snag a l) n] +(a)])\n~[[p=7 q=4] [p=8 q=5] [p=9 q=6]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "weld"
        ],
        "doc": "<h1><code>++weld</code></h1>\n<p>Concatenate</p>\n<p>Concatenate two <code>++list</code>s <code>a</code> and <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> and <code>b</code> are lists.</p>\n<h2>Source</h2>\n<pre><code>++  weld                                                ::  concatenate\n  ~/  %weld\n  |*  {a/(list) b/(list)}\n  =&gt;  .(a ^.(homo a), b ^.(homo b))\n  |-  ^+  b\n  ?~  a  b\n  [i.a $(a t.a)]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (weld \"urb\" \"it\")\n~[~~u ~~r ~~b ~~i ~~t]\n&gt; (weld (limo [1 2 ~]) (limo [3 4 ~]))\n~[1 2 3 4]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "welp"
        ],
        "doc": "<h1><code>++welp</code></h1>\n<p>Perfect weld</p>\n<p>Concatenate two <code>++list</code>s <code>a</code> and <code>b</code> without losing their type information\nto homogenization.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a list.</p>\n<p><code>b</code> is a list.</p>\n<h2>Produces</h2>\n<p>A list.</p>\n<h2>Source</h2>\n<pre><code>++  welp                                                ::  perfect weld\n  =|  {* *}\n  |%\n  +-  $\n    ?~  +&lt;-\n      +&lt;-(. +&lt;+)\n    +&lt;-(+ $(+&lt;- +&lt;-&gt;))\n  --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (welp \"foo\" \"bar\")\n\"foobar\"\n~zod/arvo=/hoon/hoon&gt; (welp ~[60 61 62] ~[%a %b %c])\n[60 61 62 %a %b %c ~]\n~zod/arvo=/hoon/hoon&gt;? (welp ~[60 61 62] ~[%a %b %c])\n[60 61 62 %a %b %c ~]\n[@ud @ud @ud %a %b %c %~]\n~zod/arvo=/hoon/hoon&gt; (welp [sa+1 so+2 ~] si/3)\n[[%sa 1] [%so 2] %si 3]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zing"
        ],
        "doc": "<h1><code>++zing</code></h1>\n<p>Cons</p>\n<p>Turns a <code>++list</code> of lists into a single list by promoting the elements of\neach sublist into the higher.</p>\n<h2>Accepts</h2>\n<p>A list of lists.</p>\n<h2>Produces</h2>\n<p>A list.</p>\n<h2>Source</h2>\n<pre><code>++  zing                                                ::  promote\n  =|  *\n  |%\n  +-  $\n    ?~  +&lt;\n      +&lt;\n    (welp +&lt;- $(+&lt; +&lt;+))\n  --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (zing (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) (limo ['h' 'i' 'j' ~]) ~]))\n~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']\n&gt; (zing (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))\n~[1 97 2 98 3 99 4 100]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bex"
        ],
        "doc": "<h1><code>++bex</code></h1>\n<p>Binary exponent</p>\n<p>Computes the result of <code>2^a</code>, producing an atom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  bex                                                 ::  binary exponent\n  ~/  %bex\n  |=  a/@\n  ^-  @\n  ?:  =(0 a)  1\n  (mul 2 $(a (dec a)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (bex 4)\n16\n&gt; (bex (add 19 1))\n1.048.576\n&gt; (bex 0)\n1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "can"
        ],
        "doc": "<h1><code>++can</code></h1>\n<p>Assemble</p>\n<p>Produces an atom from a list <code>b</code> of length-value pairs <code>p</code> and <code>q</code>,\nwhere <code>p</code> is the length in bloqs of size <code>a</code>, and <code>q</code> is an atomic\nvalue.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is a <code>++list</code> of length value pairs, <code>p</code> and <code>q</code>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  can                                                 ::  assemble\n  ~/  %can\n  |=  [a/bloq b/(list [p=@ q=@])]\n  ^-  @\n  ?~  b  0\n  (mix (end a p.i.b q.i.b) (lsh a p.i.b $(b t.b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`(can 3 ~[[1 1]])\n0b1 \n&gt; `@ub`(can 0 ~[[1 255]])\n0b1\n&gt; `@ux`(can 3 [3 0xc1] [1 0xa] ~)\n0xa00.00c1\n&gt; `@ux`(can 3 [3 0xc1] [1 0xa] [1 0x23] ~)\n0x23.0a00.00c1\n&gt; `@ux`(can 4 [3 0xc1] [1 0xa] [1 0x23] ~)\n0x23.000a.0000.0000.00c1\n&gt; `@ux`(can 3 ~[[1 'a'] [2 'bc']])\n0x63.6261\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cat"
        ],
        "doc": "<h1><code>++cat</code></h1>\n<p>Concatenate</p>\n<p>Concatenates two atoms, <code>b</code> and <code>c</code>, according to bloq size <code>a</code>, producing an\natom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  cat                                                 ::  concatenate\n  ~/  %cat\n  |=  {a/bloq b/@ c/@}\n  (add (lsh a (met a b) c) b)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`(cat 3 1 0)\n0b1\n&gt; `@ub`(cat 0 1 1)\n0b11\n&gt; `@ub`(cat 0 2 1)\n0b110\n&gt; `@ub`(cat 2 1 1)\n0b1.0001\n&gt; `@ub`256\n0b1.0000.0000\n&gt; `@ub`255\n0b1111.1111\n&gt; `@ub`(cat 3 256 255)\n0b1111.1111.0000.0001.0000.0000\n&gt; `@ub`(cat 2 256 255)\n0b1111.1111.0001.0000.0000\n&gt; (cat 3 256 255)\n16.711.936\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cut"
        ],
        "doc": "<h1><code>++cut</code></h1>\n<p>Slice</p>\n<p>Slices <code>c</code> blocks of size <code>a</code> that are <code>b</code> blocks from the end of <code>d</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see ++bloq).</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  cut                                                 ::  slice\n  ~/  %cut\n  |=  {a/bloq {b/@u c/@u} d/@}\n  (end a c (rsh a b d))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (cut 0 [1 1] 2)\n1\n&gt; (cut 0 [2 1] 4)\n1\n&gt; `@t`(cut 3 [0 3] 'abcdefgh')\n'abc'\n&gt; `@t`(cut 3 [1 3] 'abcdefgh')\n'bcd'\n&gt; `@ub`(cut 0 [0 3] 0b1111.0000.1101)\n0b101\n&gt; `@ub`(cut 0 [0 6] 0b1111.0000.1101)\n0b1101\n&gt; `@ub`(cut 0 [4 6] 0b1111.0000.1101)\n0b11.0000\n&gt; `@ub`(cut 0 [3 6] 0b1111.0000.1101)\n0b10.0001\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "end"
        ],
        "doc": "<h1><code>++end</code></h1>\n<p>Tail</p>\n<p>Produces an atom by taking the last <code>b</code> blocks of size <code>a</code> from <code>c</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  end                                                 ::  tail\n  ~/  %end\n  |=  {a/bloq b/@u c/@}\n  (mod c (bex (mul (bex a) b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`12\n0b1100\n&gt; `@ub`(end 0 3 12)\n0b100\n&gt; (end 0 3 12)\n4\n&gt; `@ub`(end 1 3 12)\n0b1100\n&gt; (end 1 3 12)\n12\n&gt; `@ux`'abc'\n0x63.6261\n&gt; `@ux`(end 3 2 'abc')\n0x6261\n&gt; `@t`(end 3 2 'abc')\n'ab'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fil"
        ],
        "doc": "<h1><code>++fil</code></h1>\n<p>Fill bloqstream</p>\n<p>Produces an atom by repeating <code>c</code> for <code>b</code> blocks of size <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  fil                                                 ::  fill bloqstream\n  |=  {a/bloq b/@u c/@}\n  =+  n=0\n  =+  d=c\n  |-  ^-  @\n  ?:  =(n b)\n    (rsh a 1 d)\n  $(d (add c (lsh a 1 d)), n +(n))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`(fil 3 5 %a)\n'aaaaa'\n&gt; `@t`(fil 5 10 %ceeb)\n'ceebceebceebceebceebceebceebceebceebceeb'\n&gt; `@t`(fil 4 10 %eced)\n'\u0287\u0287\u0287\u0287\u0287\u0287\u0287\u0287\u0287\u0287ed'\n&gt; `@tas`(fil 4 10 %bf)\n%bfbfbfbfbfbfbfbfbfbf\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lsh"
        ],
        "doc": "<h1><code>++lsh</code></h1>\n<p>Left-shift</p>\n<p>Produces an atom by left-shifting <code>c</code> by <code>b</code> blocks of size <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  lsh                                                 ::  left-shift\n  ~/  %lsh\n  |=  {a/bloq b/@u c/@}\n  (mul (bex (mul (bex a) b)) c)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`1\n0b1\n&gt; `@ub`(lsh 0 1 1)\n0b10\n&gt; (lsh 0 1 1)\n2\n&gt; `@ub`255\n0b1111.1111\n&gt; `@ub`(lsh 3 1 255)\n0b1111.1111.0000.0000\n&gt; (lsh 3 1 255)\n65.280\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "met"
        ],
        "doc": "<h1><code>++met</code></h1>\n<p>Measure</p>\n<p>Computes the number of blocks of size <code>a</code> in <code>b</code>, producing an atom.</p>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<h2>Source</h2>\n<pre><code>++  met                                                 ::  measure\n  ~/  %met\n  |=  {a/bloq b/@}\n  ^-  @\n  =+  c=0\n  |-\n  ?:  =(0 b)  c\n  $(b (rsh a 1 b), c +(c))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (met 0 1)\n1\n&gt; (met 0 2)\n2\n&gt; (met 3 255)\n1\n&gt; (met 3 256)\n2\n&gt; (met 3 'abcde')\n5\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rap"
        ],
        "doc": "<h1><code>++rap</code></h1>\n<p>Assemble non-zero</p>\n<p>Concatenates a list of atoms <code>b</code> using blocksize <code>a</code>, producing an atom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is a <code>++list</code> of atoms.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  rap                                                 ::  assemble nonzero\n  ~/  %rap\n  |=  {a/bloq b/(list @)}\n  ^-  @\n  ?~  b  0\n  (cat a i.b $(b t.b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`(rap 2 (limo [1 2 3 4 ~]))\n0b100.0011.0010.0001\n&gt; `@ub`(rap 1 (limo [1 2 3 4 ~]))\n0b1.0011.1001\n&gt; (rap 0 (limo [0 0 0 ~]))\n0\n&gt; (rap 0 (limo [1 0 1 ~]))\n3\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rep"
        ],
        "doc": "<h1><code>++rep</code></h1>\n<p>Assemble single</p>\n<p>Produces an atom by assembling a list of atoms <code>b</code> using block size <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is a list of atoms.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  rep                                                 ::  assemble single\n  ~/  %rep\n  |=  {a/bloq b/(list @)}\n  ^-  @\n  =+  c=0\n  |-\n  ?~  b  0\n  (con (lsh a c (end a 1 i.b)) $(c +(c), b t.b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`(rep 2 (limo [1 2 3 4 ~]))\n0b100.0011.0010.0001\n&gt; (rep 0 (limo [0 0 1 ~]))\n4\n&gt; (rep 0 (limo [0 0 0 1 ~]))\n8\n&gt; (rep 0 (limo [0 1 0 0 ~]))\n2\n&gt; (rep 0 (limo [0 1 0 1 ~]))\n10\n&gt; (rep 0 (limo [0 1 0 1 0 1 ~]))\n42\n&gt; `@ub`42\n0b10.1010\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rip"
        ],
        "doc": "<h1><code>++rip</code></h1>\n<p>Disassemble</p>\n<p>Produces a list of atoms from the bits of <code>b</code> using block size <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A list of atoms.</p>\n<h2>Source</h2>\n<pre><code>++  rip                                                 ::  disassemble\n  ~/  %rip\n  |=  {a/bloq b/@}\n  ^-  (list @)\n  ?:  =(0 b)  ~\n  [(end a 1 b) $(b (rsh a 1 b))]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`155\n0b1001.1011\n&gt; (rip 0 155)\n~[1 1 0 1 1 0 0 1]\n&gt; (rip 2 155)\n~[11 9]\n&gt; (rip 1 155)\n~[3 2 1 2]\n&gt; `@ub`256\n0b1.0000.0000\n&gt; (rip 0 256)\n~[0 0 0 0 0 0 0 0 1]\n&gt; (rip 2 256)\n~[0 0 1]\n&gt; (rip 3 256)\n~[0 1]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rsh"
        ],
        "doc": "<h1><code>++rsh</code></h1>\n<p>Right-shift</p>\n<p>Right-shifts <code>c</code> by <code>b</code> blocks of size <code>a</code>, producing an atom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  rsh                                                 ::  right-shift\n  ~/  %rsh\n  |=  {a/bloq b/@u c/@}\n  (div c (bex (mul (bex a) b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`145\n0b1001.0001\n&gt; `@ub`(rsh 1 1 145)\n0b10.0100\n&gt; (rsh 1 1 145)\n36\n&gt; `@ub`(rsh 2 1 145)\n0b1001\n&gt; (rsh 2 1 145)\n9\n&gt; `@ub`10\n0b1010\n&gt; `@ub`(rsh 0 1 10)\n0b101\n&gt; (rsh 0 1 10)\n5\n&gt; `@ux`'abc'\n0x63.6261\n&gt; `@t`(rsh 3 1 'abc')\n'bc'\n&gt; `@ux`(rsh 3 1 'abc')\n0x6362\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "swp"
        ],
        "doc": "<h1><code>++swp</code></h1>\n<p>Reverse block order</p>\n<p>Switches little endian to big and vice versa: produces an atom by\nreversing the block order of <code>b</code> using block size <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom</p>\n<h2>Source</h2>\n<pre><code>++  swap  |=({a/bloq b/@} (rep a (flop (rip a b))))     ::  reverse bloq order\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`24\n0b1.1000\n&gt; (swap 0 24)\n3\n&gt; `@ub`3\n0b11\n&gt; (swap 0 0)\n0\n&gt; (swap 0 128)\n1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "xeb"
        ],
        "doc": "<h1><code>++xeb</code></h1>\n<p>Binary logarithm</p>\n<p>Computes the base-2 logarithm of <code>a</code>, producing an atom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  xeb                                                 ::  binary logarithm\n  ~/  %xeb\n  |=  a/@\n  ^-  @\n  (met 0 a)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (xeb 31)\n5\n&gt; (xeb 32)\n6\n&gt; (xeb 49)\n6\n&gt; (xeb 0)\n0\n&gt; (xeb 1)\n1\n&gt; (xeb 2)\n2\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "con"
        ],
        "doc": "<h1><code>++con</code></h1>\n<p>Binary OR</p>\n<p>Computes the bit-wise logical OR of two <a href=\"\">atom</a>s, <code>a</code> and <code>b</code>, producing an\natom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom</p>\n<p><code>b</code> is an atom</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  con                                                 ::  binary or\n  ~/  %con\n  |=  {a/@ b/@}\n  =+  [c=0 d=0]\n  |-  ^-  @\n  ?:  ?&amp;(=(0 a) =(0 b))  d\n  %=  $\n    a   (rsh 0 1 a)\n    b   (rsh 0 1 b)\n    c   +(c)\n    d   %+  add  d\n          %^  lsh  0  c\n          ?&amp;  =(0 (end 0 1 a))\n              =(0 (end 0 1 b))\n          ==\n  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (con 0b0 0b1)\n1\n&gt; (con 0 1)\n1\n&gt; (con 0 0)\n0\n&gt; `@ub`(con 0b1111.0000 0b1.0011)\n0b1111.0011    \n&gt; (con 4 4)\n4\n&gt; (con 10.000 234)\n10.234\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dis"
        ],
        "doc": "<h1><code>++dis</code></h1>\n<p>Binary AND</p>\n<p>Computes the bit-wise logical AND of two atoms <code>a</code> and <code>b</code>, producing an\natom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  dis                                                 ::  binary and\n  ~/  %dis\n  |=  {a/@ b/@}\n  =|  {c/@ d/@}\n  |-  ^-  @\n  ?:  ?|(=(0 a) =(0 b))  d\n  %=  $\n    a   (rsh 0 1 a)\n    b   (rsh 0 1 b)\n    c   +(c)\n    d   %+  add  d\n          %^  lsh  0  c\n          ?|  =(0 (end 0 1 a))\n              =(0 (end 0 1 b))\n          ==\n  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`9\n0b1001\n&gt; `@ub`5\n0b101\n&gt; `@ub`(dis 9 5)\n0b1\n&gt; (dis 9 5)\n1\n&gt; `@ub`534\n0b10.0001.0110\n&gt; `@ub`987\n0b11.1101.1011\n&gt; `@ub`(dis 534 987)\n0b10.0001.0010\n&gt; (dis 534 987)\n530\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mix"
        ],
        "doc": "<h1><code>++mix</code></h1>\n<p>Binary XOR</p>\n<p>Produces the bit-wise logical XOR of <code>a</code> and <code>b</code>, producing an atom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom</p>\n<p><code>b</code> is an atom</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  mix                                                 ::  binary xor\n  ~/  %mix\n  |=  {a/@ b/@}\n  ^-  @\n  =+  [c=0 d=0]\n  |-\n  ?:  ?&amp;(=(0 a) =(0 b))  d\n  %=  $\n    a   (rsh 0 1 a)\n    b   (rsh 0 1 b)\n    c   +(c)\n    d   (add d (lsh 0 c =((end 0 1 a) (end 0 1 b))))\n  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`2\n0b10\n&gt; `@ub`3\n0b11\n&gt; `@ub`(mix 2 3)\n0b1\n&gt; (mix 2 3)\n1\n&gt; `@ub`(mix 2 2)\n0b0\n&gt; (mix 2 2)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "not"
        ],
        "doc": "<h1><code>++not</code></h1>\n<p>Binary NOT</p>\n<p>Computes the bit-wise logical NOT of the bottom <code>b</code> blocks of size <code>a</code>\nof <code>c</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a block size (see <code>++bloq</code>).</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  not  |=  {a/bloq b/@ c/@}                           ::  binary not (sized)\n  (mix c (dec (bex (mul b (bex a)))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`24\n0b1.1000\n&gt; (not 0 5 24)\n7\n&gt; `@ub`7\n0b111\n&gt; (not 2 5 24)\n1.048.551\n&gt; (not 2 5 1.048.551)\n24\n&gt; (not 1 1 (not 1 1 10))\n10\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fnv"
        ],
        "doc": "<h1><code>++fnv</code></h1>\n<p>Hashes an atom with the 32-bit FNV non-cryptographic hash algorithm.\nMultiplies <code>a</code> by the prime number 16,777,619 and then takes the block\nof size 5 off the product's end, producing an atom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  fnv  |=(a/@ (end 5 1 (mul 16.777.619 a)))           ::  FNV scrambler\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (fnv 10.000)\n272.465.456\n&gt; (fnv 10.001)\n289.243.075\n&gt; (fnv 1)\n16.777.619\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mug"
        ],
        "doc": "<h1><code>++mug</code></h1>\n<p>Hashes <code>a</code> with the 31-bit nonzero FNV-1a non-cryptographic hash\nalgorithm, producing an atom.</p>\n<h2>Accepts</h2>\n<p>A is a noun.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  mug                                                 ::  31bit nonzero FNV1a\n  ~/  %mug\n  |=  a/*\n  ?^  a\n    =+  b=[p=$(a -.a) q=$(a +.a)]\n    |-  ^-  @\n    =+  c=(fnv (mix p.b (fnv q.b)))\n    =+  d=(mix (rsh 0 31 c) (end 0 31 c))\n    ?.  =(0 c)  c\n    $(q.b +(q.b))\n  =+  b=2.166.136.261\n  |-  ^-  @\n  =+  c=b\n  =+  [d=0 e=(met 3 a)]\n  |-  ^-  @\n  ?:  =(d e)\n    =+  f=(mix (rsh 0 31 c) (end 0 31 c))\n    ?.  =(0 f)  f\n    ^$(b +(b))\n  $(c (fnv (mix c (cut 3 [d 1] a))), d +(d))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mug 10.000)\n178.152.889\n&gt; (mug 10.001)\n714.838.017\n&gt; (mug 1)\n67.918.732\n&gt; (mug (some 10))\n1.872.403.737\n&gt; (mug (limo [1 2 3 4 5 ~]))\n1.067.931.605\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mum"
        ],
        "doc": "<h1><code>++mum</code></h1>\n<p>XX document</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  mum                                                 ::  mug with murmur3\n  ~/  %mum\n  |=  a/*\n  |^  (trim ?@(a a (mix $(a -.a) (mix 0x7fff.ffff $(a +.a)))))\n  ++  spec                                              ::  standard murmur3\n    |=  {syd/@ key/@}\n    ?&gt;  (lte (met 5 syd) 1)\n    =+  ^=  row\n        |=  {a/@ b/@}\n        (con (end 5 1 (lsh 0 a b)) (rsh 0 (sub 32 a) b))\n    =+  mow=|=({a/@ b/@} (end 5 1 (mul a b)))\n    =+  len=(met 5 key)\n    =-  =.  goc  (mix goc len)\n        =.  goc  (mix goc (rsh 4 1 goc))\n        =.  goc  (mow goc 0x85eb.ca6b)\n        =.  goc  (mix goc (rsh 0 13 goc))\n        =.  goc  (mow goc 0xc2b2.ae35)\n        (mix goc (rsh 4 1 goc))\n    ^=  goc\n    =+  [inx=0 goc=syd]\n    |-  ^-  @\n    ?:  =(inx len)  goc\n    =+  kop=(cut 5 [inx 1] key)\n    =.  kop  (mow kop 0xcc9e.2d51)\n    =.  kop  (row 15 kop)\n    =.  kop  (mow kop 0x1b87.3593)\n    =.  goc  (mix kop goc)\n    =.  goc  (row 13 goc)\n    =.  goc  (end 5 1 (add 0xe654.6b64 (mul 5 goc)))\n    $(inx +(inx))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mum 10.000)\n1.232.632.901\n&gt; (mum 10.001)\n658.093.079\n&gt; (mum 1)\n818.387.364\n&gt; (mum (some 10))\n1.177.215.703\n&gt; (mum ~[1 2 3 4 5])\n1.517.902.092\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "aor"
        ],
        "doc": "<h1><code>++aor</code></h1>\n<p>Alphabetic order</p>\n<p>Computes whether <code>a</code> and <code>b</code> are in alphabetical order, producing a\nboolean.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a noun.</p>\n<p><code>b</code> is a noun.</p>\n<h2>Produces</h2>\n<p>A boolean atom.</p>\n<h2>Source</h2>\n<pre><code>++  aor                                                 ::  a-order\n  ~/  %aor\n  |=  {a/* b/*}\n  ^-  ?\n  ?:  =(a b)  &amp;\n  ?.  ?=(@ a)\n    ?:  ?=(@ b)  |\n    ?:  =(-.a -.b)\n      $(a +.a, b +.b)\n    $(a -.a, b -.b)\n  ?.  ?=(@ b)  &amp;\n  |-\n  =+  [c=(end 3 1 a) d=(end 3 1 b)]\n  ?:  =(c d)\n    $(a (rsh 3 1 a), b (rsh 3 1 b))\n  (lth c d)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (aor 'a' 'b')\n%.y\n&gt; (aor 'b' 'a')\n%.n\n&gt; (aor \"foo\" \"bar\")\n%.n\n&gt; (aor \"bar\" \"foo\")\n%.y\n&gt; (aor \"abcdefz\" \"abcdefa\")\n%.n\n&gt; (aor \"abcdefa\" \"abcdefz\")\n%.y\n&gt; (aor 10.000 17.000)\n%.y\n&gt; (aor 10 9)\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dor"
        ],
        "doc": "<h1><code>++dor</code></h1>\n<p>Numeric order</p>\n<p>Computes whether <code>a</code> and <code>b</code> are in ascending numeric order, producing a\nboolean.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a noun.</p>\n<p><code>b</code> is a noun.</p>\n<h2>Produces</h2>\n<p>A boolean atom.</p>\n<h2>Source</h2>\n<pre><code>++  dor                                                 ::  d-order\n  ~/  %dor\n  |=  {a/* b/*}\n  ^-  ?\n  ?:  =(a b)  &amp;\n  ?.  ?=(@ a)\n    ?:  ?=(@ b)  |\n    ?:  =(-.a -.b)\n      $(a +.a, b +.b)\n    $(a -.a, b -.b)\n  ?.  ?=(@ b)  &amp;\n  (lth a b)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (dor 1 2)\n%.y\n&gt; (dor 2 1)\n%.n\n&gt; (dor ~[1 2 3] ~[1 2 4])\n%.y\n&gt; (dor ~[1 2 4] ~[1 2 3])\n%.n\n&gt; (dor (limo ~[99 100 10.000]) ~[99 101 10.000])\n%.y\n&gt; (dor ~[99 101 10.999] (limo ~[99 100 10.000]))\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gor"
        ],
        "doc": "<h1><code>++gor</code></h1>\n<p>Hash order</p>\n<p>XX revisit</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a noun.</p>\n<p><code>b</code> is a noun.</p>\n<h2>Produces</h2>\n<p>A boolean atom.</p>\n<h2>Source</h2>\n<pre><code>++  gor                                                 ::  g-order\n  ~/  %gor\n  |=  {a/* b/*}\n  ^-  ?\n  =+  [c=(mug a) d=(mug b)]\n  ?:  =(c d)\n    (dor a b)\n  (lth c d)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (gor 'd' 'c')\n%.y\n&gt; 'd'\n'd'\n&gt; 'c'\n&gt; `@ud`'d'\n100\n&gt; `@ud`'c'\n99\n&gt; (mug 'd')\n1.628.185.714\n&gt; (mug 'c')\n1.712.073.811\n&gt; (gor 'd' 'c')\n%.y\n&gt; (gor 'c' 'd')\n%.n\n&gt; (gor \"foo\" \"bar\")\n%.n\n&gt; (gor (some 10) (limo [1 2 3 ~]))\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hor"
        ],
        "doc": "<h1><code>++hor</code></h1>\n<p>Hash order</p>\n<p>XX revisit</p>\n<p>Recursive hash comparator gate.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a noun.</p>\n<p><code>b</code> is a noun.</p>\n<h2>Produces</h2>\n<p>A boolean atom.</p>\n<h2>Source</h2>\n<pre><code>++  hor                                                 ::  h-order\n  ~/  %hor\n  |=  {a/* b/*}\n  ^-  ?\n  ?:  ?=(@ a)\n    ?.  ?=(@ b)  &amp;\n    (gor a b)\n  ?:  ?=(@ b)  |\n  ?:  =(-.a -.b)\n    (gor +.a +.b)\n  (gor -.a -.b)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (hor . 1)\n%.n\n&gt; (hor 1 2)\n%.y\n&gt; (hor \"abc\" \"cba\")\n%.y\n&gt; (hor 'c' 'd')\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "vor"
        ],
        "doc": "<h1><code>++vor</code></h1>\n<p>Double hash comparator gate.</p>\n<p>XX revisit</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a noun</p>\n<p><code>b</code> is a noun</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  vor                                                 ::  v-order\n  ~/  %vor\n  |=  {a/* b/*}\n  ^-  ?\n  =+  [c=(mug (mug a)) d=(mug (mug b))]\n  ?:  =(c d)\n    (dor a b)\n  (lth c d)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (vor 'f' 'g')\n%.y\n&gt; (vor 'a' 'z')\n%.n\n&gt; (vor 43.326 41.106)\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "in"
        ],
        "doc": "<h1><code>++in</code></h1>\n<p>Set operations</p>\n<p>Core whose arms contain a variety of functions that operate on <code>++set</code>s. Its sample accepts the input <code>++set</code> to be manipulated.</p>\n<h2>Accepts</h2>\n<p>A <code>++set</code>.</p>\n<h2>Source</h2>\n<pre><code>++  in                                                  ::  set engine\n  ~/  %in\n  |_  a/(set)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ~(. in (sa \"asd\"))\n&lt;13.evb [nlr(^$1{@tD $1}) &lt;414.fvk 101.jzo 1.ypj %164&gt;]&gt;\n</code></pre>\n"
    },
    {
        "keys": [
            "by"
        ],
        "doc": "<h1><code>++by</code></h1>\n<p>Map operations</p>\n<pre><code>++  by                                                  ::  map engine\n  ~/  %by\n  |_  a/(map)\n</code></pre>\n<p>Container arm for map operation arms. A map is a set of key, value\npairs. The contained arms inherit it's sample map, <code>a</code>.</p>\n<p><code>a</code> is a map.</p>\n<pre><code>&gt; ~(. by (my [%a 1] [%b 2] ~))\n&lt;22.znh {a/nlr({p/?($a $b) q/@ud}) &lt;409.ofg 110.xht 1.ztu $151&gt;}&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ja"
        ],
        "doc": "<h1><code>++ja</code></h1>\n<p>Jar engine</p>\n<pre><code>  |_  a/(jar)\n</code></pre>\n<p>A container arm for <code>++jar</code> operation arms. A <code>++jar</code> is a <code>++map</code> of\n<code>++list</code>s. The contained arms inherit the sample jar.</p>\n<p><code>a</code> is a jar.</p>\n<pre><code>&gt; ~(. ja (mo (limo a/\"ho\" b/\"he\" ~)))\n&lt;2.dgz [nlr([p={%a %b} q=\"\"]) &lt;414.fvk 101.jzo 1.ypj %164&gt;]&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ju"
        ],
        "doc": "<h1><code>++ju</code></h1>\n<p>Jug operations</p>\n<pre><code>++  ju                                                  ::  jug engine\n  |/  a/(jug)\n</code></pre>\n<p>Container arm for jug operation arms. A <code>++jug</code> is a <code>++map</code> of\n<code>++sets</code>. The contained arms inherit its sample jug, <code>a</code>.</p>\n<p><code>a</code> is a jug.</p>\n<pre><code>&gt; ~(. ju (mo (limo a/(sa \"ho\") b/(sa \"he\") ~)))\n&lt;2.dgz [nlr([p={%a %b} q={nlr(^$1{@tD $1}) nlr(^$3{@tD $3})}]) &lt;414.fvk 101.jzo 1.ypj %164&gt;]&gt;\n</code></pre>\n"
    },
    {
        "keys": [
            "to"
        ],
        "doc": "<h1><code>++to</code></h1>\n<p>Queue operations</p>\n<p>Container arm for queue operation arms. The contained arms inherit its\nsample <code>++qeu</code> <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a queue, ++qeu.</p>\n<h2>Source</h2>\n<pre><code>++  to                                                  ::  queue engine\n  |/  a/(qeu)\n</code></pre>\n"
    },
    {
        "keys": [
            "cork"
        ],
        "doc": "<h1><code>++cork</code></h1>\n<p>Build <code>f</code> such that <code>(f x) .= (b (a x))</code>.</p>\n<p><code>a</code> is a noun.</p>\n<p><code>b</code> is a gate.</p>\n<h2>Source</h2>\n<pre><code>++  cork  |*({a/_|=(* **) b/gate} (corl b a))           ::  compose forward\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (:(cork dec dec dec) 20)\n17\n&gt; =mal (mo (limo a+15 b+23 ~))\n&gt; ((cork ~(got by mal) dec) %a)\n14\n&gt; ((cork ~(got by mal) dec) %b)\n22\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "corl"
        ],
        "doc": "<h1><code>++corl</code></h1>\n<p>Gate compose</p>\n<p>XX Revisit</p>\n<p><code>a</code> is a gate.</p>\n<p><code>b</code> is a noun.</p>\n<h2>Source</h2>\n<pre><code>++  corl                                                ::  compose backwards\n  |*  {a/gate b/_|=(* **)}\n  =&lt;  +:|.((a (b)))      ::  span check\n  |*  c/_+&lt;.b\n  (a (b c))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((corl (lift bex) (slat %ud)) '2')\n[~ 4]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "curr"
        ],
        "doc": "<h1><code>++curr</code></h1>\n<p>Right curry</p>\n<p>Right curry a gate, binding the tail of its sample</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a gate.</p>\n<p><code>c</code> is a noun.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  curr                                                ::  curry right\n  |*  {a/_|=(^ **) c/*}     \n  |*  b/_+&lt;+.a\n  (a b c)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =tep (curr scan sym)\n&gt; `@t`(tep \"asd\")\n'asd'\n&gt; `@t`(tep \"lek-om\")\n'lek-om'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cury"
        ],
        "doc": "<h1><code>++cury</code></h1>\n<p>Curry a gate, binding the head of its sample</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a gate.</p>\n<p><code>b</code> is a noun.</p>\n<h2>Produces</h2>\n<p>A gate.</p>\n<h2>Source</h2>\n<pre><code>++  cury                                                ::  curry left\n  |*  {a/_|=(^ **) b/*}\n  |*  c/_+&lt;+.a\n  (a b c)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =mol (cury add 2)\n&gt; (mol 4)\n6\n&gt; (mol 7)\n9\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hard"
        ],
        "doc": "<h1><code>++hard</code></h1>\n<p>Demands that a specific type be produced, crashing the program if it is\nnot.</p>\n<h2>Source</h2>\n<pre><code>++  hard                                                ::  force remold\n  |*  han/gate\n  |=  fud/*  ^-  han\n  ~_  leaf+\"hard\"\n  =+  gol=(han fud)\n  ?&gt;(=(gol fud) gol)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((hard (list)) (limo [1 2 3 ~]))\n~[1 2 3]\n&gt; ((hard @) (add 2 2))\n4\n&gt; ((hard @t) (crip \"Tape to cord, bro!\"))\n'Tape to cord, bro'\n&gt; ((hard tape) (crip \"...Tape to cord, bro?...\"))\n! hard\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "soft"
        ],
        "doc": "<h1><code>++soft</code></h1>\n<p>Politely requests a specific type to be produced, producing null if it\nis not.</p>\n<h2>Source</h2>\n<pre><code>++  soft                                                ::  maybe remold\n  |*  han/gate\n  |=  fud/*  ^-  (unit han)\n  =+  gol=(han fud)\n  ?.(=(gol fud) ~ [~ gol])\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((soft %4) (add 2 2))\n[~ %4]\n&gt; ((soft @) (add 2 2))\n[~ 4]\n&gt; ((soft %5) (add 2 2))\n~\n&gt; ((soft @t) (crip \"Tape to cord, Woohoo!\"))\n[~ 'Tape to cord, Woohoo!']\n&gt; ((soft @t) (trip 'Cmon man... Tape to cord? Please?!'))\n~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "jar"
        ],
        "doc": "<h1><code>++jar</code></h1>\n<p>Tile generator. A <code>++jar</code> is a <code>++map</code> of <code>++list</code>.</p>\n<h2>Source</h2>\n<pre><code>++  jar  |*({a/$-(* *) b/$-(* *)} (map a (list b)))     ::  map of lists\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++ja</code>, <code>++by</code>, <code>++map</code>, <code>++list</code></p>\n<pre><code>&gt; =a (limo [1 2 ~])\n&gt; a\n[i=1 t=[i=2 t=~]]\n&gt; =b (limo [3 4 ~])\n&gt; b\n[i=3 t=[i=4 t=~]]\n&gt; =c (mo (limo [[%a a] [%b b] ~]))\n&gt; c\n{[p=%a q=[i=1 t=[i=2 t=~]]] [p=%b q=[i=3 t=[i=4 t=~]]]}\n&gt; (~(get ja c) %a)\n[i=1 t=[i=2 t=~]]\n&gt; (~(get ja c) %c)\n~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "jug"
        ],
        "doc": "<h1><code>++jug</code></h1>\n<p>mold generator.  A <code>++jug</code> is a <code>++map</code> of <code>++set</code>s.</p>\n<h2>Source</h2>\n<pre><code>++  jug  |*({a/$-(* *) b/$-(* *)} (map a (set b)))      ::  map of sets\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++ju</code>, <code>++by</code>, <code>++map</code>, <code>++set</code></p>\n<pre><code>&gt; =a (sa (limo [1 2 ~]))\n&gt; a\n{1 2}\n&gt; =b (sa (limo [3 4 ~]))\n&gt; b\n{4 3}\n&gt; =c (mo (limo [[%a a] [%b b] ~]))\n&gt; c\n{[p=%a q={1 2}] [p=%b q={4 3}]}\n&gt; (~(get ju c) %b)\n{4 3}\n&gt; (~(put ju c) [%b 5])\n{[p=%a q={1 2}] [p=%b q={5 4 3}]}\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "map"
        ],
        "doc": "<h1><code>++map</code></h1>\n<p>Map</p>\n<p>mold generator. A <code>++map</code> is a treap of\nkey-value pairs.</p>\n<h2>Source</h2>\n<pre><code>++  map  |*  {a/$-(* *) b/$-(* *)}                      ::  associative tree\n         $@($~ {n/{p/a q/b} l/(map a b) r/(map a b)})   ::\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++by</code></p>\n<pre><code>&gt;? *(map @t @u)\n          nlr({p/@t q/@u})\n          {}   \n&gt; (molt `(list (pair * *))`[[a+1 b+2] ~])\n          {[p=[97 1] q=[98 2]]}\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qeu"
        ],
        "doc": "<h1><code>++qeu</code></h1>\n<p>Queue</p>\n<p>mold generator. An ordered <a href=\"http://en.wikipedia.org/wiki/Treap\">treap</a> of\nitems.</p>\n<h2>Source</h2>\n<pre><code>++  qeu  |*  a/$-(* *)                                  ::  queue\n         $@($~ {n/a l/(qeu a) r/(qeu a)})               ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (qeu time)\n&lt;1.qyo [* &lt;1.sxx [a=&lt;1.ebd [* &lt;101.jzo 1.ypj %164&gt;]&gt; &lt;101.jzo 1.ypj %164&gt;]&gt;]&gt;\n&gt; (~(gas to *(qeu time)) [~2014.1.1 ~2014.1.2 ~])\n{~2014.1.2 ~2014.1.1}\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "set"
        ],
        "doc": "<h1><code>++set</code></h1>\n<p>Set</p>\n<p>mold generator. A <code>++set</code> is a treap with unique values.</p>\n<h2>Source</h2>\n<pre><code>++  set  |*  a/$-(* *)                                  ::  set\n         $@($~ {n/a l/(set a) r/(set a)})               ::\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++in</code></p>\n<pre><code>&gt; (sa \"abc\")\n{~~a ~~c ~~b}\n&gt; (~(put in (sa \"abc\")) %d)\n{~~d ~~a ~~c ~~b}\n&gt; (~(put in (sa \"abc\")) %a)\n{~~a ~~c ~~b}\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cue"
        ],
        "doc": "<h1><code>++cue</code></h1>\n<p>Unpack atom to noun</p>\n<p>Produces a noun unpacked from atom <code>a</code>. The inverse of jam.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>++noun</code>.</p>\n<h2>Source</h2>\n<pre><code>++  cue                                                 ::  unpack\n  ~/  %cue\n  |=  a/@\n  ^-  *\n  =+  b=0\n  =+  m=`(map @ *)`~\n  =&lt;  q\n  |-  ^-  {p/@ q/* r/(map @ *)}\n  ?:  =(0 (cut 0 [b 1] a))\n    =+  c=(rub +(b) a)\n    [+(p.c) q.c (~(put by m) b q.c)]\n  =+  c=(add 2 b)\n  ?:  =(0 (cut 0 [+(b) 1] a))\n    =+  u=$(b c)\n    =+  v=$(b (add p.u c), m r.u)\n    =+  w=[q.u q.v]\n    [(add 2 (add p.u p.v)) w (~(put by r.v) b w)]\n  =+  d=(rub c a)\n  [(add 2 p.d) (need (~(get by m) q.d)) m]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (cue 12)\n1\n&gt; (cue 817)\n[1 1]\n&gt; (cue 4.657)\n[1 2]\n&gt; (cue 39.689)\n[0 19]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "jam"
        ],
        "doc": "<h1><code>++jam</code></h1>\n<p>Pack noun to atom</p>\n<p>Produces an atom packed from noun <code>a</code>. The inverse of cue.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a noun.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  jam                                                 ::  pack\n  ~/  %jam\n  |=  a/*\n  ^-  @\n  =+  b=0\n  =+  m=`(map * @)`~\n  =&lt;  q\n  |-  ^-  {p/@ q/@ r/(map * @)}\n  =+  c=(~(get by m) a)\n  ?~  c\n    =&gt;  .(m (~(put by m) a b))\n    ?:  ?=(@ a)\n      =+  d=(mat a)\n      [(add 1 p.d) (lsh 0 1 q.d) m]\n    =&gt;  .(b (add 2 b))\n    =+  d=$(a -.a)\n    =+  e=$(a +.a, b (add b p.d), m r.d)\n    [(add 2 (add p.d p.e)) (mix 1 (lsh 0 2 (cat 0 q.d q.e))) r.e]\n  ?:  ?&amp;(?=(@ a) (lte (met 0 a) (met 0 u.c)))\n    =+  d=(mat a)\n    [(add 1 p.d) (lsh 0 1 q.d) m]\n  =+  d=(mat u.c)\n  [(add 2 p.d) (mix 3 (lsh 0 2 q.d)) m]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (jam 1)\n12\n&gt; (jam [1 1])\n817\n&gt; (jam [1 2])\n4.657\n&gt; (jam [~ u=19])\n39.689\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mat"
        ],
        "doc": "<h1><code>++mat</code></h1>\n<p>Length-encode</p>\n<p>Produces a cell whose tail <code>q</code> is atom <code>a</code> with a bit representation of\nits length prepended to it (as the least significant bits). The head <code>p</code>\nis the length of <code>q</code> in bits.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A cell of two atoms, <code>p</code> and <code>q</code>.</p>\n<h2>Source</h2>\n<pre><code>++  mat                                                 ::  length-encode\n  ~/  %mat\n  |=  a/@\n  ^-  {p/@ q/@}\n  ?:  =(0 a)\n    [1 1]\n  =+  b=(met 0 a)\n  =+  c=(met 0 b)\n  :-  (add (add c c) b)\n  (cat 0 (bex c) (mix (end 0 (dec c) b) (lsh 0 (dec c) a)))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mat 0xaaa)\n[p=20 q=699.024]\n&gt; (met 0 q:(mat 0xaaa))\n20\n&gt; `@ub`q:(mat 0xaaa)\n0b1010.1010.1010.1001.0000\n&gt; =a =-(~&amp;(- -) `@ub`0xaaa)\n0b1010.1010.1010\n&gt; =b =-(~&amp;(- -) `@ub`(xeb a))\n0b1100\n&gt; =b =-(~&amp;(- -) `@ub`(met 0 a))\n0b1100\n&gt; =c =-(~&amp;(- -) (xeb b))\n4\n&gt;  [`@ub`a `@ub`(end 0 (dec c) b) `@ub`(bex c)]\n[0b1010.1010.1010 0b100 0b1.0000]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rub"
        ],
        "doc": "<h1><code>++rub</code></h1>\n<p>Length-decode</p>\n<p>The inverse of <code>++mat</code>. Accepts a cell of index <code>a</code> and a bitstring <code>b</code>\nand produces the cell whose tail <code>q</code> is the decoded atom at index <code>a</code>\nand whose head is the length of the encoded atom <code>q</code>, by which the\noffset <code>a</code> is advanced. Only used internally as a helper cue.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is a bitstring as an atom.</p>\n<h2>Produces</h2>\n<p>A cell of two atoms, <code>p</code> and <code>q</code>.</p>\n<h2>Source</h2>\n<pre><code>++  rub                                                 ::  length-decode\n  ~/  %rub\n  |=  {a/@ b/@}\n  ^-  {p/@ q/@}\n  =+  ^=  c\n      =+  [c=0 m=(met 0 b)]\n      |-  ?&lt;  (gth c m)\n      ?.  =(0 (cut 0 [(add a c) 1] b))\n        c\n      $(c +(c))\n  ?:  =(0 c)\n    [1 0]\n  =+  d=(add a +(c))\n  =+  e=(add (bex (dec c)) (cut 0 [d (dec c)] b))\n  [(add (add c c) e) (cut 0 [(add d (dec c)) e] b)]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ub`(jam 0xaaa)\n0b1.0101.0101.0101.0010.0000\n&gt; (rub 1 0b1.0101.0101.0101.0010.0000)\n[p=20 q=2.730]\n&gt; `@ux`q:(rub 1 0b1.0101.0101.0101.0010.0000)\n0xaaa\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "char"
        ],
        "doc": "<h1><code>++char</code></h1>\n<p>Char</p>\n<p>A single character. odor <code>@tD</code> designates a single unicode byte. All\nparsers consume <code>++tape</code>s, which are lists of <code>++char</code>.</p>\n<h2>Source</h2>\n<pre><code>++  char  @tD                                          ::  UTF-8 byte\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *char\n''\n~zod/try&gt; (char 97)\n'a'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cord"
        ],
        "doc": "<h1><code>++cord</code></h1>\n<p>UTF-8 text</p>\n<p>One of Hoon's two string types (the other being <code>++tape</code>). A cord is an\natom of UTF-8 text. <code>++trip</code> and <code>++crip</code> convert between cord and\n<code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  cord  @t                                           ::  text atom (UTF-8)\n</code></pre>\n<h2>Examples</h2>\n<p>Odor <code>@t</code> designates a Unicode atom, little-endian: the first character\nin the text is the low byte.</p>\n<pre><code>&gt; `@ux`'foobar'\n0x7261.626f.6f66\n\n&gt; `@`'urbit'\n499.984.265.845\n&gt; (cord 499.984.265.845)\n'urbit'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "date"
        ],
        "doc": "<h1><code>++date</code></h1>\n<p>Point in time</p>\n<p>A boolean designating AD or BC, a year atom, a month\natom, and a <code>++tarp</code>, which is a day atom and a time.</p>\n<h2>Source</h2>\n<pre><code>++  date  {{a/? y/@ud} m/@ud t/tarp}                    ::  parsed date\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++year</code>, <code>++yore</code> <code>++stud</code>, <code>++dust</code></p>\n<pre><code>&gt; `date`(yore ~2014.6.6..21.09.15..0a16)\n[[a=%.y y=2.014] m=6 t=[d=6 h=21 m=9 s=15 f=~[0xa16]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tang"
        ],
        "doc": "<h1><code>++tang</code></h1>\n<pre><code>++  tang  (list tank)                                   ::  general error\n</code></pre>\n<p>Unused XX</p>\n<hr>\n"
    },
    {
        "keys": [
            "tank"
        ],
        "doc": "<h1><code>++tank</code></h1>\n<p>Pretty-printing structure.</p>\n<p>A <code>++tank</code> is one of three cases: a <code>%leaf</code>\nis simply a string; a <code>%palm</code> is XX need more information; and a <code>%rose</code> is a\nlist of <code>++tank</code> delimted by the strings in <code>p</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tank  $%  {$leaf p/tape}                            ::  printing formats\n              $:  $palm                                 ::  backstep list\n                  p/{p/tape q/tape r/tape s/tape}       ::\n                  q/(list tank)                         ::\n              ==                                        ::\n              $:  $rose                                 ::  flat list\n                  p/{p/tape q/tape r/tape}              ::  mid open close\n                  q/(list tank)                         ::\n              ==                                        ::\n          ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; &gt;(bex 20) (bex 19)&lt;\n[%rose p=[p=\" \" q=\"[\" r=\"]\"] q=~[[%leaf p=\"1.048.576\"] [%leaf p=\"524.288\"]]]\n&gt; (wash [0 80] &gt;(bex 20) (bex 19)&lt;)  :: at 80 cols\n&lt;&lt;\"[1.048.576 524.288]\"&gt;&gt;\n&gt; (wash [0 15] &gt;(bex 20) (bex 19)&lt;)  :: at 15 cols (two lines)\n&lt;&lt;\"[ 1.048.576\" \"  524.288\" \"]\"&gt;&gt;\n\n&gt; [(bex 150) (bex 151)]  :: at 80 cols\n[ 1.427.247.692.705.959.881.058.285.969.449.495.136.382.746.624\n  2.854.495.385.411.919.762.116.571.938.898.990.272.765.493.248\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tape"
        ],
        "doc": "<h1><code>++tape</code></h1>\n<p>List of chars</p>\n<p>One of Hoon's two string types, the other being <code>++cord</code>. A tape is a\nlist of chars.</p>\n<h2>Source</h2>\n<pre><code>    ++  tape  (list char)                                   ::  like a string\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `(list char)`\"foobar\"\n\"foobar\"\n&gt; `(list @)`\"foobar\"\n~[102 111 111 98 97 114]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tarp"
        ],
        "doc": "<h1><code>++tarp</code></h1>\n<p>Day through second</p>\n<p>The remaining part of a <code>++date</code>: day, hour, minute, second and a list\nof <code>@ux</code> for precision.</p>\n<h2>Source</h2>\n<pre><code>++  tarp  {d/@ud h/@ud m/@ud s/@ud f/(list @ux)}        ::  parsed time\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; -&lt;-\n~2014.9.20..00.43.33..b52a\n&gt; :: the time is always in your context at -&lt;-\n&gt; (yell -&lt;-)\n[d=106.751.991.820.278 h=0 m=43 s=39 f=~[0x54d1]]\n\n&gt; (yell ~d20)\n[d=20 h=0 m=0 s=0 f=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "term"
        ],
        "doc": "<h1><code>++term</code></h1>\n<p>Hoon constants</p>\n<p>A restricted text atom for Hoon constants. The only characters permitted are\nlowercase ASCII, <code>-</code>, and <code>0-9</code>, the latter two of which can neither be the first or last\ncharacter. The syntax for <code>@tas</code> is the text itself, always preceded by <code>%</code>.\nThis means a term is always cubical. The empty <code>@tas</code> has a special syntax,\n<code>$</code>.</p>\n<h2>Source</h2>\n<pre><code>    ++  term  @tas                                         ::  Hoon ASCII subset\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *term\n%$\n\n&gt; %dead-fish9\n%dead-fish9\n&gt; -:!&gt;(%dead-fish9)\n[%cube p=271.101.667.197.767.630.546.276 q=[%atom p=%tas]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wain"
        ],
        "doc": "<h1><code>++wain</code></h1>\n<pre><code>++  wain  (list cord)                                   ::  text lines (no \\n)\n</code></pre>\n<p>A list of lines. A <code>++wain</code> is used instead of a single <code>++cord</code> with\n<code>\\n</code>.</p>\n<p>See also: <code>++lore</code>, <code>++role</code></p>\n<pre><code>&gt; `wain`/som/del/rok\n&lt;|som del rok|&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wall"
        ],
        "doc": "<h1><code>++wall</code></h1>\n<p>List of lines</p>\n<p>A <code>++wall</code> is used instead of a single <code>++tape</code> with\n<code>\\n</code>.</p>\n<h2>Source</h2>\n<pre><code>++  wall  (list tape)                                   ::  text lines (no \\n)\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++wash</code></p>\n<pre><code>&gt; `wall`(wash [0 20] leaf+&lt;(bex 256)&gt;)\n&lt;&lt;\n  \"115.792.089.237.316.195.423.570.985.008.687.907.853.269.984.665.640.564.039.457.584.007.913.129.639.936\"\n&gt;&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fe`                                                 ::  modulo blo"
        ],
        "doc": "<h1><code>++fe</code>                                                 ::  modulo bloq</h1>\n<p>Modulo bloq</p>\n<p>Core containing XX</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++bloq</code>.</p>\n<h2>Source</h2>\n<pre><code>|_  a=bloq\n</code></pre>\n"
    },
    {
        "keys": [
            "dif"
        ],
        "doc": "<h1><code>++dif</code></h1>\n<p>Produces the difference between two atoms in the modular basis\nrepresentation.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++bloq</code>.</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>@s</code></p>\n<h2>Source</h2>\n<pre><code>  ++  dif  |=([b/@ c/@] (sit (sub (add out (sit b)) (sit c))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (~(dif fe 3) 63 64)\n255\n&gt; (~(dif fe 3) 5 10)\n251\n&gt; (~(dif fe 3) 0 1)\n255\n&gt; (~(dif fe 0) 9 10)\n1\n&gt; (~(dif fe 0) 9 11)\n0\n&gt; (~(dif fe 0) 9 12)\n1\n&gt; (~(dif fe 2) 9 12)\n13\n&gt; (~(dif fe 2) 63 64)\n15\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "inv"
        ],
        "doc": "<h1><code>++inv</code></h1>\n<p>Invert mod field</p>\n<p>Inverts the order of the modular field.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a <code>++bloq</code>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  inv  |=(b/@ (sub (dec out) (sit b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (~(inv fe 3) 255)\n0\n&gt; (~(inv fe 3) 256)\n255\n&gt; (~(inv fe 3) 0)\n255\n&gt; (~(inv fe 3) 1)\n254\n&gt; (~(inv fe 3) 2)\n253\n&gt; (~(inv fe 3) 55)\n200\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "net"
        ],
        "doc": "<h1><code>++net</code></h1>\n<p>Reverse bytes</p>\n<p>Revereses bytes within block.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a <code>++bloq</code>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  net  |=  b/@  ^-  @\n           =&gt;  .(b (sit b))\n           ?:  (lte a 3)\n             b\n           =+  c=(dec a)\n           %+  con\n             (lsh c 1 $(a c, b (cut c [0 1] b)))\n           $(a c, b (cut c [1 1] b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (~(net fe 3) 64)\n64\n&gt; (~(net fe 3) 128)\n128\n&gt; (~(net fe 3) 255)\n255\n&gt; (~(net fe 3) 256)\n0\n&gt; (~(net fe 3) 257)\n1\n&gt; (~(net fe 3) 500)\n244\n&gt; (~(net fe 3) 511)\n255\n&gt; (~(net fe 3) 512)\n0\n&gt; (~(net fe 3) 513)\n1\n&gt; (~(net fe 3) 0)\n0\n&gt; (~(net fe 3) 1)\n1\n&gt; (~(net fe 0) 1)\n1\n&gt; (~(net fe 0) 2)\n0\n&gt; (~(net fe 0) 3)\n1\n&gt; (~(net fe 6) 1)\n72.057.594.037.927.936\n&gt; (~(net fe 6) 2)\n144.115.188.075.855.872\n&gt; (~(net fe 6) 3)\n216.172.782.113.783.808\n&gt; (~(net fe 6) 4)\n288.230.376.151.711.744\n&gt; (~(net fe 6) 5)\n360.287.970.189.639.680\n&gt; (~(net fe 6) 6)\n432.345.564.227.567.616\n&gt; (~(net fe 6) 7)\n504.403.158.265.495.552\n&gt; (~(net fe 6) 512)\n562.949.953.421.312\n&gt; (~(net fe 6) 513)\n72.620.543.991.349.248\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "out"
        ],
        "doc": "<h1><code>++out</code></h1>\n<p>Max integer value</p>\n<p>The maximum integer value that the current block can store.</p>\n<h2>Accepts</h2>\n<p>A <code>++bloq</code>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  out  (bex (bex a))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ~(out fe 0)\n2\n&gt; ~(out fe 1)\n4\n&gt; ~(out fe 2)\n16\n&gt; ~(out fe 3)\n256\n&gt; ~(out fe 4)\n65.536\n&gt; ~(out fe 10)\n\\/179.769.313.486.231.590.772.930.519.078.902.473.361.797.697.894.230.657.\\/\n  273.430.081.157.732.675.805.500.963.132.708.477.322.407.536.021.120.113.\n  879.871.393.357.658.789.768.814.416.622.492.847.430.639.474.124.377.767.\n  893.424.865.485.276.302.219.601.246.094.119.453.082.952.085.005.768.838.\n  150.682.342.462.881.473.913.110.540.827.237.163.350.510.684.586.298.239.\n  947.245.938.479.716.304.835.356.329.624.224.137.216\n\\/                                                                        \\/\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rol"
        ],
        "doc": "<h1><code>++rol</code></h1>\n<p>Roll left</p>\n<p>Roll <code>d</code> to the left by <code>c</code> <code>b</code>-sized blocks.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++bloq</code>.</p>\n<p><code>b</code> is a <code>++bloq</code>.</p>\n<p><code>c</code> is an atom.</p>\n<p><code>d</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  rol  |=  [b/bloq c/@ d/@]  ^-  @                  ::  roll left\n           =+  e=(sit d)\n           =+  f=(bex (sub a b))\n           =+  g=(mod c f)\n           (sit (con (lsh b g e) (rsh b (sub f g) e)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ux`(~(rol fe 6) 4 3 0xabac.dedf.1213)\n0x1213.0000.abac.dedf\n&gt; `@ux`(~(rol fe 6) 4 2 0xabac.dedf.1213)\n0xdedf.1213.0000.abac\n&gt; `@t`(~(rol fe 5) 3 1 'dfgh')\n'hdfg'\n&gt; `@t`(~(rol fe 5) 3 2 'dfgh')\n'ghdf'\n&gt; `@t`(~(rol fe 5) 3 0 'dfgh')\n'dfgh'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ror"
        ],
        "doc": "<h1><code>++ror</code></h1>\n<p>Roll right</p>\n<p>Roll <code>d</code> to the right by <code>c</code> <code>b</code>-sized blocks.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++bloq</code>.</p>\n<p><code>b</code> is a <code>++bloq</code>.</p>\n<p><code>c</code> is an atom.</p>\n<p><code>d</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  ror  |=  {b/bloq c/@ d/@}  ^-  @                  ::  roll right\n           =+  e=(sit d)\n           =+  f=(bex (sub a b))\n           =+  g=(mod c f)\n           (sit (con (rsh b g e) (lsh b (sub f g) e)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ux`(~(ror fe 6) 4 1 0xabac.dedf.1213)\n0x1213.0000.abac.dedf\n&gt; `@ux`(~(ror fe 6) 3 5 0xabac.dedf.1213)\n0xacde.df12.1300.00ab\n&gt; `@ux`(~(ror fe 6) 3 3 0xabac.dedf.1213)\n0xdf12.1300.00ab.acde\n&gt; `@t`(~(rol fe 5) 3 0 'hijk')\n'hijk'\n&gt; `@t`(~(rol fe 5) 3 1 'hijk')\n'khij'\n&gt; `@t`(~(rol fe 5) 3 2 'hijk')\n'jkhi'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sum"
        ],
        "doc": "<h1><code>++sum</code></h1>\n<p>Sum</p>\n<p>Sum two numbers in this modular field.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++bloq</code>.</p>\n<p><code>b</code> is an atom.</p>\n<p><code>c</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  sum  |=([b/@ c/@] (sit (add b c)))                ::  wrapping add\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (~(sum fe 3) 10 250)\n4\n&gt; (~(sum fe 0) 0 1)\n1\n&gt; (~(sum fe 0) 0 2)\n0\n&gt; (~(sum fe 2) 14 2)\n0\n&gt; (~(sum fe 2) 14 3)\n1\n&gt; (~(sum fe 4) 10.000 256)\n10.256\n&gt; (~(sum fe 4) 10.000 100.000)\n44.464\n</code></pre>\n"
    },
    {
        "keys": [
            "sit"
        ],
        "doc": "<h1><code>++sit</code></h1>\n<p>Atom in mod block representation</p>\n<p>Produce an atom in the current modular block representation.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++bloq</code>.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  sit  |=(b/@ (end a 1 b))                          ::  enforce modulo\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (~(sit fe 3) 255)\n255\n&gt; (~(sit fe 3) 256)\n0\n&gt; (~(sit fe 3) 257)\n1\n&gt; (~(sit fe 2) 257)\n1\n&gt; (~(sit fe 2) 10.000)\n0\n&gt; (~(sit fe 2) 100)\n4\n&gt; (~(sit fe 2) 19)\n3\n&gt; (~(sit fe 2) 17)\n1\n&gt; (~(sit fe 0) 17)\n1\n&gt; (~(sit fe 0) 0)\n0\n&gt; (~(sit fe 0) 1)\n1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "si"
        ],
        "doc": "<h1><code>++si</code></h1>\n<pre><code>++  si  !:                                              ::  signed integer\n  |%\n</code></pre>\n<p>Container core for the signed integer functions.</p>\n<hr>\n"
    },
    {
        "keys": [
            "abs"
        ],
        "doc": "<h1><code>++abs</code></h1>\n<p>Absolute value</p>\n<p>Produces the absolute value of a signed integer.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a signed integer, <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  abs  |=(a/@s (add (end 0 1 a) (rsh 0 1 a)))       ::  absolute value\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (abs:si -2)\n2\n&gt; (abs:si -10.000)\n10.000\n&gt; (abs:si --2)\n2\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dif"
        ],
        "doc": "<h1><code>++dif</code></h1>\n<p>Difference</p>\n<p>Produces the difference between two signed integers <code>b</code> and <code>c</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a signed integer, <code>@s</code>.</p>\n<p><code>b</code> is a signed integer, <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@s</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  dif  |=  [a/@s b/@s]                              ::  subtraction\n           (sum a (new !(syn b) (abs b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (dif:si --10 -7)\n--17\n&gt; (dif:si --10 --7)\n--3\n&gt; (dif:si `@s`0 --7)\n-7\n&gt; (dif:si `@s`0 `@s`7)\n--4\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dul"
        ],
        "doc": "<h1><code>++dul</code></h1>\n<p>Modulus</p>\n<p>Produces the modulus of two signed integers.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a signed integer, <code>@s</code>.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  dul  |=  [a/@s b/@]                               ::  modulus\n           =+(c=(old a) ?:(-.c (mod +.c b) (sub b +.c)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (dul:si --9 3)\n0\n&gt; (dul:si --9 4)\n1\n&gt; (dul:si --9 5)\n4\n&gt; (dul:si --9 6)\n3\n&gt; (dul:si --90 --10)\n10\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fra"
        ],
        "doc": "<h1><code>++fra</code></h1>\n<p>Divide</p>\n<p>Produces the quotient of two signed integers.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a signed integer, <code>@s</code>.</p>\n<p><code>b</code> is a signed integer, <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  fra  |=  [a/@s b/@s]                              ::  divide\n           (new =(0 (mix (syn a) (syn b))) (div (abs a) (abs b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (fra:si --10 -2)\n-5\n&gt; (fra:si -20 -5)\n--4\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "new"
        ],
        "doc": "<h1><code>++new</code></h1>\n<p>Signed integer</p>\n<p>Produces a signed integer from a loobean sign value <code>a</code> and an atom <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a loobean.</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>@s</code></p>\n<h2>Source</h2>\n<pre><code>  ++  new  |=  [a/? b/@]                                ::  [sign value] to @s\n           `@s`?:(a (mul 2 b) ?:(=(0 b) 0 +((mul 2 (dec b)))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (new:si [&amp; 10])\n--10\n&gt; (new:si [| 10])\n-10\n&gt; (new:si [%.y 7])\n--7\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "old"
        ],
        "doc": "<h1><code>++old</code></h1>\n<p>sign value</p>\n<p>Produces the cell <code>[sign value]</code> representations of a signed integer.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>A cell of a boolean and an atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  old  |=(a/@s [(syn a) (abs a)])                   ::  [sign value]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (old:si 7)\n! type-fail\n! exit\n&gt; (old:si -7)\n[%.n 7]\n&gt; (old:si --7)\n[%.y 7]\n&gt; (old:si `@s`7)\n[%.n 4]\n&gt; (old:si -0)\n[%.y 0]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pro"
        ],
        "doc": "<h1><code>++pro</code></h1>\n<p>Multiply</p>\n<p>Produces the product of two signed integers.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>@s</code>.</p>\n<p><code>b</code> is a  <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@s</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  pro  |=  [a/@s b/@s]                              ::  multiplication\n           (new =(0 (mix (syn a) (syn b))) (mul (abs a) (abs b)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (pro:si -4 --2)\n-8\n&gt; (pro:si -4 -2)\n--8\n&gt; (pro:si --10.000.000 -10)\n-100.000.000\n&gt; (pro:si -1.337 --0)\n--0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rem"
        ],
        "doc": "<h1><code>++rem</code></h1>\n<p>Remainder</p>\n<p>Produces the remainder from a division of two signed integers.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>@s</code>.</p>\n<p><code>b</code> is a <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@sd</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  rem  |=([a/@s b/@s] (dif a (pro b (fra a b))))    ::  remainder\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (rem:si -10 -4)\n-2\n&gt; (rem:si --10 --4)\n--2\n&gt; (rem:si --10 -4)\n--2\n&gt; (rem:si --7 --3)\n--1\n&gt; (rem:si --0 --10.000)\n--0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sum"
        ],
        "doc": "<h1><code>++sum</code></h1>\n<p>Add</p>\n<p>Sum two signed integers.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a <code>@s</code>.</p>\n<p><code>c</code> is a signed integer <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@s</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  sum  |=  [a/@s b/@s]                              ::  addition\n           ~|  %si-sum\n           =+  [c=(old a) d=(old b)]\n           ?:  -.c\n             ?:  -.d\n               (new &amp; (add +.c +.d))\n             ?:  (gte +.c +.d)\n               (new &amp; (sub +.c +.d))\n             (new | (sub +.d +.c))\n           ?:  -.d\n             ?:  (gte +.c +.d)\n               (new | (sub +.c +.d))\n             (new &amp; (sub +.d +.c))\n           (new | (add +.c +.d))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (sum:si --10 --10)\n--20\n&gt; (sum:si --10 -0)\n--10\n&gt; (sum:si -10 -7)\n-17\n&gt; (sum:si -10 --7)\n-3\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sun"
        ],
        "doc": "<h1><code>++sun</code></h1>\n<p>Signed from unsigned</p>\n<p>Produces a signed integer from an unsigned integer.</p>\n<p>Note that the result must be manually cast to some <code>@s</code> odor to be\ninferred as an unsigned integer in the type system.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>@u</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@s</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  sun  |=(a/@u (mul 2 a))                           ::  @u to @s\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@s`10\n--5\n&gt; (sun:si 10)\n20\n&gt; `@s`(sun:si 10)\n--10\n&gt; `@sd`(sun:si 10)\n--10\n&gt; `@sd`(sun:si 12.345)\n--12.345\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "syn"
        ],
        "doc": "<h1><code>++syn</code></h1>\n<p>Sign</p>\n<p>Produce the sign of a signed integer, where <code>&amp;</code> is posiitve, and <code>|</code> is negative.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>  ++  syn  |=(a/@s =(0 (end 0 1 a)))                    ::  sign test\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (syn:si -2)\n%.n\n&gt; (syn:si --2)\n%.y\n&gt; (syn:si -0)\n%.y\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cmp"
        ],
        "doc": "<h1><code>++cmp</code></h1>\n<p>Compare</p>\n<p>Compare two signed integers.</p>\n<h2>Accepts</h2>\n<p><code>b</code> is a  <code>@s</code>.</p>\n<p><code>c</code> is a  <code>@s</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@s</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  cmp  |=  [a/@s b/@s]                              ::  compare\n           ^-  @s\n           ?:  =(a b)\n             --0\n           ?:  (syn a)\n             ?:  (syn b)\n               ?:  (gth a b)\n                 --1\n               -1\n             --1\n          ?:  (syn b)\n            -1\n          ?:  (gth a b)\n            -1\n          --1\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (cmp:si --10 --10)\n--0\n&gt; (cmp:si --10 -0)\n--1\n&gt; (cmp:si -10 -7)\n-1\n&gt; (cmp:si -10 --7)\n-1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "egcd"
        ],
        "doc": "<h1><code>++egcd</code></h1>\n<p>GCD</p>\n<pre><code>++  egcd  !:                                            ::  schneier's egcd\n  |=  {a/@ b/@}\n  =+  si\n  =+  [c=(sun a) d=(sun b)]\n  =+  [u=[c=(sun 1) d=--0] v=[c=--0 d=(sun 1)]]\n  |-  ^-  {d/@ u/@s v/@s}\n  ?:  =(--0 c)\n    [(abs d) d.u d.v]\n  ::  ?&gt;  ?&amp;  =(c (sum (pro (sun a) c.u) (pro (sun b) c.v)))\n  ::          =(d (sum (pro (sun a) d.u) (pro (sun b) d.v)))\n  ::      ==\n  =+  q=(fra d c)\n  %=  $\n    c  (dif d (pro q c))\n    d  c\n    u  [(dif d.u (pro q c.u)) c.u]\n    v  [(dif d.v (pro q c.v)) c.v]\n  ==\n::\n</code></pre>\n<p>Greatest common denominator</p>\n<pre><code>&gt; (egcd 20 15)\n[d=5 u=2 v=1]\n&gt; (egcd 24 16)\n[d=8 u=2 v=1]\n&gt; (egcd 7 5)\n[d=1 u=3 v=6]\n&gt; (egcd (shaf ~ %ham) (shaf ~ %sam))\n[ d=1\n  u=59.983.396.314.566.203.239.184.568.129.921.874.787  \n  v=38.716.650.351.034.402.960.165.718.823.532.275.722\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "yo"
        ],
        "doc": "<h1><code>++yo</code></h1>\n<pre><code>++  yo                                                  ::  time constants core\n</code></pre>\n<p>Useful constants for interacting with earth time.</p>\n"
    },
    {
        "keys": [
            "cet"
        ],
        "doc": "<h1><code>++cet</code></h1>\n<p>Days in a century. Derived by multiplying the number of days in a year\n(365) by the number of years in a century (100), then adding the number\ndays from leap years in a century (24).</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  |%  ++  cet  36.524                 ::  (add 24 (mul 100 365))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; cet:yo\n36.524\n&gt; (add 365 cet:yo)\n36.889\n&gt; (sub (add 24 (mul 100 365)) cet:yo)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "day"
        ],
        "doc": "<h1><code>++day</code></h1>\n<p>Number of seconds in a day.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>      ++  day  86.400                 ::  (mul 24 hor)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; day:yo\n86.400\n&gt; (add 60 day:yo)\n86.460\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "era"
        ],
        "doc": "<h1><code>++era</code></h1>\n<p>XX Revisit</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>      ++  era  146.097                ::  (add 1 (mul 4 cet))\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "hor"
        ],
        "doc": "<h1><code>++hor</code></h1>\n<p>Seconds in hour</p>\n<p>The number of seconds in an hour. Derived by multiplying the number of\nseconds in a minute by the minutes in an hour.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>      ++  hor  3.600                  ::  (mul 60 mit)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; hor:yo\n3.600\n&gt; (div hor:yo 60)\n60\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "jes"
        ],
        "doc": "<h1><code>++jes</code></h1>\n<p>XX Revisit</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>      ++  jes  106.751.991.084.417    ::  (mul 730.692.561 era)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; jes:yo\n106.751.991.084.417\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mit"
        ],
        "doc": "<h1><code>++mit</code></h1>\n<p>Seconds in minute</p>\n<p>The number of seconds in a minute.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>      ++  mit  60\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; mit:yo\n60\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "moh"
        ],
        "doc": "<h1><code>++moh</code></h1>\n<p>Days in month</p>\n<p>The days in each month of the Gregorian common year. A list of unsigned\ndecimal atoms (Either 28, 30, or 31) denoting the number of days in the\nmonth at the year at that index.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code> of <code>@ud</code></p>\n<h2>Source</h2>\n<pre><code>      ++  moh  `(list @ud)`[31 28 31 30 31 30 31 31 30 31 30 31 ~]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; moh:yo\n~[31 28 31 30 31 30 31 31 30 31 30 31]\n&gt; (snag 4 moh:yo)\n31\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "moy"
        ],
        "doc": "<h1><code>++moy</code></h1>\n<p>Moh with leapyear</p>\n<p>The days in each month of the Gregorian leap-year. A list of unsigned\ndecimal atoms (Either 29,30, or 31) denoting the number of days in the\nmonth at the leap-year at that index.</p>\n<h2>Examples</h2>\n<p>A <code>++list</code> of <code>@ud</code></p>\n<h2>Source</h2>\n<pre><code>      ++  moy  `(list @ud)`[31 29 31 30 31 30 31 31 30 31 30 31 ~]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; moy:yo\n~[31 29 31 30 31 30 31 31 30 31 30 31]\n&gt; (snag 1 moy:yo)\n29\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qad"
        ],
        "doc": "<h1><code>++qad</code></h1>\n<p>Seconds in 4 years</p>\n<p>The number of seconds in four years. Derived by adding one second to the\nnumber of seconds in four years.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>      ++  qad  126.144.001            ::  (add 1 (mul 4 yer))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; qad:yo\n126.144.001\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "yer"
        ],
        "doc": "<h1><code>++yer</code></h1>\n<p>Seconds in year</p>\n<p>The number of seconds in a year. Derived by multiplying the number of\nseconds in a day by 365.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>      ++  yer  31.536.000             ::  (mul 365 day)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; yer:yo\n31.536.000\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "yall"
        ],
        "doc": "<h1><code>++yall</code></h1>\n<p>Time since beginning of time</p>\n<p>Produce the date tuple of <code>[y=@ud m=@ud d=@ud]</code> of the year, month, and\nday from a number of days from the beginning of time.</p>\n<h2>Accepts</h2>\n<p><code>day</code> is a <a href=\"\"><code>@ud</code></a></p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  yall                                                ::  day / to day of year\n  |=  day/@ud\n  ^-  {y/@ud m/@ud d/@ud}\n  =+  [era=0 cet=0 lep=*?]\n  =&gt;  .(era (div day era:yo), day (mod day era:yo))\n  =&gt;  ^+  .\n      ?:  (lth day +(cet:yo))\n        .(lep &amp;, cet 0)\n      =&gt;  .(lep |, cet 1, day (sub day +(cet:yo)))\n      .(cet (add cet (div day cet:yo)), day (mod day cet:yo))\n  =+  yer=(add (mul 400 era) (mul 100 cet))\n  |-  ^-  {y/@ud m/@ud d/@ud}\n  =+  dis=?:(lep 366 365)\n  ?.  (lth day dis)\n    =+  ner=+(yer)\n    $(yer ner, day (sub day dis), lep =(0 (end 0 2 ner)))\n  |-  ^-  {y/@ud m/@ud d/@ud}\n  =+  [mot=0 cah=?:(lep moy:yo moh:yo)]\n  |-  ^-  {y/@ud m/@ud d/@ud}\n  =+  zis=(snag mot cah)\n  ?:  (lth day zis)\n    [yer +(mot) +(day)]\n  $(mot +(mot), day (sub day zis))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (yall 198)\n[y=0 m=7 d=17]\n&gt; (yall 90.398)\n[y=247 m=7 d=3]\n&gt; (yall 0)\n[y=0 m=1 d=1]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "yawn"
        ],
        "doc": "<h1><code>++yawn</code></h1>\n<p>Days since beginning of time</p>\n<p>Inverse of <code>yall</code>, computes number of days A.D. from y/m/d date as the\ntuple <code>[yer=@ud mot=@ud day=@ud]</code>.</p>\n<h2>Accepts</h2>\n<p><code>yer</code> is an unsigned decimal, <code>@ud</code>.</p>\n<p><code>mon</code> is an unsigned decimal, <code>@ud</code>.</p>\n<p><code>day</code> is an unsigned decimal, <code>@ud</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@ud</code>.</p>\n<h2>Source</h2>\n<pre><code>++  yawn                                                ::  days since Jesus\n  |=  {yer/@ud mot/@ud day/@ud}\n  ^-  @ud\n  =&gt;  .(mot (dec mot), day (dec day))\n  =&gt;  ^+  .\n      %=    .\n          day\n        =+  cah=?:((yelp yer) moy:yo moh:yo)\n        |-  ^-  @ud\n        ?:  =(0 mot)\n          day\n        $(mot (dec mot), cah (slag 1 cah), day (add day (snag 0 cah)))\n      ==\n  |-  ^-  @ud\n  ?.  =(0 (mod yer 4))\n    =+  ney=(dec yer)\n    $(yer ney, day (add day ?:((yelp ney) 366 365)))\n  ?.  =(0 (mod yer 100))\n    =+  nef=(sub yer 4)\n    $(yer nef, day (add day ?:((yelp nef) 1.461 1.460)))\n  ?.  =(0 (mod yer 400))\n    =+  nec=(sub yer 100)\n    $(yer nec, day (add day ?:((yelp nec) 36.525 36.524)))\n  (add day (mul (div yer 400) (add 1 (mul 4 36.524))))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (yawn 2.014 8 4)\n735.814\n&gt; (yawn 1.776 7 4)\n648.856\n&gt; (yawn 1.990 10 11)\n727.116\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "year"
        ],
        "doc": "<h1><code>++year</code></h1>\n<p>Accept a parsed date of form <code>[[a=? y=@ud] m=@ud t=tarp]</code> and produce\nits <code>@d</code>representation.</p>\n<h2>Accepts</h2>\n<p><code>det</code> is a <code>++date</code></p>\n<h2>Produces</h2>\n<p>A <code>@d</code>.</p>\n<h2>Source</h2>\n<pre><code>++  year                                                ::  date to @d\n  |=  det/date\n  ^-  @da\n  =+  ^=  yer\n      ?:  a.det\n        (add 292.277.024.400 y.det)\n      (sub 292.277.024.400 (dec y.det))\n  =+  day=(yawn yer m.det d.t.det)\n  (yule day h.t.det m.t.det s.t.det f.t.det)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (year [[a=%.y y=2.014] m=8 t=[d=4 h=20 m=4 s=57 f=~[0xd940]]])\n0x8000000d227df4e9d940000000000000\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "yell"
        ],
        "doc": "<h1><code>++yell</code></h1>\n<p>Produce a parsed daily time format from an atomic date.</p>\n<p><code>now</code> is a <code>@d</code>.</p>\n<h2>Source</h2>\n<pre><code>++  yell                                                ::  tarp from @d\n  |=  now/@d\n  ^-  tarp\n  =+  sec=(rsh 6 1 now)\n  =+  ^=  fan\n      =+  [muc=4 raw=(end 6 1 now)]\n      |-  ^-  (list @ux)\n      ?:  |(=(0 raw) =(0 muc))\n        ~\n      =&gt;  .(muc (dec muc))\n      [(cut 4 [muc 1] raw) $(raw (end 4 muc raw))]\n  =+  day=(div sec day:yo)\n  =&gt;  .(sec (mod sec day:yo))\n  =+  hor=(div sec hor:yo)\n  =&gt;  .(sec (mod sec hor:yo))\n  =+  mit=(div sec mit:yo)\n  =&gt;  .(sec (mod sec mit:yo))\n  [day hor mit sec fan]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (yell ~2014.3.20..05.42.53..7456)\n[d=106.751.991.820.094 h=5 m=42 s=53 f=~[0x7456]]\n&gt; (yell ~2014.6.9..19.09.40..8b66)\n[d=106.751.991.820.175 h=19 m=9 s=40 f=~[0x8b66]]\n&gt; (yell ~1776.7.4)\n[d=106.751.991.733.273 h=0 m=0 s=0 f=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "yelp"
        ],
        "doc": "<h1><code>++yelp</code></h1>\n<p>Leap-week?</p>\n<p>Determines whether a year contains an ISO 8601 leap week. Produces a\nloobean.</p>\n<h2>Accepts</h2>\n<p><code>yer</code> is an unsigned decimal, <code>@ud</code>.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>++  yelp                                                ::  leap year\n  |=  yer=@ud  ^-  ?\n  &amp;(=(0 (mod yer 4)) |(!=(0 (mod yer 100)) =(0 (mod yer 400))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (yelp 2.014)\n%.n\n&gt; (yelp 2.008)\n%.y\n&gt; (yelp 0)\n%.y\n&gt; (yelp 14.011)\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "yore"
        ],
        "doc": "<h1><code>++yore</code></h1>\n<p>Produces a <code>++date</code> from a <code>@d</code></p>\n<h2>Accepts</h2>\n<p><code>now</code> is a <code>@d</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++date</code>.</p>\n<h2>Source</h2>\n<pre><code>++  yore                                                ::  @d to date\n  |=  now/@da\n  ^-  date\n  =+  rip=(yell now)\n  =+  ger=(yall d.rip)\n  :-  ?:  (gth y.ger 292.277.024.400)\n        [a=&amp; y=(sub y.ger 292.277.024.400)]\n      [a=| y=+((sub 292.277.024.400 y.ger))]\n  [m.ger d.ger h.rip m.rip s.rip f.rip]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (yore -&lt;-)\n[[a=%.y y=2.014] m=8 t=[d=4 h=20 m=17 s=1 f=~[0x700d]]]\n&gt; (yore -&lt;-)\n[[a=%.y y=2.014] m=8 t=[d=4 h=20 m=28 s=53 f=~[0x7b82]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "yule"
        ],
        "doc": "<h1><code>++yule</code></h1>\n<p>Daily time to time atom</p>\n<p>Accept a <code>++tarp</code>, a parsed daily time, and produces a time atom,\n<code>@d</code>.</p>\n<h2>Accepts</h2>\n<p><code>rip</code> is a <code>++tarp</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@d</code>.</p>\n<h2>Source</h2>\n<pre><code>++  yule                                                ::  time atom\n  |=  rip/tarp\n  ^-  @d\n  =+  ^=  sec  ;:  add\n                 (mul d.rip day:yo)\n                 (mul h.rip hor:yo)\n                 (mul m.rip mit:yo)\n                 s.rip\n               ==\n  =+  ^=  fac  =+  muc=4\n               |-  ^-  @\n               ?~  f.rip\n                 0\n               =&gt;  .(muc (dec muc))\n               (add (lsh 4 muc i.f.rip) $(f.rip t.f.rip))\n  (con (lsh 6 1 sec) fac)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; =murica (yell ~1776.7.4)\n&gt; murica\n[d=106.751.991.733.273 h=0 m=0 s=0 f=~]\n&gt; (yule murica)\n0x8000000b62aaf5800000000000000000\n&gt; `@da`(yule murica)\n~1776.7.4\n&gt; `@da`(yule (yell ~2014.3.20..05.42.53..7456))\n~2014.3.20..05.42.53..7456\n&gt; `tarp`[31 12 30 0 ~]\n[d=31 h=12 m=30 s=0 f=~]\n&gt; `@dr`(yule `tarp`[31 12 30 0 ~])\n~d31.h12.m30\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "og"
        ],
        "doc": "<h1><code>++og</code></h1>\n<pre><code>++  og                                                  ::  shax-powered rng\n  ~/  %og\n  |_  a/@\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rad"
        ],
        "doc": "<h1><code>++rad</code></h1>\n<pre><code>  ++  rad                                               ::  random in range\n    |=  b/@  ^-  @\n    =+  c=(raw (met 0 b))\n    ?:((lth c b) c $(a +(a)))\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rads"
        ],
        "doc": "<h1><code>++rads</code></h1>\n<pre><code>  ++  rads                                              ::  random continuation\n    |=  b/@\n    =+  r=(rad b)\n    [r +&gt;.$(a (shas %og-s r))]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "raw"
        ],
        "doc": "<h1><code>++raw</code></h1>\n<pre><code>  ++  raw                                               ::  random bits\n    ~/  %raw\n    |=  b/@  ^-  @\n    %+  can\n      0\n    =+  c=(shas %og-a (mix b a))\n    |-  ^-  (list [@ @])\n    ?:  =(0 b)\n      ~\n    =+  d=(shas %og-b (mix b (mix a c)))\n    ?:  (lth b 256)\n      [[b (end 0 b d)] ~]\n    [[256 d] $(c d, b (sub b 256))]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "raws"
        ],
        "doc": "<h1><code>++raws</code></h1>\n<pre><code>  ++  raws                                              ::  random bits continuation\n    |=  b/@\n    =+  r=(raw b)\n    [r +&gt;.$(a (shas %og-s r))]\n  --\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "shad"
        ],
        "doc": "<h1><code>++shad</code></h1>\n<pre><code>++  shad  |=(ruz/@ (shax (shax ruz)))                   ::  double sha-256\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "shaf"
        ],
        "doc": "<h1><code>++shaf</code></h1>\n<pre><code>++  shaf                                                ::  half sha-256\n  |=  [sal/@ ruz/@]\n  =+  haz=(shas sal ruz)\n  (mix (end 7 1 haz) (rsh 7 1 haz))\n::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "shak"
        ],
        "doc": "<h1><code>++shak</code></h1>\n<pre><code>++  shak                                                ::  XX shd be PBKDF\n  |=  [who/@p wud/@]\n  (shas (mix %shak who) wud)\n::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "shal"
        ],
        "doc": "<h1><code>++shal</code></h1>\n<pre><code>++  shal                                                ::  sha-512 with length\n  ~/  %shal\n  |=  {len/@ ruz/@}  ^-  @\n  =&gt;  .(ruz (cut 3 [0 len] ruz))\n  =+  [few==&gt;(fe .(a 6)) wac=|=({a/@ b/@} (cut 6 [a 1] b))]\n  =+  [sum=sum.few ror=ror.few net=net.few inv=inv.few]\n  =+  ral=(lsh 0 3 len)\n  =+  ^=  ful\n      %+  can  0\n      :~  [ral ruz]\n          [8 128]\n          [(mod (sub 1.920 (mod (add 8 ral) 1.024)) 1.024) 0]\n          [128 (~(net fe 7) ral)]\n      ==\n  =+  lex=(met 10 ful)\n  =+  ^=  kbx  0x6c44.198c.4a47.5817.5fcb.6fab.3ad6.faec.\n                 597f.299c.fc65.7e2a.4cc5.d4be.cb3e.42b6.\n                 431d.67c4.9c10.0d4c.3c9e.be0a.15c9.bebc.\n                 32ca.ab7b.40c7.2493.28db.77f5.2304.7d84.\n                 1b71.0b35.131c.471b.113f.9804.bef9.0dae.\n                 0a63.7dc5.a2c8.98a6.06f0.67aa.7217.6fba.\n                 f57d.4f7f.ee6e.d178.eada.7dd6.cde0.eb1e.\n                 d186.b8c7.21c0.c207.ca27.3ece.ea26.619c.\n                 c671.78f2.e372.532b.bef9.a3f7.b2c6.7915.\n                 a450.6ceb.de82.bde9.90be.fffa.2363.1e28.\n                 8cc7.0208.1a64.39ec.84c8.7814.a1f0.ab72.\n                 78a5.636f.4317.2f60.748f.82ee.5def.b2fc.\n                 682e.6ff3.d6b2.b8a3.5b9c.ca4f.7763.e373.\n                 4ed8.aa4a.e341.8acb.391c.0cb3.c5c9.5a63.\n                 34b0.bcb5.e19b.48a8.2748.774c.df8e.eb99.\n                 1e37.6c08.5141.ab53.19a4.c116.b8d2.d0c8.\n                 106a.a070.32bb.d1b8.f40e.3585.5771.202a.\n                 d699.0624.5565.a910.d192.e819.d6ef.5218.\n                 c76c.51a3.0654.be30.c24b.8b70.d0f8.9791.\n                 a81a.664b.bc42.3001.a2bf.e8a1.4cf1.0364.\n                 9272.2c85.1482.353b.81c2.c92e.47ed.aee6.\n                 766a.0abb.3c77.b2a8.650a.7354.8baf.63de.\n                 5338.0d13.9d95.b3df.4d2c.6dfc.5ac4.2aed.\n                 2e1b.2138.5c26.c926.27b7.0a85.46d2.2ffc.\n                 1429.2967.0a0e.6e70.06ca.6351.e003.826f.\n                 d5a7.9147.930a.a725.c6e0.0bf3.3da8.8fc2.\n                 bf59.7fc7.beef.0ee4.b003.27c8.98fb.213f.\n                 a831.c66d.2db4.3210.983e.5152.ee66.dfab.\n                 76f9.88da.8311.53b5.5cb0.a9dc.bd41.fbd4.\n                 4a74.84aa.6ea6.e483.2de9.2c6f.592b.0275.\n                 240c.a1cc.77ac.9c65.0fc1.9dc6.8b8c.d5b5.\n                 efbe.4786.384f.25e3.e49b.69c1.9ef1.4ad2.\n                 c19b.f174.cf69.2694.9bdc.06a7.25c7.1235.\n                 80de.b1fe.3b16.96b1.72be.5d74.f27b.896f.\n                 550c.7dc3.d5ff.b4e2.2431.85be.4ee4.b28c.\n                 1283.5b01.4570.6fbe.d807.aa98.a303.0242.\n                 ab1c.5ed5.da6d.8118.923f.82a4.af19.4f9b.\n                 59f1.11f1.b605.d019.3956.c25b.f348.b538.\n                 e9b5.dba5.8189.dbbc.b5c0.fbcf.ec4d.3b2f.\n                 7137.4491.23ef.65cd.428a.2f98.d728.ae22\n  =+  ^=  hax  0x5be0.cd19.137e.2179.1f83.d9ab.fb41.bd6b.\n                 9b05.688c.2b3e.6c1f.510e.527f.ade6.82d1.\n                 a54f.f53a.5f1d.36f1.3c6e.f372.fe94.f82b.\n                 bb67.ae85.84ca.a73b.6a09.e667.f3bc.c908\n  =+  i=0\n  |-  ^-  @\n  ?:  =(i lex)\n    (rep 6 (turn (rip 6 hax) net))\n  =+  ^=  wox\n      =+  dux=(cut 10 [i 1] ful)\n      =+  wox=(rep 6 (turn (rip 6 dux) net))\n      =+  j=16\n      |-  ^-  @\n      ?:  =(80 j)\n        wox\n      =+  :*  l=(wac (sub j 15) wox)\n              m=(wac (sub j 2) wox)\n              n=(wac (sub j 16) wox)\n              o=(wac (sub j 7) wox)\n          ==\n      =+  x=:(mix (ror 0 1 l) (ror 0 8 l) (rsh 0 7 l))\n      =+  y=:(mix (ror 0 19 m) (ror 0 61 m) (rsh 0 6 m))\n      =+  z=:(sum n x o y)\n      $(wox (con (lsh 6 j z) wox), j +(j))\n  =+  j=0\n  =+  :*  a=(wac 0 hax)\n          b=(wac 1 hax)\n          c=(wac 2 hax)\n          d=(wac 3 hax)\n          e=(wac 4 hax)\n          f=(wac 5 hax)\n          g=(wac 6 hax)\n          h=(wac 7 hax)\n      ==\n  |-  ^-  @\n  ?:  =(80 j)\n    %=  ^$\n      i  +(i)\n      hax  %+  rep  6\n           :~  (sum a (wac 0 hax))\n               (sum b (wac 1 hax))\n               (sum c (wac 2 hax))\n               (sum d (wac 3 hax))\n               (sum e (wac 4 hax))\n               (sum f (wac 5 hax))\n               (sum g (wac 6 hax))\n               (sum h (wac 7 hax))\n           ==\n    ==\n  =+  l=:(mix (ror 0 28 a) (ror 0 34 a) (ror 0 39 a))   ::  S0\n  =+  m=:(mix (dis a b) (dis a c) (dis b c))            ::  maj\n  =+  n=(sum l m)                                       ::  t2\n  =+  o=:(mix (ror 0 14 e) (ror 0 18 e) (ror 0 41 e))   ::  S1\n  =+  p=(mix (dis e f) (dis (inv e) g))                 ::  ch\n  =+  q=:(sum h o p (wac j kbx) (wac j wox))            ::  t1\n  $(j +(j), a (sum q n), b a, c b, d c, e (sum d q), f e, g f, h g)\n::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "sham"
        ],
        "doc": "<h1><code>++sham</code></h1>\n<pre><code>++  sham                                                ::  noun hash\n  |=  yux/*  ^-  @uvH  ^-  @\n  ?@  yux\n    (shaf %mash yux)\n  (shaf %sham (jam yux))\n::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "shan"
        ],
        "doc": "<h1><code>++shan</code></h1>\n<pre><code>++  shan                                                ::  sha-1 (deprecated)\n  |=  ruz/@\n  =+  [few==&gt;(fe .(a 5)) wac=|=({a/@ b/@} (cut 5 [a 1] b))]\n  =+  [sum=sum.few ror=ror.few rol=rol.few net=net.few inv=inv.few]\n  =+  ral=(lsh 0 3 (met 3 ruz))\n  =+  ^=  ful\n      %+  can  0\n      :~  [ral ruz]\n          [8 128]\n          [(mod (sub 960 (mod (add 8 ral) 512)) 512) 0]\n          [64 (~(net fe 6) ral)]\n      ==\n  =+  lex=(met 9 ful)\n  =+  kbx=0xca62.c1d6.8f1b.bcdc.6ed9.eba1.5a82.7999\n  =+  hax=0xc3d2.e1f0.1032.5476.98ba.dcfe.efcd.ab89.6745.2301\n  =+  i=0\n  |-\n  ?:  =(i lex)\n    (rep 5 (flop (rip 5 hax)))\n  =+  ^=  wox\n      =+  dux=(cut 9 [i 1] ful)\n      =+  wox=(rep 5 (turn (rip 5 dux) net))\n      =+  j=16\n      |-  ^-  @\n      ?:  =(80 j)\n        wox\n      =+  :*  l=(wac (sub j 3) wox)\n              m=(wac (sub j 8) wox)\n              n=(wac (sub j 14) wox)\n              o=(wac (sub j 16) wox)\n          ==\n      =+  z=(rol 0 1 :(mix l m n o))\n      $(wox (con (lsh 5 j z) wox), j +(j))\n  =+  j=0\n  =+  :*  a=(wac 0 hax)\n          b=(wac 1 hax)\n          c=(wac 2 hax)\n          d=(wac 3 hax)\n          e=(wac 4 hax)\n      ==\n  |-  ^-  @\n  ?:  =(80 j)\n    %=  ^$\n      i  +(i)\n      hax  %+  rep  5\n           :~\n               (sum a (wac 0 hax))\n               (sum b (wac 1 hax))\n               (sum c (wac 2 hax))\n               (sum d (wac 3 hax))\n               (sum e (wac 4 hax))\n           ==\n    ==\n  =+  fx=(con (dis b c) (dis (not 5 1 b) d))\n  =+  fy=:(mix b c d)\n  =+  fz=:(con (dis b c) (dis b d) (dis c d))\n  =+  ^=  tem\n      ?:  &amp;((gte j 0) (lte j 19))\n        :(sum (rol 0 5 a) fx e (wac 0 kbx) (wac j wox))\n      ?:  &amp;((gte j 20) (lte j 39))\n        :(sum (rol 0 5 a) fy e (wac 1 kbx) (wac j wox))\n      ?:  &amp;((gte j 40) (lte j 59))\n        :(sum (rol 0 5 a) fz e (wac 2 kbx) (wac j wox))\n      :(sum (rol 0 5 a) fy e (wac 3 kbx) (wac j wox))\n  $(j +(j), a tem, b a, c (rol 0 30 b), d c, e d)\n::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "shas"
        ],
        "doc": "<h1><code>++shas</code></h1>\n<pre><code>++  shas                                                ::  salted hash\n  |=  [sal/@ ruz/@]\n  (shax (mix sal (shax ruz)))\n::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "shaw"
        ],
        "doc": "<h1><code>++shaw</code></h1>\n<pre><code>++  shaw                                                ::  hash to nbits\n  |=  [sal/@ len/@ ruz/@]\n  (~(raw og (shas sal (mix len ruz))) len)\n::\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "shax"
        ],
        "doc": "<h1><code>++shax</code></h1>\n<p>++  shax                                                ::  sha-256\n  ~/  %shax\n  |=  ruz/@  ^-  @\n  (shay [(met 3 ruz) ruz])\n::</p>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "shaz"
        ],
        "doc": "<h1><code>++shaz</code></h1>\n<pre><code>++  shaz                                                ::  sha-512\n  |=  ruz/@  ^-  @\n  (shal [(met 3 ruz) ruz])\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "aesc"
        ],
        "doc": "<h1><code>++aesc</code></h1>\n<pre><code>++  aesc                                                ::  AES-256\n  ~%  %aesc  +  ~\n  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "en"
        ],
        "doc": "<h1><code>++en</code></h1>\n<pre><code>  ++  en                                                ::  ECB enc\n    ~/  %en\n    |=  [a/@I b/@H]  ^-  @uxH\n    =+  ahem\n    (be &amp; (ex a) b)\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "de"
        ],
        "doc": "<h1><code>++de</code></h1>\n<pre><code>  ++  de                                                ::  ECB dec\n    ~/  %de\n    |=  [a/@I b/@H]  ^-  @uxH\n    =+  ahem\n    (be | (ix (ex a)) b)\n  --\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ahem"
        ],
        "doc": "<h1><code>++ahem</code></h1>\n<pre><code>  =&gt;\n    =+  =+  [gr=(ga 8 0x11b 3) few==&gt;(fe .(a 5))]\n        =+  [pro=pro.gr dif=dif.gr pow=pow.gr ror=ror.few]\n        [pro=pro dif=dif pow=pow ror=ror nnk=8 nnb=4 nnr=14]\n    =&gt;  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "cipa"
        ],
        "doc": "<h1><code>++cipa</code></h1>\n<pre><code>        ++  cipa                                        ::  AES params\n          $_  ^?  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "co"
        ],
        "doc": "<h1><code>++co</code></h1>\n<pre><code>      ++  co  *{p/@ q/@ r/@ s/@}                    ::  col coefs\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ix"
        ],
        "doc": "<h1><code>++ix</code></h1>\n<pre><code>      ++  ix  |~(a/@ *@)                            ::  key index\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ro"
        ],
        "doc": "<h1><code>++ro</code></h1>\n<pre><code>      ++  ro  *{p/@ q/@ r/@ s/@}                    ::  row shifts\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "su"
        ],
        "doc": "<h1><code>++su</code></h1>\n<pre><code>      ++  su  *@                                    ::  s-box\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pen"
        ],
        "doc": "<h1><code>++pen</code></h1>\n<pre><code>    ++  pen                                             ::  encrypt\n      ^-  cipa\n      |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "co"
        ],
        "doc": "<h1><code>++co</code></h1>\n<pre><code>  ++  co  [0x2 0x3 1 1]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ix"
        ],
        "doc": "<h1><code>++ix</code></h1>\n<pre><code>      ++  ix  |~(a/@ *@)                            ::  key index\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ro"
        ],
        "doc": "<h1><code>++ro</code></h1>\n<pre><code>      ++  ro  *{p/@ q/@ r/@ s/@}                    ::  row shifts\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "su"
        ],
        "doc": "<h1><code>++su</code></h1>\n<pre><code>      ++  su  0x7d0c.2155.6314.69e1.26d6.77ba.7e04.2b17.\n                6199.5383.3cbb.ebc8.b0f5.2aae.4d3b.e0a0.\n                ef9c.c993.9f7a.e52d.0d4a.b519.a97f.5160.\n                5fec.8027.5910.12b1.31c7.0788.33a8.dd1f.\n                f45a.cd78.fec0.db9a.2079.d2c6.4b3e.56fc.\n                1bbe.18aa.0e62.b76f.89c5.291d.711a.f147.\n                6edf.751c.e837.f9e2.8535.ade7.2274.ac96.\n                73e6.b4f0.cecf.f297.eadc.674f.4111.913a.\n                6b8a.1301.03bd.afc1.020f.3fca.8f1e.2cd0.\n                0645.b3b8.0558.e4f7.0ad3.bc8c.00ab.d890.\n                849d.8da7.5746.155e.dab9.edfd.5048.706c.\n                92b6.655d.cc5c.a4d4.1698.6886.64f6.f872.\n                25d1.8b6d.49a2.5b76.b224.d928.66a1.2e08.\n                4ec3.fa42.0b95.4cee.3d23.c2a6.3294.7b54.\n                cbe9.dec4.4443.8e34.87ff.2f9b.8239.e37c.\n                fbd7.f381.9ea3.40bf.38a5.3630.d56a.0952\n      --\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pin"
        ],
        "doc": "<h1><code>++pin</code></h1>\n<pre><code>    ++  pin                                             :: decrypt\n      ^-  cipa\n      |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "co"
        ],
        "doc": "<h1><code>++co</code></h1>\n<pre><code>      ++  co  [0xe 0xb 0xd 0x9]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ix"
        ],
        "doc": "<h1><code>++ix</code></h1>\n<pre><code>  ++  ix                                                ::  key expand, inv\n    |=  a=@  ^-  @\n    =+  [i=1 j=_@ b=_@ c=co:pin]\n    |-\n    ?:  =(nnr i)\n      a\n    =&gt;  .(b (cut 7 [i 1] a))\n    =&gt;  .(b (rep 5 (mcol (pode 5 4 b) c)))\n    =&gt;  .(j (sub nnr i))\n    %=    $\n        i  +(i)\n        a\n      %+  can  7\n      :~  [i (cut 7 [0 i] a)]\n          [1 b]\n          [j (cut 7 [+(i) j] a)]\n      ==\n    ==\n  --\n::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ro"
        ],
        "doc": "<h1><code>++ro</code></h1>\n<pre><code>      ++  ro  [0 3 2 1]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "su"
        ],
        "doc": "<h1><code>++su</code></h1>\n<pre><code>      ++  su  0x7d0c.2155.6314.69e1.26d6.77ba.7e04.2b17.\n                6199.5383.3cbb.ebc8.b0f5.2aae.4d3b.e0a0.\n                ef9c.c993.9f7a.e52d.0d4a.b519.a97f.5160.\n                5fec.8027.5910.12b1.31c7.0788.33a8.dd1f.\n                f45a.cd78.fec0.db9a.2079.d2c6.4b3e.56fc.\n                1bbe.18aa.0e62.b76f.89c5.291d.711a.f147.\n                6edf.751c.e837.f9e2.8535.ade7.2274.ac96.\n                73e6.b4f0.cecf.f297.eadc.674f.4111.913a.\n                6b8a.1301.03bd.afc1.020f.3fca.8f1e.2cd0.\n                0645.b3b8.0558.e4f7.0ad3.bc8c.00ab.d890.\n                849d.8da7.5746.155e.dab9.edfd.5048.706c.\n                92b6.655d.cc5c.a4d4.1698.6886.64f6.f872.\n                25d1.8b6d.49a2.5b76.b224.d928.66a1.2e08.\n                4ec3.fa42.0b95.4cee.3d23.c2a6.3294.7b54.\n                cbe9.dec4.4443.8e34.87ff.2f9b.8239.e37c.\n                fbd7.f381.9ea3.40bf.38a5.3630.d56a.0952\n      --\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "mcol"
        ],
        "doc": "<h1><code>++mcol</code></h1>\n<pre><code>    ++  mcol\n      |=  [a=(list ,@) b=[p=@ q=@ r=@ s=@]]  ^-  (list ,@)\n      =+  c=[p=_@ q=_@ r=_@ s=_@]\n      |-  ^-  (list ,@)\n      ?~  a  ~\n      =&gt;  .(p.c (cut 3 [0 1] i.a))\n      =&gt;  .(q.c (cut 3 [1 1] i.a))\n      =&gt;  .(r.c (cut 3 [2 1] i.a))\n      =&gt;  .(s.c (cut 3 [3 1] i.a))\n      :_  $(a t.a)\n      %+  rep  3\n      %+  turn\n        %-  limo\n        :~  [[p.c p.b] [q.c q.b] [r.c r.b] [s.c s.b]]\n            [[p.c s.b] [q.c p.b] [r.c q.b] [s.c r.b]]\n            [[p.c r.b] [q.c s.b] [r.c p.b] [s.c q.b]]\n            [[p.c q.b] [q.c r.b] [r.c s.b] [s.c p.b]]\n        ==\n      |=  [a=[@ @] b=[@ @] c=[@ @] d=[@ @]]\n      :(dif (pro a) (pro b) (pro c) (pro d))\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pode"
        ],
        "doc": "<h1><code>++pode</code></h1>\n<pre><code>    ++  pode                                            ::  explode to block\n      |=  [a=bloq b=@ c=@]  ^-  (list ,@)\n      =+  d=(rip a c)\n      =+  m=(met a c)\n      |-\n      ?:  =(m b)\n        d\n      $(m +(m), d (weld d (limo [0 ~])))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sube"
        ],
        "doc": "<h1><code>++sube</code></h1>\n<pre><code>    ++  sube                                            ::  s-box word\n      |=  [a=@ b=@]  ^-  @\n      (rep 3 (turn (pode 3 4 a) |=(c=@ (cut 3 [c 1] b))))\n    --\n  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "be"
        ],
        "doc": "<h1><code>++be</code></h1>\n<pre><code>  ++  be                                                ::  block cipher\n    |=  [a=? b=@ c=@H]  ^-  @uxH\n    ~|  %be-aesc\n    =&gt;  %=    .\n            +\n          =&gt;  +\n          |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ankh"
        ],
        "doc": "<h1><code>++ankh</code></h1>\n<pre><code>          ++  ankh\n            |=  [a=cipa b=@ c=@]\n            (pode 5 nnb (cut 5 [(mul (ix.a b) nnb) nnb] c))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sark"
        ],
        "doc": "<h1><code>++sark</code></h1>\n<pre><code>          ++  sark\n            |=  [c=(list ,@) d=(list ,@)]  ^-  (list ,@)\n            ?~  c  ~\n            ?~  d  !!\n            [(mix i.c i.d) $(c t.c, d t.d)]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "srow"
        ],
        "doc": "<h1><code>++srow</code></h1>\n<pre><code>          ++  srow\n            |=  [a=cipa b=(list ,@)]  ^-  (list ,@)\n            =+  [c=0 d=~ e=ro.a]\n            |-\n            ?:  =(c nnb)\n              d\n            :_  $(c +(c))\n            %+  rep  3\n            %+  turn\n              (limo [0 p.e] [1 q.e] [2 r.e] [3 s.e] ~)\n            |=  [f=@ g=@]\n            (cut 3 [f 1] (snag (mod (add g c) nnb) b))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "subs"
        ],
        "doc": "<h1><code>++subs</code></h1>\n<pre><code>          ++  subs\n            |=  [a=cipa b=(list ,@)]  ^-  (list ,@)\n            ?~  b  ~\n            [(sube i.b su.a) $(b t.b)]\n          --\n        ==\n    =+  [d=?:(a pen pin) e=(pode 5 nnb c) f=1]\n    =&gt;  .(e (sark e (ankh d 0 b)))\n    |-\n    ?.  =(nnr f)\n      =&gt;  .(e (subs d e))\n      =&gt;  .(e (srow d e))\n      =&gt;  .(e (mcol e co.d))\n      =&gt;  .(e (sark e (ankh d f b)))\n      $(f +(f))\n    =&gt;  .(e (subs d e))\n    =&gt;  .(e (srow d e))\n    =&gt;  .(e (sark e (ankh d nnr b)))\n    (rep 5 e)\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ex"
        ],
        "doc": "<h1><code>++ex</code></h1>\n<pre><code>  ++  ex                                                ::  key expand\n    |=  a=@I  ^-  @\n    =+  [b=a c=0 d=su:pen i=nnk]\n    |-\n    ?:  =(i (mul nnb +(nnr)))\n      b\n    =&gt;  .(c (cut 5 [(dec i) 1] b))\n    =&gt;  ?:  =(0 (mod i nnk))\n          =&gt;  .(c (ror 3 1 c))\n          =&gt;  .(c (sube c d))\n          .(c (mix c (pow (dec (div i nnk)) 2)))\n        ?:  &amp;((gth nnk 6) =(4 (mod i nnk)))\n          .(c (sube c d))\n        .\n    =&gt;  .(c (mix c (cut 5 [(sub i nnk) 1] b)))\n    =&gt;  .(b (can 5 [i b] [1 c] ~))\n    $(i +(i))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ix"
        ],
        "doc": "<h1><code>++ix</code></h1>\n<pre><code>  ++  ix                                                ::  key expand, inv\n    |=  a=@  ^-  @\n    =+  [i=1 j=_@ b=_@ c=co:pin]\n    |-\n    ?:  =(nnr i)\n      a\n    =&gt;  .(b (cut 7 [i 1] a))\n    =&gt;  .(b (rep 5 (mcol (pode 5 4 b) c)))\n    =&gt;  .(j (sub nnr i))\n    %=    $\n        i  +(i)\n        a\n      %+  can  7\n      :~  [i (cut 7 [0 i] a)]\n          [1 b]\n          [j (cut 7 [+(i) j] a)]\n      ==\n    ==\n  --\n::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "curt"
        ],
        "doc": "<h1><code>++curt</code></h1>\n<pre><code>++  curt                                                ::  curve25519\n  |=  [a=@ b=@]\n  =&gt;  %=    .\n          +\n        =&gt;  +\n        =+  =+  [p=486.662 q=(sub (bex 255) 19)]\n            =+  fq=~(. fo q)\n            [p=p q=q fq=fq]\n        |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "cla"
        ],
        "doc": "<h1><code>++cla</code></h1>\n<pre><code>        ++  cla\n          |=  raw=@\n          =+  low=(dis 248 (cut 3 [0 1] raw))\n          =+  hih=(con 64 (dis 127 (cut 3 [31 1] raw)))\n          =+  mid=(cut 3 [1 30] raw)\n          (can 3 [[1 low] [30 mid] [1 hih] ~])\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sqr"
        ],
        "doc": "<h1><code>++sqr</code></h1>\n<pre><code>        ++  sqr  |=(a=@ (mul a a))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "inv"
        ],
        "doc": "<h1><code>++inv</code></h1>\n<pre><code>        ++  inv  |=(a=@ (~(exp fo q) (sub q 2) a))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "cad"
        ],
        "doc": "<h1><code>++cad</code></h1>\n<pre><code>        ++  cad\n          |=  [n=[x=@ z=@] m=[x=@ z=@] d=[x=@ z=@]]\n          =+  ^=  xx\n              ;:  mul  4  z.d\n                %-  sqr  %-  abs:si\n                %+  dif:si\n                  (sun:si (mul x.m x.n))\n                (sun:si (mul z.m z.n))\n              ==\n          =+  ^=  zz\n              ;:  mul  4  x.d\n                %-  sqr  %-  abs:si\n                %+  dif:si\n                  (sun:si (mul x.m z.n))\n                (sun:si (mul z.m x.n))\n              ==\n          [(sit.fq xx) (sit.fq zz)]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "cub"
        ],
        "doc": "<h1><code>++cub</code></h1>\n<pre><code>        ++  cub\n          |=  [x=@ z=@]\n          =+  ^=  xx\n              %+  mul\n                %-  sqr  %-  abs:si\n                (dif:si (sun:si x) (sun:si z))\n              (sqr (add x z))\n          =+  ^=  zz\n              ;:  mul  4  x  z\n                :(add (sqr x) :(mul p x z) (sqr z))\n              ==\n          [(sit.fq xx) (sit.fq zz)]\n        --\n      ==\n  =+  one=[b 1]\n  =+  i=253\n  =+  r=one\n  =+  s=(cub one)\n  |-\n  ?:  =(i 0)\n    =+  x=(cub r)\n    (sit.fq (mul -.x (inv +.x)))\n  =+  m=(rsh 0 i a)\n  ?:  =(0 (mod m 2))\n     $(i (dec i), s (cad r s one), r (cub r))\n  $(i (dec i), r (cad r s one), s (cub s))\n::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ed"
        ],
        "doc": "<h1><code>++ed</code></h1>\n<pre><code>++  ed                                                  ::  ed25519\n  =&gt;\n    =+  =+  [b=256 q=(sub (bex 255) 19)]\n        =+  fq=~(. fo q)\n        =+  ^=  l\n             %+  add\n               (bex 252)\n             27.742.317.777.372.353.535.851.937.790.883.648.493\n        =+  d=(dif.fq 0 (fra.fq 121.665 121.666))\n        =+  ii=(exp.fq (div (dec q) 4) 2)\n        [b=b q=q fq=fq l=l d=d ii=ii]\n    ~%  %coed  +&gt;  ~\n    |%\n</code></pre>\n"
    },
    {
        "keys": [
            "norm"
        ],
        "doc": "<h1><code>++norm</code></h1>\n<pre><code>    ++  norm  |=(x=@ ?:(=(0 (mod x 2)) x (sub q x)))\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "xrec"
        ],
        "doc": "<h1><code>++xrec</code></h1>\n<pre><code>    ++  xrec                                            ::  recover x-coord\n      |=  y=@  ^-  @\n      =+  ^=  xx\n          %+  mul  (dif.fq (mul y y) 1)\n                   (inv.fq +(:(mul d y y)))\n      =+  x=(exp.fq (div (add 3 q) 8) xx)\n      ?:  !=(0 (dif.fq (mul x x) (sit.fq xx)))\n        (norm (pro.fq x ii))\n      (norm x)\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ward"
        ],
        "doc": "<h1><code>++ward</code></h1>\n<pre><code>    ++  ward                                            ::  edwards multiply\n      |=  [pp=[@ @] qq=[@ @]]  ^-  [@ @]\n      =+  dp=:(pro.fq d -.pp -.qq +.pp +.qq)\n      =+  ^=  xt\n          %+  pro.fq\n            %+  sum.fq\n              (pro.fq -.pp +.qq)\n            (pro.fq -.qq +.pp)\n          (inv.fq (sum.fq 1 dp))\n      =+  ^=  yt\n          %+  pro.fq\n            %+  sum.fq\n              (pro.fq +.pp +.qq)\n            (pro.fq -.pp -.qq)\n          (inv.fq (dif.fq 1 dp))\n      [xt yt]\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "scam"
        ],
        "doc": "<h1><code>++scam</code></h1>\n<pre><code>    ++  scam                                            ::  scalar multiply\n      |=  [pp=[@ @] e=@]  ^-  [@ @]\n      ?:  =(0 e)\n        [0 1]\n      =+  qq=$(e (div e 2))\n      =&gt;  .(qq (ward qq qq))\n      ?:  =(1 (dis 1 e))\n        (ward qq pp)\n      qq\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "etch"
        ],
        "doc": "<h1><code>++etch</code></h1>\n<pre><code>    ++  etch                                            ::  encode point\n      |=  pp=[@ @]  ^-  @\n      (can 0 ~[[(sub b 1) +.pp] [1 (dis 1 -.pp)]])\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "curv"
        ],
        "doc": "<h1><code>++curv</code></h1>\n<pre><code>    ++  curv                                            ::  point on curve?\n      |=  [x=@ y=@]  ^-  ?\n      .=  0\n          %+  dif.fq\n            %+  sum.fq\n              (pro.fq (sub q (sit.fq x)) x)\n            (pro.fq y y)\n          (sum.fq 1 :(pro.fq d x x y y))\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "deco"
        ],
        "doc": "<h1><code>++deco</code></h1>\n<pre><code>    ++  deco                                            ::  decode point\n      |=  s=@  ^-  (unit ,[@ @])\n      =+  y=(cut 0 [0 (dec b)] s)\n      =+  si=(cut 0 [(dec b) 1] s)\n      =+  x=(xrec y)\n      =&gt;  .(x ?:(!=(si (dis 1 x)) (sub q x) x))\n      =+  pp=[x y]\n      ?.  (curv pp)\n        ~\n      [~ pp]\n    ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "bb"
        ],
        "doc": "<h1><code>++bb</code></h1>\n<pre><code>    ++  bb\n      =+  bby=(pro.fq 4 (inv.fq 5))\n    [(xrec bby) bby]\n    ::\n    --\n  ~%  %ed  +  ~\n  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "puck"
        ],
        "doc": "<h1><code>++puck</code></h1>\n<pre><code>  ++  puck                                                ::  public key\n    ~/  %puck\n    |=  sk=@I  ^-  @\n    ?:  (gth (met 3 sk) 32)  !!\n    =+  h=(shal (rsh 0 3 b) sk)\n    =+  ^=  a\n        %+  add\n          (bex (sub b 2))\n        (lsh 0 3 (cut 0 [3 (sub b 5)] h))\n    =+  aa=(scam bb a)\n    (etch aa)\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "suck"
        ],
        "doc": "<h1><code>++suck</code></h1>\n<pre><code>  ++  suck                                                ::  keypair from seed\n    |=  se=@I  ^-  @uJ\n    =+  pu=(puck se)\n    (can 0 ~[[b se] [b pu]])\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sign"
        ],
        "doc": "<h1><code>++sign</code></h1>\n<pre><code>  ++  sign                                                ::  certify\n    ~/  %sign\n    |=  [m=@ se=@]  ^-  @\n    =+  sk=(suck se)\n    =+  pk=(cut 0 [b b] sk)\n    =+  h=(shal (rsh 0 3 b) sk)\n    =+  ^=  a\n        %+  add\n          (bex (sub b 2))\n        (lsh 0 3 (cut 0 [3 (sub b 5)] h))\n    =+  ^=  r\n        =+  hm=(cut 0 [b b] h)\n        =+  ^=  i\n            %+  can  0\n            :~  [b hm]\n                [(met 0 m) m]\n            ==\n        (shaz i)\n    =+  rr=(scam bb r)\n    =+  ^=  ss\n        =+  er=(etch rr)\n        =+  ^=  ha\n            %+  can  0\n            :~  [b er]\n                [b pk]\n                [(met 0 m) m]\n            ==\n        (~(sit fo l) (add r (mul (shaz ha) a)))\n    (can 0 ~[[b (etch rr)] [b ss]])\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "veri"
        ],
        "doc": "<h1><code>++veri</code></h1>\n<pre><code>  ++  veri                                                ::  validate\n    ~/  %veri\n    |=  [s=@ m=@ pk=@]  ^-  ?\n    ?:  (gth (div b 4) (met 3 s))  |\n    ?:  (gth (div b 8) (met 3 pk))  |\n    =+  cb=(rsh 0 3 b)\n    =+  rr=(deco (cut 0 [0 b] s))\n    ?~  rr  |\n    =+  aa=(deco pk)\n    ?~  aa  |\n    =+  ss=(cut 0 [b b] s)\n    =+  ha=(can 3 ~[[cb (etch u.rr)] [cb pk] [(met 3 m) m]])\n    =+  h=(shaz ha)\n    =((scam bb ss) (ward u.rr (scam u.aa h)))\n  ::\n  --\n::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "ob"
        ],
        "doc": "<h1><code>++ob</code></h1>\n<p>Reversible scrambling core, v2</p>\n<pre><code>++  ob\n  |%\n</code></pre>\n<p>A core for performing reversible scrambling operations for the <code>@p</code> phonetic base.</p>\n<hr>\n"
    },
    {
        "keys": [
            "feen"
        ],
        "doc": "<h1><code>++feen</code></h1>\n<p>Conceal structure, v2</p>\n<p>Randomly permutes atoms that fit into 17 to 32 bits into one another. If the\natom fits into 33 to 64 bits, does the same permutation on the low 32 bits\nonly. Otherwise, passes the atom through unchanged.</p>\n<h2>Accepts</h2>\n<p>An atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  feen                                              ::  conceal structure v2\n    |=  pyn/@  ^-  @\n    ?:  &amp;((gte pyn 0x1.0000) (lte pyn 0xffff.ffff))\n      (add 0x1.0000 (fice (sub pyn 0x1.0000)))\n    ?:  &amp;((gte pyn 0x1.0000.0000) (lte pyn 0xffff.ffff.ffff.ffff))\n      =+  lo=(dis pyn 0xffff.ffff)\n      =+  hi=(dis pyn 0xffff.ffff.0000.0000)\n      %+  con  hi\n      (add 0x1.0000 (fice (sub lo 0x1.0000)))\n    pyn\n  ::\n</code></pre>\n<h2>Examples</h2>\n<p>XX</p>\n<hr>\n"
    },
    {
        "keys": [
            "fend"
        ],
        "doc": "<h1><code>++fend</code></h1>\n<p>XX</p>\n<p>Randomly permutes atoms that fit into 17 to 32 bits into one another, and\nrandomly permutes the low 32 bits of atoms that fit into 33 to 64 bits;\notherwise, passes the atom through unchanged. The permutation is the inverse of\nthe one applied by <code>++feen</code>.</p>\n<h2>Accepts</h2>\n<p>An atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  fend                                              ::  restore structure v2\n    |=  cry/@  ^-  @\n    ?:  &amp;((gte cry 0x1.0000) (lte cry 0xffff.ffff))\n      (add 0x1.0000 (teil (sub cry 0x1.0000)))\n    ?:  &amp;((gte cry 0x1.0000.0000) (lte cry 0xffff.ffff.ffff.ffff))\n      =+  lo=(dis cry 0xffff.ffff)\n      =+  hi=(dis cry 0xffff.ffff.0000.0000)\n      %+  con  hi\n      (add 0x1.0000 (teil (sub lo 0x1.0000)))\n    cry\n  ::\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "fice"
        ],
        "doc": "<h1><code>++fice</code></h1>\n<p>XX</p>\n<h2>Accepts</h2>\n<p>An atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>      ++  fice                                              ::  adapted from\n        |=  nor/@                                           ::  black and rogaway\n        ^-  @                                               ::  \"ciphers with\n        =+  ^=  sel                                         ::   arbitrary finite\n        %+  rynd  2                                         ::   domains\", 2002\n        %+  rynd  1\n        %+  rynd  0\n        [(mod nor 65.535) (div nor 65.535)]\n        (add (mul 65.535 -.sel) +.sel)\n      ::\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "teil"
        ],
        "doc": "<h1><code>++teil</code></h1>\n<p>XX</p>\n<p>Applies the reverse of the Feistel-like cipher applied by <code>++fice</code>. Unlike\na conventional Feistel cipher that is its own inverse if keys are used in\nreverse order, this Feistel-like cipher uses two moduli that must be swapped\nwhen applying the reverse transformation.</p>\n<h2>Accepts</h2>\n<p>An atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  teil                                              ::  reverse ++fice\n    |=  vip/@\n    ^-  @\n    =+  ^=  sel\n    %+  rund  0\n    %+  rund  1\n    %+  rund  2\n    [(mod vip 65.535) (div vip 65.535)]\n    (add (mul 65.535 -.sel) +.sel)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "rynd"
        ],
        "doc": "<h1><code>++rynd</code></h1>\n<p>XX</p>\n<p>A single round of the Feistel-like cipher <code>++fice</code>. AES (<code>++aesc</code>) is\nused as the round function.</p>\n<h2>Accepts</h2>\n<p>A cell of three atoms, <code>n</code>, <code>l</code>, and <code>r</code>.</p>\n<h2>Produces</h2>\n<p>A cell of two atoms.</p>\n<h2>Source</h2>\n<pre><code>++  rynd                                              ::  feistel round\n  |=  [n/@ l/@ r/@]\n  ^-  [@ @]\n  :-  r\n  ?~  (mod n 2)\n    (~(sum fo 65.535) l (en:aesc (snag n raku) r))\n  (~(sum fo 65.536) l (en:aesc (snag n raku) r))\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "rund"
        ],
        "doc": "<h1><code>++rund</code></h1>\n<p>XX</p>\n<p>A single round of the Feistel-like reverse cipher <code>++teil</code>.</p>\n<h2>Accepts</h2>\n<p>A cell of three atoms, <code>n</code>, <code>l</code>, and <code>r</code>.</p>\n<h2>Produces</h2>\n<p>A cell of two atoms.</p>\n<h2>Source</h2>\n<p>++  rund                                              ::  reverse round\n    |=  {n/@ l/@ r/@}\n    ^-  {@ @}\n    :-  r\n    ?~  (mod n 2)\n      (~(dif fo 65.535) l (en:aesc (snag n raku) r))\n    (~(dif fo 65.536) l (en:aesc (snag n raku) r))</p>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "raku"
        ],
        "doc": "<h1><code>++raku</code></h1>\n<p>XX</p>\n<h2>Accepts</h2>\n<p>A list of atoms of odor <code>@ux</code> (hexadecimal).</p>\n<h2>Produces</h2>\n<p>Arbitrary keys for use with <code>++aesc</code>.</p>\n<h2>Source</h2>\n<pre><code>++  raku\n  ^-  (list ,@ux)\n  :~  0x15f6.25e3.083a.eb3e.7a55.d4db.fb99.32a3.\n        43af.2750.219e.8a24.e5f8.fac3.6c36.f968\n      0xf2ff.24fe.54d0.1abd.4b2a.d8aa.4402.8e88.\n        e82f.19ec.948d.b1bb.ed2e.f791.83a3.8133\n      0xa3d8.6a7b.400e.9e91.187d.91a7.6942.f34a.\n        6f5f.ab8e.88b9.c089.b2dc.95a6.aed5.e3a4\n  ==\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "un"
        ],
        "doc": "<h1><code>++un</code></h1>\n<p>Reversible scrambling core</p>\n<pre><code>++  un                                                  ::  =(x (wred (wren x)))\n  |%\n</code></pre>\n<p>A core that contains arms that perform reversible scrambling operations.\nUsed in the <code>@p</code> phonetic base.</p>\n<hr>\n"
    },
    {
        "keys": [
            "wren"
        ],
        "doc": "<h1><code>++wren</code></h1>\n<p>Conceal structure</p>\n<p>Scrambles a bytestring <code>pyn</code> by adding the current position to each\nbyte, looking it up in an s-box, and then performing the XOR operation\non the result, pushing it forward. Produces an atom.</p>\n<h2>Accepts</h2>\n<p><code>pyn</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  wren                                              ::  conceal structure\n    |=  pyn/@  ^-  @\n    =+  len=(met 3 pyn)\n    ?:  =(0 len)\n      0\n    =&gt;  .(len (dec len))\n    =+  mig=(zaft (xafo len (cut 3 [len 1] pyn)))\n    %+  can  3\n    %-  flop  ^-  (list {@ @})\n    :-  [1 mig]\n    |-  ^-  (list {@ @})\n    ?:  =(0 len)\n      ~\n    =&gt;  .(len (dec len))\n    =+  mog=(zyft :(mix mig (end 3 1 len) (cut 3 [len 1] pyn)))\n    [[1 mog] $(mig mog)]\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ux`(wren:un 'testing')\n0x30.bf6a.b9fe.7d8f\n&gt; `@ux`'testing'\n0x67.6e69.7473.6574\n&gt; `@da`(wred:un (wren:un ~2001.2.5))\n~2001.2.5\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wred"
        ],
        "doc": "<h1><code>++wred</code></h1>\n<p>Restore structure</p>\n<p>Unscrambles a bytestring <code>cry</code> by subtracting the current position from\neach byte, looking it up in an s-box, and performing the XOR operation\non the result, pushing it forward. Produces an atom.</p>\n<h2>Accepts</h2>\n<p><code>cry</code> is an atom.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  wred                                              ::  restore structure\n    |=  cry/@  ^-  @\n    =+  len=(met 3 cry)\n    ?:  =(0 len)\n      0\n    =&gt;  .(len (dec len))\n    =+  mig=(cut 3 [len 1] cry)\n    %+  can  3\n    %-  flop  ^-  (list {@ @})\n    :-  [1 (xaro len (zart mig))]\n    |-  ^-  (list {@ @})\n    ?:  =(0 len)\n      ~\n    =&gt;  .(len (dec len))\n    =+  mog=(cut 3 [len 1] cry)\n    [[1 :(mix mig (end 3 1 len) (zyrt mog))] $(mig mog)]\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (wred:un 0x30.bf6a.b9fe.7d8f)\n29.113.321.805.538.676\n&gt; `@t`(wred:un 0x30.bf6a.b9fe.7d8f)\n'testing'\n&gt; (wred:un (wren:un 200.038.426))\n200.038.426\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "xafo"
        ],
        "doc": "<h1><code>++xafo</code></h1>\n<p>Add modulo 255</p>\n<p>Produces the sum of two atoms modulo 255, encoded as a nonzero byte.</p>\n<h2>Accepts</h2>\n<p>A cell of two atoms, <code>a</code> and <code>b</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  xafo  |=([a/@ b/@] +((mod (add (dec b) a) 255)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (xafo:un 5 6)\n11\n&gt; (xafo:un 256 20)\n21\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "xaro"
        ],
        "doc": "<h1><code>++xaro</code></h1>\n<p>Subtract modulo 255</p>\n<p>Produces the difference between two atoms modulo 255, encoded as a\nnonzero byte.</p>\n<h2>Accepts</h2>\n<p>A cell of two atoms, <code>a</code> and <code>b</code>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  xaro  |=([a/@ b/@] +((mod (add (dec b) (sub 255 (mod a 255))) 255)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (xaro:un 17 57)\n40\n&gt; (xaro:un 265 12)\n2\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zaft"
        ],
        "doc": "<h1><code>++zaft</code></h1>\n<p>Look up in 255 sub box</p>\n<p>The inverse of <code>++zart</code>. Looks up a nonzero byte <code>a</code>in a substiution\nbox with 255 values, producing a unique nonzero byte.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom of one byte in length.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  zaft                                              ::  forward 255-sbox\n    |=  a/@D\n    =+  ^=  b\n        0xcc.75bc.86c8.2fb1.9a42.f0b3.79a0.92ca.21f6.1e41.cde5.fcc0.\n        7e85.51ae.1005.c72d.1246.07e8.7c64.a914.8d69.d9f4.59c2.8038.\n        1f4a.dca2.6fdf.66f9.f561.a12e.5a16.f7b0.a39f.364e.cb70.7318.\n        1de1.ad31.63d1.abd4.db68.6a33.134d.a760.edee.5434.493a.e323.\n        930d.8f3d.3562.bb81.0b24.43cf.bea5.a6eb.52b4.0229.06b2.6704.\n        78c9.45ec.d75e.58af.c577.b7b9.c40e.017d.90c3.87f8.96fa.1153.\n        0372.7f30.1c32.ac83.ff17.c6e4.d36d.6b55.e2ce.8c71.8a5b.b6f3.\n        9d4b.eab5.8b3c.e7f2.a8fe.9574.5de0.bf20.3f15.9784.9939.5f9c.\n        e609.564f.d8a4.b825.9819.94aa.2c08.8e4c.9b22.477a.2840.3ed6.\n        3750.6ef1.44dd.89ef.6576.d00a.fbda.9ed2.3b6c.7b0c.bde9.2ade.\n        5c88.c182.481a.1b0f.2bfd.d591.2726.57ba\n    (cut 3 [(dec a) 1] b)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (zaft:un 0x12)\n42\n&gt; (zaft:un 0xff)\n204\n&gt; (zaft:un 0x0)\n! decrement-underflow\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zart"
        ],
        "doc": "<h1><code>++zart</code></h1>\n<p>Reverse look up in 255 sub box</p>\n<p>The inverse of <code>++zaft</code>. Looks up the index of a nonzero byte <code>a</code> in\nthe substitution box with 255 values, producing a unique nonzero byte.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom of one byte in length.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  zart                                              ::  reverse 255-sbox\n    |=  a/@D\n    =+  ^=  b\n        0x68.4f07.ea1c.73c9.75c2.efc8.d559.5125.f621.a7a8.8591.5613.\n        dd52.40eb.65a2.60b7.4bcb.1123.ceb0.1bd6.3c84.2906.b164.19b3.\n        1e95.5fec.ffbc.f187.fbe2.6680.7c77.d30e.e94a.9414.fd9a.017d.\n        3a7e.5a55.8ff5.8bf9.c181.e5b6.6ab2.35da.50aa.9293.3bc0.cdc6.\n        f3bf.1a58.4130.f844.3846.744e.36a0.f205.789e.32d8.5e54.5c22.\n        0f76.fce7.4569.0d99.d26e.e879.dc16.2df4.887f.1ffe.4dba.6f5d.\n        bbcc.2663.1762.aed7.af8a.ca20.dbb4.9bc7.a942.834c.105b.c4d4.\n        8202.3e61.a671.90e6.273d.bdab.3157.cfa4.0c2e.df86.2496.f7ed.\n        2b48.2a9d.5318.a343.d128.be9c.a5ad.6bb5.6dfa.c5e1.3408.128d.\n        2c04.0339.97a1.2ff0.49d0.eeb8.6c0a.0b37.b967.c347.d9ac.e072.\n        e409.7b9f.1598.1d3f.33de.8ce3.8970.8e7a\n    (cut 3 [(dec a) 1] b)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ux`(zart:un 204)\n0xff\n&gt; `@ux`(zart:un 42)\n0x12\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zyft"
        ],
        "doc": "<h1><code>++zyft</code></h1>\n<p>Lookup byte in 256 sub box</p>\n<p>The inverse of <code>++zyrt</code>. Looks up a byte <code>a</code> in a substituion box\nwith 256 values, producing a byte.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom of one byte in length.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  zyft                                              ::  forward 256-sbox\n    |=  a/@D\n    =+  ^=  b\n        0xbb49.b71f.b881.b402.17e4.6b86.69b5.1647.115f.dddb.7ca5.\n          8371.4bd5.19a9.b092.605d.0d9b.e030.a0cc.78ba.5706.4d2d.\n          986a.768c.f8e8.c4c7.2f1c.effe.3cae.01c0.253e.65d3.3872.\n          ce0e.7a74.8ac6.daac.7e5c.6479.44ec.4143.3d20.4af0.ee6c.\n          c828.deca.0377.249f.ffcd.7b4f.eb7d.66f2.8951.042e.595a.\n          8e13.f9c3.a79a.f788.6199.9391.7fab.6200.4ce5.0758.e2f1.\n          7594.c945.d218.4248.afa1.e61a.54fb.1482.bea4.96a2.3473.\n          63c2.e7cb.155b.120a.4ed7.bfd8.b31b.4008.f329.fca3.5380.\n          9556.0cb2.8722.2bea.e96e.3ac5.d1bc.10e3.2c52.a62a.b1d6.\n          35aa.d05e.f6a8.0f3b.31ed.559d.09ad.f585.6d21.fd1d.8d67.\n          370b.26f4.70c1.b923.4684.6fbd.cf8b.5036.0539.9cdc.d93f.\n          9068.1edf.8f33.b632.d427.97fa.9ee1\n    (cut 3 [a 1] b)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (zyft:un 0x12)\n57\n&gt; (zyft:un 0x0)\n225\n&gt; (zyft:un 0xff)\n187\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zyrt"
        ],
        "doc": "<h1><code>++zyrt</code></h1>\n<p>Reverse lookup byte in 256 sub box</p>\n<p>The inverse of <code>++zyft</code>. Looks up a byte <code>a</code> in a substituion box\nwith 256 values, producing a byte.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom of one byte in length.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  zyrt                                              ::  reverse 256-sbox\n    |=  a/@D\n    =+  ^=  b\n        0x9fc8.2753.6e02.8fcf.8b35.2b20.5598.7caa.c9a9.30b0.9b48.\n          47ce.6371.80f6.407d.00dd.0aa5.ed10.ecb7.0f5a.5c3a.e605.\n          c077.4337.17bd.9eda.62a4.79a7.ccb8.44cd.8e64.1ec4.5b6b.\n          1842.ffd8.1dfb.fd07.f2f9.594c.3be3.73c6.2cb6.8438.e434.\n          8d3d.ea6a.5268.72db.a001.2e11.de8c.88d3.0369.4f7a.87e2.\n          860d.0991.25d0.16b9.978a.4bf4.2a1a.e96c.fa50.85b5.9aeb.\n          9dbb.b2d9.a2d1.7bba.66be.e81f.1946.29a8.f5d2.f30c.2499.\n          c1b3.6583.89e1.ee36.e0b4.6092.937e.d74e.2f6f.513e.9615.\n          9c5d.d581.e7ab.fe74.f01b.78b1.ae75.af57.0ec2.adc7.3245.\n          12bf.2314.3967.0806.31dc.cb94.d43f.493c.54a6.0421.c3a1.\n          1c4a.28ac.fc0b.26ca.5870.e576.f7f1.616d.905f.ef41.33bc.\n          df4d.225e.2d56.7fd6.1395.a3f8.c582\n    (cut 3 [a 1] b)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ux`(zyrt:un 57)\n0x12\n&gt; `@ux`(zyrt:un 225)\n0x0\n&gt; `@ux`(zyrt:un 187)\n0xff\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "coin"
        ],
        "doc": "<h1><code>++coin</code></h1>\n<p>Noun literal syntax cases</p>\n<p>Noun literal syntax cases: atoms, jammed nouns, and nestable tuples.\nParsed and printed using <code>++so</code> and <code>++co</code> cores.</p>\n<h2>Source</h2>\n<pre><code>++  coin  $%  {$$ p/dime}                               ::\n              {$blob p/*}                               ::\n              {$many p/(list coin)}                     ::\n          ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `coin`(need (slay '~s1'))\n[%$ p=[p=~.dr q=18.446.744.073.709.551.616]]\n&gt; `coin`(need (slay '0x2b59'))\n[%$ p=[p=~.ux q=11.097]]\n\n&gt; ~(rend co [%many ~[[%$ %ud 1] [%$ %tas 'a'] [%$ %s -2]]])\n\"._1_a_-2__\"\n&gt; ._1_a_-2__\n[1 %a -2]\n\n&gt; `@uv`(jam [3 4])\n0v2cd1\n&gt; (slay '~02cd1')\n[~ [%blob p=[3 4]]]\n&gt; ~02cd1\n[3 4]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dime"
        ],
        "doc": "<h1><code>++dime</code></h1>\n<p>Odor-atom pair</p>\n<p>Used in <code>++coin</code>. Convenience methods <code>++scot</code> and <code>++scow</code> (in\nSection 2eL) print dimes as <code>++cord</code> and <code>++tape</code>, respectively.\n<code>++slat</code>, <code>++slav</code>, and <code>++slaw</code> are used to parse atoms of\nspecific odors.</p>\n<h2>Source</h2>\n<pre><code>    ++  dime  {p/@ta q/@}                                  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; +&gt;:(slay '0x123')\np=[p=~.ux q=291]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "edge"
        ],
        "doc": "<h1><code>++edge</code></h1>\n<p>Parsing location metadata</p>\n<p>Optional result <code>p</code> and parsing continuation <code>q</code>.</p>\n<h2>Source</h2>\n<pre><code>        ++  hair  {p/@ud q/@ud}                                 ::  parsing trace\n</code></pre>\n<h2>Examples</h2>\n<p>See also: Section 2eD, <code>++rule</code></p>\n<pre><code>&gt; *edge\n[p=[p=0 q=0] q=~]\n&gt; (tall:vast [1 1] \"a b\")\n[p=[p=1 q=2] q=[~ [p=[%cnzz p=~[%a]] q=[p=[p=1 q=2] q=\" b\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hair"
        ],
        "doc": "<h1><code>++hair</code></h1>\n<p>Parsing line and column</p>\n<p>A pair of two <a href=\"\"><code>@ud</code></a> used in parsing indicating line and column number.</p>\n<h2>Source</h2>\n<pre><code>        ++  hair  {p/@ud q/@ud}                                 ::  parsing trace\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *hair\n[p=0 q=0]\n\n&gt; `hair`[1 1] :: parsing starts at [1 1] as a convention.\n[p=1 q=1]\n&gt; ((plus ace) [1 1] \"   --\")\n[p=[p=1 q=4] q=[~ u=[p=[~~. \"  \"] q=[p=[p=1 q=4] q=\"--\"]]]]\n&gt; `hair`p:((plus ace) [1 1] \"   --\")\n[p=1 q=4]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "like"
        ],
        "doc": "<h1><code>++like</code></h1>\n<p>Mold generator for an edge</p>\n<p><code>++like</code> generates an <code>++edge</code> with a parsed result set to a specific type.</p>\n<h2>Source</h2>\n<pre><code>++  like  |*  a/gate                                    ::  generic edge\n          |=  b/_`*`[(hair) ~]                          ::\n          :-  p=(hair -.b)                              ::\n          ^=  q                                         ::\n          ?@  +.b  ~                                    ::\n          :-  ~                                         ::\n          u=[p=(a +&gt;-.b) q=[p=(hair -.b) q=(tape +.b)]] ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *(like char)\n[p=[p=0 q=0] q=~]\n\n&gt; (ace [1 1] \" a\")\n[p=[p=1 q=2] q=[~ [p=~~. q=[p=[p=1 q=2] q=\"a\"]]]]\n&gt; `(like char)`(ace [1 1] \" a\")\n[p=[p=1 q=2] q=[~ [p=~~. q=[p=[p=1 q=2] q=\"a\"]]]]\n&gt; `(like ,@)`(ace [1 1] \" a\")\n[p=[p=1 q=2] q=[~ [p=32 q=[p=[p=1 q=2] q=\"a\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "nail"
        ],
        "doc": "<h1><code>++nail</code></h1>\n<p>Location, remainder of parsed text</p>\n<p>Indicates parsing position <code>p</code>, and remaining text to be parsed <code>q</code>.</p>\n<h2>Source</h2>\n<pre><code>        ++  nail  {p/hair q/tape}                               ::  parsing input\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; +&lt;:;~(plug cab cab)\nc=tub=[p=[p=0 q=0] q=\"\"]\n&gt; :: tub is a ++nail\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "path"
        ],
        "doc": "<h1><code>++path</code></h1>\n<p>Filesystem path</p>\n<p>A <code>++path</code> is a list of <code>++span</code>s aka <code>@ta</code>. Used in\n<code>%clay</code> and <code>%eyre</code> extensively.</p>\n<h2>Source</h2>\n<pre><code>        ++  path  (list knot)                                   ::  filesys location\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `path`\"abc\"\n/a/b/c\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pint"
        ],
        "doc": "<h1><code>++pint</code></h1>\n<p>Parsing range</p>\n<p>Mostly used for stacktraces. A <code>++pint</code> is a pair of\n<code>++hair</code>, indicating from <code>p</code> to <code>q</code>.</p>\n<h2>Source</h2>\n<pre><code>        ++  pint  {p/{p/@ q/@} q/{p/@ q/@}}                     ::  line+column range\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; !:(!!)\n! /~zod/try/~2014.9.20..01.22.04..52e3/:&lt;[1 4].[1 6]&gt;\n&gt; :: !! always produces a crash\n&gt; `pint`[[1 4] [1 6]]\n[p=[p=1 q=4] q=[p=1 q=6]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rule"
        ],
        "doc": "<h1><code>++rule</code></h1>\n<p>Parsing rule</p>\n<p><code>++rule</code> is an empty parsing rule, but it is used to check\nthat parsing rules match this with <code>_</code>.</p>\n<h2>Source</h2>\n<pre><code>        ++  rule  _|=(nail *edge)                               ::  parsing rule\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *rule\n[p=[p=0 q=0] q=[~ [p=0 q=[p=[p=0 q=0] q=\"\"]]]]\n\n&gt; ^+(rule [|=(a=nail [p.a ~])]:|6)\n&lt;1.dww [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;101.jzo 1.ypj %164&gt;]&gt;\n&gt; (^+(rule [|=(a=nail [p.a ~ u=['a' a]])]:|6) [1 1] \"hi\")\n[p=[p=1 q=1] q=[~ [p=97 q=[p=[p=1 q=1] q=\"hi\"]]]]\n&gt; ([|=(a=nail [p.a ~ u=['a' a]])]:|6 [1 1] \"hi\")\n[[p=1 q=1] ~ u=['a' p=[p=1 q=1] q=\"hi\"]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "spot"
        ],
        "doc": "<h1><code>++spot</code></h1>\n<p>Stack trace line</p>\n<p>A <code>++spot</code> is what we print after crashing.</p>\n<h2>Source</h2>\n<pre><code>        ++  spot  {p/path q/pint}                               ::  range in file\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; :into /=main=/bin/fail/hoon '!:  !!'\n+ /~zod/main/359/bin/fail/hoon\n&gt; :fail\n! /~zod/main/~2014.9.22..18.40.56..ef04/bin/fail/:&lt;[1 5].[1 7]&gt;\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "toon"
        ],
        "doc": "<h1><code>++toon</code></h1>\n<p>Nock computation result</p>\n<p>Either success (<code>%0</code>), a block with list of requests blocked on (<code>%1</code>), or\nfailure with stack trace (<code>%2</code>).</p>\n<h2>Source</h2>\n<pre><code>        ++  toon  $%  {$0 p/*}                                  ::  success\n                      {$1 p/(list)}                             ::  blocks\n                      {$2 p/(list tank)}                        ::  stack trace\n                                              ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mock [[20 21] 0 3] $~)\n[%0 p=21]\n&gt; (mock [[0] !=(.^(cy//=main/1))] ,~)\n[%1 p=~[[31.075 1.685.027.454 1.852.399.981 49 0]]]\n&gt; (path [31.075 1.685.027.454 1.852.399.981 49 0])\n/cy/~zod/main/1\n\n&gt; (mock [[1 2] !=(!:(+(.)))] ,~)\n[%2 p=~[[%leaf p=\"/~zod/try/~2014.9.23..18.34.32..d3c5/:&lt;[1 20].[1 24]&gt;\"]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wonk"
        ],
        "doc": "<h1><code>++wonk</code></h1>\n<p>XX Not a model?</p>\n<p>Pull result out of a <code>++edge</code>, or crash if there's no result.</p>\n<h2>Source</h2>\n<pre><code>    ++  wonk  |*(veq=edge ?~(q.veq !! p.u.q.veq))           ::\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <a href=\"\"><code>++edge</code></a></p>\n<pre><code>&gt; (wide:vast [1 1] \"(add 2 2)\")\n[ p=[p=1 q=10]\n    q\n  [ ~\n    [ p=[%cnhp p=[%cnzz p=~[%add]] q=~[[%dtzy p=%ud q=2] [%dtzy p=%ud q=2]]]\n      q=[p=[p=1 q=10] q=\"\"]\n    ]\n  ]\n]\n&gt; (wonk (wide:vast [1 1] \"(add 2 2)\"))\n[%cnhp p=[%cnzz p=~[%add]] q=~[[%dtzy p=%ud q=2] [%dtzy p=%ud q=2]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "po"
        ],
        "doc": "<h1><code>++po</code></h1>\n<pre><code>++  po\n  ~/  %po\n  =+  :-  ^=  sis                                       ::  prefix syllables\n      'dozmarbinwansamlitsighidfidlissogdirwacsabwissib\\\n      /rigsoldopmodfoglidhopdardorlorhodfolrintogsilmir\\\n      /holpaslacrovlivdalsatlibtabhanticpidtorbolfosdot\\\n      /losdilforpilramtirwintadbicdifrocwidbisdasmidlop\\\n      /rilnardapmolsanlocnovsitnidtipsicropwitnatpanmin\\\n      /ritpodmottamtolsavposnapnopsomfinfonbanporworsip\\\n      /ronnorbotwicsocwatdolmagpicdavbidbaltimtasmallig\\\n      /sivtagpadsaldivdactansidfabtarmonranniswolmispal\\\n      /lasdismaprabtobrollatlonnodnavfignomnibpagsopral\\\n      /bilhaddocridmocpacravripfaltodtiltinhapmicfanpat\\\n      /taclabmogsimsonpinlomrictapfirhasbosbatpochactid\\\n      /havsaplindibhosdabbitbarracparloddosbortochilmac\\\n      /tomdigfilfasmithobharmighinradmashalraglagfadtop\\\n      /mophabnilnosmilfopfamdatnoldinhatnacrisfotribhoc\\\n      /nimlarfitwalrapsarnalmoslandondanladdovrivbacpol\\\n      /laptalpitnambonrostonfodponsovnocsorlavmatmipfap'\n      ^=  dex                                           ::  suffix syllables\n      'zodnecbudwessevpersutletfulpensytdurwepserwylsun\\\n      /rypsyxdyrnuphebpeglupdepdysputlughecryttyvsydnex\\\n      /lunmeplutseppesdelsulpedtemledtulmetwenbynhexfeb\\\n      /pyldulhetmevruttylwydtepbesdexsefwycburderneppur\\\n      /rysrebdennutsubpetrulsynregtydsupsemwynrecmegnet\\\n      /secmulnymtevwebsummutnyxrextebfushepbenmuswyxsym\\\n      /selrucdecwexsyrwetdylmynmesdetbetbeltuxtugmyrpel\\\n      /syptermebsetdutdegtexsurfeltudnuxruxrenwytnubmed\\\n      /lytdusnebrumtynseglyxpunresredfunrevrefmectedrus\\\n      /bexlebduxrynnumpyxrygryxfeptyrtustyclegnemfermer\\\n      /tenlusnussyltecmexpubrymtucfyllepdebbermughuttun\\\n      /bylsudpemdevlurdefbusbeprunmelpexdytbyttyplevmyl\\\n      /wedducfurfexnulluclennerlexrupnedlecrydlydfenwel\\\n      /nydhusrelrudneshesfetdesretdunlernyrsebhulryllud\\\n      /remlysfynwerrycsugnysnyllyndyndemluxfedsedbecmun\\\n      /lyrtesmudnytbyrsenwegfyrmurtelreptegpecnelnevfes'\n  |%\n</code></pre>\n<p>Provides the phonetic syllables and name generators for the Urbit naming\nsystem. The two faces, <code>sis</code> and <code>dex</code> are available to the arms\ncontained in this section.</p>\n<hr>\n"
    },
    {
        "keys": [
            "ind"
        ],
        "doc": "<h1><code>++ind</code></h1>\n<p>Parse prefix</p>\n<p>Produces the byte of the right-hand syllable <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>++unit</code> of an atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  ind  ~/  %ind                                     ::  parse suffix\n           |=  a/@tas\n           =+  b=0\n           |-  ^-  (unit @)\n           ?:(=(256 b) ~ ?:(=(a (tod b)) [~ b] $(b +(b))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (ind:po 'zod')\n[~ 0]\n&gt; (ind:po 'zam')\n~\n&gt; (ind:po 'del')\n[~ 37]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ins"
        ],
        "doc": "<h1><code>++ins</code></h1>\n<p>Parse suffix</p>\n<p>Produces the byte of the left-hand phonetic syllable <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>++unit</code> of an atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  ins  ~/  %ins                                     ::  parse prefix\n           |=  a/@tas\n           =+  b=0\n           |-  ^-  (unit @)\n           ?:(=(256 b) ~ ?:(=(a (tos b)) [~ b] $(b +(b))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (ins:po 'mar')\n[~ 1]\n&gt; (ins:po 'son')\n[~ 164]\n&gt; (ins:po 'pit')\n[~ 242]\n&gt; (ins:po 'pok')\n~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tod"
        ],
        "doc": "<h1><code>++tod</code></h1>\n<p>Fetch prefix</p>\n<p>Produces the phonetic prefix syllable from index <code>a</code> within <code>dex</code> as an\natom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  tod  ~/  %tod                                     ::  fetch suffix\n           |=(a/@ ?&gt;((lth a 256) (cut 3 [(mul 3 a) 3] dex)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`(tod:po 1)\n'nec'\n&gt; `@t`(tod:po 98)\n'dec'\n&gt; `@t`(tod:po 0)\n'zod'\n&gt; `@t`(tod:po 150)\n'ryg'\n&gt; `@t`(tod:po 255)\n'fes'\n&gt; `@t`(tod:po 256)\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tos"
        ],
        "doc": "<h1><code>++tos</code></h1>\n<p>Fetch suffix</p>\n<p>Produces the phonetic prefix syllable from index <code>a</code> within <code>sis</code> as an\natom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  tos  ~/  %tos                                     ::  fetch suffix\n           |=(a/@ ?&gt;((lth a 256) (cut 3 [(mul 3 a) 3] sis)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`(tos:po 0)\n'doz'\n&gt; `@t`(tos:po 120)\n'fab'\n&gt; `@t`(tos:po 43)\n'pid'\n&gt; `@t`(tos:po 253)\n'mat'\n</code></pre>\n<hr>\n<hr>\n"
    },
    {
        "keys": [
            "at"
        ],
        "doc": "<h1><code>++at</code></h1>\n<pre><code>++  at\n  |_  a/@\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "r"
        ],
        "doc": "<h1><code>++r</code></h1>\n<pre><code>  ++  r\n    ?:  ?&amp;  (gte (met 3 a) 2)\n            |-\n            ?:  =(0 a)\n              &amp;\n            =+  vis=(end 3 1 a)\n            ?&amp;  ?|(=('-' vis) ?&amp;((gte vis 'a') (lte vis 'z')))\n                $(a (rsh 3 1 a))\n            ==\n        ==\n      rtam\n    ?:  (lte (met 3 a) 2)\n      rud\n    rux\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rf"
        ],
        "doc": "<h1><code>++rf</code></h1>\n<pre><code>  ++  rf    `tape`[?-(a $&amp; '&amp;', $| '|', * !!) ~]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rn"
        ],
        "doc": "<h1><code>++rn</code></h1>\n<pre><code>    ++  rn    `tape`[?&gt;(=(0 a) '~') ~]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rt"
        ],
        "doc": "<h1><code>++rt</code></h1>\n<pre><code>    ++  rt    `tape`['\\'' (weld (mesc (trip a)) `tape`['\\'' ~])]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rta"
        ],
        "doc": "<h1><code>++rta</code></h1>\n<pre><code>    ++  rta   rt\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rtam"
        ],
        "doc": "<h1><code>++rtam</code></h1>\n<pre><code>  ++  rtam  `tape`['%' (trip a)]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rub"
        ],
        "doc": "<h1><code>++rub</code></h1>\n<pre><code>  ++  rub   `tape`['0' 'b' (rum 2 ~ |=(b/@ (add '0' b)))]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rud"
        ],
        "doc": "<h1><code>++rud</code></h1>\n<pre><code>  ++  rud   (rum 10 ~ |=(b/@ (add '0' b)))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rum"
        ],
        "doc": "<h1><code>++rum</code></h1>\n<pre><code>  ++  rum\n    |=  {b/@ c/tape d/$-(@ @)}\n    ^-  tape\n    ?:  =(0 a)\n      [(d 0) c]\n    =+  e=0\n    |-  ^-  tape\n    ?:  =(0 a)\n      c\n    =+  f=&amp;(!=(0 e) =(0 (mod e ?:(=(10 b) 3 4))))\n    %=  $\n      a  (div a b)\n      c  [(d (mod a b)) ?:(f [?:(=(10 b) ',' '-') c] c)]\n      e  +(e)\n    ==\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rup"
        ],
        "doc": "<h1><code>++rup</code></h1>\n<pre><code>  ++  rup\n    =+  b=(met 3 a)\n    ^-  tape\n    :-  '-'\n    |-  ^-  tape\n    ?:  (gth (met 5 a) 1)\n      %+  weld\n        $(a (rsh 5 1 a), b (sub b 4))\n      `tape`['-' '-' $(a (end 5 1 a), b 4)]\n    ?:  =(0 b)\n      ['~' ~]\n    ?:  (lte b 1)\n      (trip (tos:po a))\n    |-  ^-  tape\n    ?:  =(2 b)\n      =+  c=(rsh 3 1 a)\n      =+  d=(end 3 1 a)\n      (weld (trip (tod:po c)) (trip (tos:po (mix c d))))\n    =+  c=(rsh 3 2 a)\n    =+  d=(end 3 2 a)\n    (weld ^$(a c, b (met 3 c)) `tape`['-' $(a (mix c d), b 2)])\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ruv"
        ],
        "doc": "<h1><code>++ruv</code></h1>\n<pre><code>  ++  ruv\n    ^-  tape\n    :+  '0'\n      'v'\n    %^    rum\n        64\n      ~\n    |=  b/@\n    ?:  =(63 b)\n      '+'\n    ?:  =(62 b)\n      '-'\n    ?:((lth b 26) (add 65 b) ?:((lth b 52) (add 71 b) (sub b 4)))\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "rux"
        ],
        "doc": "<h1><code>++rux</code></h1>\n<pre><code>  ++  rux  `tape`['0' 'x' (rum 16 ~ |=(b/@ (add b ?:((lth b 10) 48 87))))]\n  --\n  ::::::::::::::::::::::::::::::::::::::::::::::::::::::  ::\n</code></pre>\n<p>XX document</p>\n<hr>\n<hr>\n"
    },
    {
        "keys": [
            "cass"
        ],
        "doc": "<h1><code>++cass</code></h1>\n<p>To lowercase</p>\n<p>Produce the case insensitive (all lowercase) <a href=\"\"><code>++cord</code></a> of a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>vib</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++cord</code>.</p>\n<h2>Source</h2>\n<pre><code>++  cass                                                ::  lowercase\n  |=  vib/tape\n  %+  rap  3\n  (turn vib |=(a/@ ?.(&amp;((gte a 'A') (lte a 'Z')) a (add 32 a))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (cass \"john doe\")\n7.309.170.810.699.673.450\n&gt; `cord`(cass \"john doe\")\n'john doe'\n&gt; (cass \"abc, 123, !@#\")\n2.792.832.775.110.938.439.066.079.945.313\n&gt; `cord`(cass \"abc, 123, !@#\")\n'abc, 123, !@#' \n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "crip"
        ],
        "doc": "<h1><code>++crip</code></h1>\n<p>Tape to cord</p>\n<p>Produce a <code>++cord</code> from a <code>++tape</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++cord</code>.</p>\n<h2>Source</h2>\n<pre><code>++  crip  |=(a=tape `@t`(rap 3 a))                      ::  tape to cord\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (crip \"john doe\")\n'john doe'\n&gt; (crip \"abc 123 !@#\")\n'abc 123 !@#'\n&gt; `@ud`(crip \"abc\")\n6.513.249\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cuss"
        ],
        "doc": "<h1><code>++cuss</code></h1>\n<p>To uppercase</p>\n<p>Turn all occurances of lowercase letters in any <code>++tape</code> into uppercase\nletters, as a <code>++cord</code>.</p>\n<h2>Accepts</h2>\n<p><code>vib</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++cord</code>.</p>\n<h2>Source</h2>\n<pre><code>++  cuss                                                ::  uppercase\n  |=  vib=tape\n  ^-  @t\n  %+  rap  3\n  (turn vib |=(a=@ ?.(&amp;((gte a 'a') (lte a 'z')) a (sub a 32))))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (cuss \"john doe\")\n'JOHN DOE'\n&gt; (cuss \"abc ABC 123 !@#\")\n'ABC ABC 123 !@#'\n&gt; `@ud`(cuss \"abc\")\n4.407.873\n&gt; (cuss \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsQqRrVvWwXxYyZz\")\n'AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSQQRRVVWWXXYYZZ'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mesc"
        ],
        "doc": "<h1><code>++mesc</code></h1>\n<p>Escape special chars</p>\n<p>Escape special characters, used in <code>++show</code>.</p>\n<h2>Accepts</h2>\n<p><code>vib</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  mesc                                                ::  ctrl code escape\n  |=  vib/tape\n  ^-  tape\n  ?~  vib\n    ~\n  ?:  =('\\\\' i.vib)\n    ['\\\\' '\\\\' $(vib t.vib)]\n  ?:  ?|((gth i.vib 126) (lth i.vib 32) =(`@`39 i.vib))\n    ['\\\\' (welp ~(rux at i.vib) '/' $(vib t.vib))]\n  [i.vib $(vib t.vib)]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (mesc \"ham lus\")\n\"ham lus\"\n/&gt; (mesc \"bas\\\\hur\")\n\"bas\\\\\\\\hur\"\n/&gt; (mesc \"as'sa\u00df\")\n\"as\\0x27/sa\\0xc3/\\0x9f/\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "runt"
        ],
        "doc": "<h1><code>++runt</code></h1>\n<p>Prepend <code>n</code> times</p>\n<p>Add <code>a</code> repetitions of character <code>b</code> to the head of <code>++tape</code> <code>c</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> and <code>b</code> are atoms.</p>\n<p><code>c</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  runt                                                ::  prepend repeatedly\n  |=  [[a/@ b/@] c/tape]\n  ^-  tape\n  ?:  =(0 a)\n    c\n  [b $(a (dec a))]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (runt [2 '/'] \"ham\")\n\"//ham\"\n/&gt; (runt [10 'a'] \"\")\n\"aaaaaaaaaa\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sand"
        ],
        "doc": "<h1><code>++sand</code></h1>\n<p>Soft-cast by odor</p>\n<p>Soft-cast validity by odor.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++span</code> (<code>@ta</code>).</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>(unit @)</code>.</p>\n<h2>Source</h2>\n<pre><code>++  sand                                                ::  atom sanity\n  |=  a/@ta\n  |=  b/@  ^-  (unit @)\n  ?.(((sane a) b) ~ [~ b])\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; `(unit @ta)`((sand %ta) 'sym-som')\n[~ ~.sym-som]\n/&gt; `(unit @ta)`((sand %ta) 'err!')\n~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sane"
        ],
        "doc": "<h1><code>++sane</code></h1>\n<p>Check odor validity</p>\n<p>Check validity by odor. Produces a gate.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++span</code> (<code>@ta</code>).</p>\n<p><code>b</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>++  sane                                                ::  atom sanity\n  |=  a/@ta\n  |=  b/@  ^-  ?\n  ?.  =(%t (end 3 1 a))\n    ~|(%sane-stub !!)\n  =+  [inx=0 len=(met 3 b)]\n  ?:  =(%tas a)\n    |-  ^-  ?\n    ?:  =(inx len)  &amp;\n    =+  cur=(cut 3 [inx 1] b)\n    ?&amp;  ?|  &amp;((gte cur 'a') (lte cur 'z'))\n            &amp;(=('-' cur) !=(0 inx) !=(len inx))\n            &amp;(&amp;((gte cur '0') (lte cur '9')) !=(0 inx))\n        ==\n        $(inx +(inx))\n    ==\n  ?:  =(%ta a)\n    |-  ^-  ?\n    ?:  =(inx len)  &amp;\n    =+  cur=(cut 3 [inx 1] b)\n    ?&amp;  ?|  &amp;((gte cur 'a') (lte cur 'z'))\n            &amp;((gte cur '0') (lte cur '9'))\n            |(=('-' cur) =('~' cur) =('_' cur) =('.' cur))\n        ==\n        $(inx +(inx))\n    ==\n  |-  ^-  ?\n  ?:  =(0 b)  &amp;\n  =+  cur=(end 3 1 b)\n  ?:  &amp;((lth cur 32) !=(10 cur))  |\n  =+  len=(teff cur)\n  ?&amp;  |(=(1 len) =+(i=1 |-(|(=(i len) &amp;((gte (cut 3 [i 1] b) 128) $(i +(i)))))))\n      $(b (rsh 3 len b))\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; ((sane %tas) %mol)\n%.y\n/&gt; ((sane %tas) 'lam')\n%.y\n/&gt; ((sane %tas) 'more ace')\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "teff"
        ],
        "doc": "<h1><code>++teff</code></h1>\n<p>UTF8 Length</p>\n<p>Produces the number of utf8 bytes.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>@t</code>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  |=  a/@t  ^-  @\n  =+  b=(end 3 1 a)\n  ~|  %bad-utf8\n  ?:  =(0 b)\n    ?&gt;(=(`@`0 a) 0)\n  ?&gt;  |((gte b 32) =(10 b))\n  ?:((lte b 127) 1 ?:((lte b 223) 2 ?:((lte b 239) 3 4)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (teff 'a')\n1\n/&gt; (teff '\u00df')\n2\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "trim"
        ],
        "doc": "<h1><code>++trim</code></h1>\n<p>Tape split</p>\n<p>Split first <code>a</code> characters off <code>++tape</code> <code>b</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<p><code>b</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A cell of <code>++tape</code>s, <code>p</code> and <code>q</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  trim                                              ::  31-bit nonzero\n    |=  key/@\n    =+  syd=0xcafe.babe\n    |-  ^-  @\n    =+  haz=(spec syd key)\n    =+  ham=(mix (rsh 0 31 haz) (end 0 31 haz))\n    ?.(=(0 ham) ham $(syd +(syd)))\n  --\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (trim 5 \"lasok termun\")\n[p=\"lasok\" q=\" termun\"]\n/&gt; (trim 5 \"zam\")\n[p=\"zam\" q=\"\"]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "trip"
        ],
        "doc": "<h1><code>++trip</code></h1>\n<p>Cord to tape</p>\n<p>Produce a <code>++tape</code> from <code>++cord</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  trip                                                ::  cord to tape\n  ~/  %trip\n  |=  a/@  ^-  tape\n  ?:  =(0 (met 3 a))\n    ~\n  [^-(@ta (end 3 1 a)) $(a (rsh 3 1 a))]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (trip 'john doe')\n\"john doe\"\n/&gt; (trip 'abc 123 !@#')\n\"abc 123 !@#\"\n/&gt; (trip 'abc')\n\"abc\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tuba"
        ],
        "doc": "<h1><code>++tuba</code></h1>\n<p>UTF8 to UTF32 tape</p>\n<p>Convert <code>++tape</code> to a <code>++list</code> of codepoints (<code>@c</code>).</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code> of codepoints <code>@c</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tuba                                                ::  utf8 to utf32 tape\n  |=  a/tape\n  ^-  (list @c)\n  (rip 5 (turf (rap 3 a)))                              ::  XX horrible\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (tuba \"\u044f \u0442\u0443\u0442\")\n~[~-~44f. ~-. ~-~442. ~-~443. ~-~442.]\n/&gt; (tuba \"chars\")\n~[~-c ~-h ~-a ~-r ~-s]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tufa"
        ],
        "doc": "<h1><code>++tufa</code></h1>\n<p>UTF32 to UTF8 tape</p>\n<p>Wrap a <code>++list</code> of utf32 codepoints into a utf8 <code>++tape</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++list</code> of <code>@c</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tufa                                                ::  utf32 to utf8 tape\n  |=  a=(list @c)\n  ^-  tape\n  ?~  a  \"\"\n  (weld (rip 3 (tuft i.a)) $(a t.a))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (tufa ~[~-~44f. ~-. ~-~442. ~-~443. ~-~442.])\n\"\u044f \u0442\u0443\u0442\"\n/&gt; (tufa ((list @c) ~[%a %b 0xb1 %c]))\n\"ab\u00b1c\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tuft"
        ],
        "doc": "<h1><code>++tuft</code></h1>\n<p>UTF32 to UTF8 text</p>\n<p>Convert utf32 glyph to\nLSB utf8 <code>++cord</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a codepoint (<code>@c</code>).</p>\n<h2>Produces</h2>\n<p>A <code>++cord</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tuft                                                ::  utf32 to utf8 text\n  |=  a/@c\n  ^-  @t\n  %+  rap  3\n  |-  ^-  (list @)\n  ?:  =(`@`0 a)\n    ~\n  =+  b=(end 5 1 a)\n  =+  c=$(a (rsh 5 1 a))\n  ?:  (lte b 0x7f)\n    [b c]\n  ?:  (lte b 0x7ff)\n    :*  (mix 0b1100.0000 (cut 0 [6 5] b))\n        (mix 0b1000.0000 (end 0 6 b))\n        c\n    ==\n  ?:  (lte b 0xffff)\n    :*  (mix 0b1110.0000 (cut 0 [12 4] b))\n        (mix 0b1000.0000 (cut 0 [6 6] b))\n        (mix 0b1000.0000 (end 0 6 b))\n        c\n    ==\n  :*  (mix 0b1111.0000 (cut 0 [18 3] b))\n      (mix 0b1000.0000 (cut 0 [12 6] b))\n      (mix 0b1000.0000 (cut 0 [6 6] b))\n      (mix 0b1000.0000 (end 0 6 b))\n      c\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (tuft `@c`%a)\n'a'\n/&gt; (tuft `@c`0xb6)\n'\u00b6'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "turf"
        ],
        "doc": "<h1><code>++turf</code></h1>\n<p>UTF8 to UTF32 cord</p>\n<p>Convert utf8 (<code>++cord</code>) to utf32 codepoints.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>@t</code>.</p>\n<h2>Produces</h2>\n<p>A <code>@c</code>, UTF-32 codepoint.</p>\n<h2>Source</h2>\n<pre><code>++  turf                                                ::  utf8 to utf32\n  |=  a/@t\n  ^-  @c\n  %+  rap  5\n  |-  ^-  (list @c)\n  =+  b=(teff a)\n  ?:  =(0 b)  ~\n  =+  ^=  c\n      %+  can  0\n      %+  turn\n        ^-  (list {p/@ q/@})\n        ?+  b  !!\n          $1  [[0 7] ~]\n          $2  [[8 6] [0 5] ~]\n          $3  [[16 6] [8 6] [0 4] ~]\n          $4  [[24 6] [16 6] [8 6] [0 3] ~]\n        ==\n      |=({p/@ q/@} [q (cut 0 [p q] a)])\n  ?.  =((tuft c) (end 3 b a))  ~|(%bad-utf8 !!)\n  [c $(a (rsh 3 b a))]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (turf 'my \u00dfam')\n~-my.~df.am\n/&gt; '\u044f \u0442\u0443\u0442'\n'\u044f \u0442\u0443\u0442'\n/&gt; (turf '\u044f \u0442\u0443\u0442')\n~-~44f..~442.~443.~442.\n/&gt; `@ux`'\u044f \u0442\u0443\u0442'\n0x82.d183.d182.d120.8fd1\n/&gt; `@ux`(turf '\u044f \u0442\u0443\u0442')\n0x442.0000.0443.0000.0442.0000.0020.0000.044f\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wack"
        ],
        "doc": "<h1><code>++wack</code></h1>\n<p>Coin format encode</p>\n<p>Escape <code>++span</code> <code>~</code> as <code>~~</code> and <code>_</code> as <code>~-</code>. Used for printing.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++span</code> (<code>@ta</code>).</p>\n<h2>Produces</h2>\n<p>A <code>++span</code> (<code>@ta</code>).</p>\n<h2>Source</h2>\n<pre><code>++  wack                                                ::  coin format\n  |=  a/@ta\n  ^-  @ta\n  =+  b=(rip 3 a)\n  %+  rap  3\n  |-  ^-  tape\n  ?~  b\n    ~\n  ?:  =('~' i.b)  ['~' '~' $(b t.b)]\n  ?:  =('_' i.b)  ['~' '-' $(b t.b)]\n  [i.b $(b t.b)]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (wack '~20_sam~')\n~.~~20~-sam~~\n/&gt; `@t`(wack '~20_sam~')\n'~~20~-sam~~'\n&gt; ~(rend co %many ~[`ud/5 `ta/'~20_sam'])\n\"._5_~~.~~20~-sam__\"\n&gt; ._5_~~.~~20~-sam__\n[5 ~.~20_sam]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wick"
        ],
        "doc": "<h1><code>++wick</code></h1>\n<p>Coin format decode</p>\n<p>Unescape <code>++span</code> <code>~~</code> as <code>~</code> and <code>~-</code> as <code>_</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a an atom.</p>\n<h2>Produces</h2>\n<p>A <code>++span</code> <code>@ta</code>.</p>\n<h2>Source</h2>\n<pre><code>++  wick                                                ::  knot format\n  |=  a/@\n  ^-  (unit @ta)\n  =+  b=(rip 3 a)\n  =-  ?^(b ~ (some (rap 3 (flop c))))\n  =|  c/tape\n  |-  ^-  {b/tape c/tape}\n  ?~  b  [~ c]\n  ?.  =('~' i.b)\n    $(b t.b, c [i.b c])\n  ?~  t.b  [b ~]\n  ?-  i.t.b\n    $'~'  $(b t.t.b, c ['~' c])\n    $'-'  $(b t.t.b, c ['_' c])\n    @     [b ~]\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; `@t`(wick '~-ams~~lop')\n'_ams~lop'\n/&gt; `@t`(wick (wack '~20_sam~'))\n'~20_sam~'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "woad"
        ],
        "doc": "<h1><code>++woad</code></h1>\n<p>Unescape cord</p>\n<p>Unescape <code>++cord</code> codepoints.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>@ta</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++cord</code>.</p>\n<h2>Source</h2>\n<pre><code>++  woad                                                ::  cord format\n  |=  a/@ta\n  ^-  @t\n  %+  rap  3\n  |-  ^-  (list @)\n  ?:  =(`@`0 a)\n    ~\n  =+  b=(end 3 1 a)\n  =+  c=(rsh 3 1 a)\n  ?:  =('.' b)\n    [' ' $(a c)]\n  ?.  =('~' b)\n    [b $(a c)]\n  =&gt;  .(b (end 3 1 c), c (rsh 3 1 c))\n  ?+  b  =-  (weld (rip 3 (tuft p.d)) $(a q.d))\n         ^=  d\n         =+  d=0\n         |-  ^-  {p/@ q/@}\n         ?:  =('.' b)\n           [d c]\n         ?&lt;  =(0 c)\n         %=    $\n            b  (end 3 1 c)\n            c  (rsh 3 1 c)\n            d  %+  add  (mul 16 d)\n               %+  sub  b\n               ?:  &amp;((gte b '0') (lte b '9'))  48\n               ?&gt;(&amp;((gte b 'a') (lte b 'z')) 87)\n         ==\n    $'.'  ['.' $(a c)]\n    $'~'  ['~' $(a c)]\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (woad ~.~b6.20.as)\n'\u00b620 as'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wood"
        ],
        "doc": "<h1><code>++wood</code></h1>\n<p>Escape cord</p>\n<p>Escape <code>++cord</code> codepoints.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <code>++span</code> (<code>@ta</code>).</p>\n<h2>Produces</h2>\n<p>A <code>++span</code> (<code>@ta</code>).</p>\n<h2>Source</h2>\n<pre><code>++  wood                                                ::  cord format\n  |=  a/@t\n  ^-  @ta\n  %+  rap  3\n  |-  ^-  (list @)\n  ?:  =(`@`0 a)\n    ~\n  =+  b=(teff a)\n  =+  c=(turf (end 3 b a))\n  =+  d=$(a (rsh 3 b a))\n  ?:  ?|  &amp;((gte c 'a') (lte c 'z'))\n          &amp;((gte c '0') (lte c '9'))\n          =(`@`'-' c)\n      ==\n    [c d]\n  ?+  c\n    :-  '~'\n    =+  e=(met 2 c)\n    |-  ^-  tape\n    ?:  =(0 e)\n      ['.' d]\n    =.  e  (dec e)\n    =+  f=(rsh 2 e c)\n    [(add ?:((lte f 9) 48 87) f) $(c (end 2 e c))]\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (wood 'my \u00dfam')\n~.my.~df.am\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "re"
        ],
        "doc": "<h1><code>++re</code></h1>\n<p>Pretty-printing engine</p>\n<p>Pretty-printing engine that accepts a <code>++tank</code> sample and contains arms that perform computation on it.</p>\n<h2>Accepts</h2>\n<p><code>tac</code> is a <code>++tank</code>.</p>\n<h2>Produces</h2>\n<pre><code>++  re\n  |_  tac/tank\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; ~(. re leaf+\"ham\")\n&lt;2.gdc {tac/{$leaf \"\"} &lt;402.arm 110.jyx 1.ztu $151&gt;}&gt;\n</code></pre>\n"
    },
    {
        "keys": [
            "ram"
        ],
        "doc": "<h1><code>++ram</code></h1>\n<p>Flatten to tape</p>\n<p>Flatten <code>++tank</code> out into a <code>++tape</code>.</p>\n<h2>Accepts</h2>\n<p><code>tac</code> is a <code>++tank</code>, taken from sample of <code>++re</code> core.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  ram\n    ^-  tape\n    ?-    -.tac\n        $leaf  p.tac\n        $palm  ram(tac [%rose [p.p.tac (weld q.p.tac r.p.tac) s.p.tac] q.tac])\n        $rose\n      %+  weld\n        q.p.tac\n      |-  ^-  tape\n      ?~  q.tac\n        r.p.tac\n      =+  voz=$(q.tac t.q.tac)\n      (weld ram(tac i.q.tac) ?~(t.q.tac voz (weld p.p.tac voz)))\n    ==\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; ~(ram re leaf+\"foo\")\n\"foo\"\n/&gt; ~(ram re rose+[\".\" \"(\" \")\"]^~[leaf+\"bar\" leaf+\"baz\" leaf+\"bam\"])\n\"(bar.baz.bam)\"\n</code></pre>\n"
    },
    {
        "keys": [
            "win"
        ],
        "doc": "<h1><code>++win</code></h1>\n<p>Render at indent</p>\n<p>Render at indent level <code>tab</code> and width <code>edg</code>.</p>\n<h2>Accepts</h2>\n<p><code>tac</code> is a <code>++tank</code>, taken from sample of <code>++re</code> core.</p>\n<p><code>tab</code> and <code>edg</code> are atoms.</p>\n<h2>Produces</h2>\n<p>A <code>++wall</code> (<code>++list</code> of <code>++tapes</code>).</p>\n<h2>Source</h2>\n<pre><code>  ++  win\n    |=  {tab/@ edg/@}\n    =+  lug=`wall`~\n    |^  |-  ^-  wall\n        ?-    -.tac\n            $leaf  (rig p.tac)\n            $palm\n          ?:  fit\n            (rig ram)\n          ?~  q.tac\n            (rig q.p.tac)\n          ?~  t.q.tac\n            (rig(tab (add 2 tab), lug $(tac i.q.tac)) q.p.tac)\n          =&gt;  .(q.tac `(list tank)`q.tac)\n          =+  lyn=(mul 2 (lent q.tac))\n          =+  ^=  qyr\n              |-  ^-  wall\n              ?~  q.tac\n                lug\n              %=  ^$\n                tac  i.q.tac\n                tab  (add tab (sub lyn 2))\n                lug  $(q.tac t.q.tac, lyn (sub lyn 2))\n              ==\n          (wig(lug qyr) q.p.tac)\n        ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; (~(win re leaf+\"samoltekon-lapdok\") 0 20)\n&lt;&lt;\"samoltekon-lapdok\"&gt;&gt;\n/&gt; (~(win re leaf+\"samoltekon-lapdok\") 0 10)\n&lt;&lt;\"\\/samolt\\/\" \"  ekon-l\" \"  apdok\" \"\\/      \\/\"&gt;&gt;\n/&gt; (~(win re rose+[\"--\" \"[\" \"]\"]^~[leaf+\"1423\" leaf+\"2316\"]) 0 20)\n&lt;&lt;\"[1423--2316]\"&gt;&gt;\n/&gt; (~(win re rose+[\"--\" \"[\" \"]\"]^~[leaf+\"1423\" leaf+\"2316\"]) 0 10)\n&lt;&lt;\"[ 1423\" \"  2316\" \"]\"&gt;&gt;\n</code></pre>\n"
    },
    {
        "keys": [
            "din"
        ],
        "doc": "<h1><code>++din</code></h1>\n<p>XX document</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>    ++  din  (mod (add 2 tab) (mul 2 (div edg 3)))\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fit"
        ],
        "doc": "<h1><code>++fit</code></h1>\n<p>Fit on one line test</p>\n<p>Determine whether <code>tac</code> fits on one line. Internal to <code>++win</code></p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<p>++  fit  (lte (lent ram) (sub edg tab))</p>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "rig"
        ],
        "doc": "<h1><code>++rig</code></h1>\n<p>Wrap in <code>\\/</code></p>\n<p>Wrap <code>++tape</code> in <code>\\/</code> if it doesn't fit at current indentation. Internal to\n<code>++win</code></p>\n<h2>Accepts</h2>\n<p><code>tac</code> is a <code>++tank</code>, taken from sample of <code>++re</code> core.</p>\n<p><code>hom</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++wall</code> (list of <code>++tape</code>s).</p>\n<h2>Source</h2>\n<pre><code>    ++  rig\n      |=  hom/tape\n      ^-  wall\n      ?:  &amp; ::(lte (lent hom) (sub edg tab))\n        [(runt [tab ' '] hom) lug]\n      =&gt;  .(tab (add tab 2), edg (sub edg 2))\n      =+  mut=(trim (sub edg tab) hom)\n      :-  (runt [(sub tab 2) ' '] ['\\\\' '/' (weld p.mut `_hom`['\\\\' '/' ~])])\n      =&gt;  .(hom q.mut)\n      |-\n      ?~  hom\n        :-  %+  runt\n              [(sub tab 2) ' ']\n            ['\\\\' '/' (runt [(sub edg tab) ' '] ['\\\\' '/' ~])]\n        lug\n      =&gt;  .(mut (trim (sub edg tab) hom))\n      [(runt [tab ' '] p.mut) $(hom q.mut)]\n    ::\n</code></pre>\n<h2>Examples</h2>\n"
    },
    {
        "keys": [
            "wig"
        ],
        "doc": "<h1><code>++wig</code></h1>\n<p><code>++win</code> render tape</p>\n<p>Render <code>++tape</code>. Internal to <code>++win</code>.</p>\n<h2>Accepts</h2>\n<p><code>tac</code> is a <code>++tank</code>, taken from sample of <code>++re</code> core.</p>\n<p><code>hom</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<pre><code>    ++  wig\n      |=  hom/tape\n      ^-  wall\n      ?~  lug\n        (rig hom)\n      =+  lin=(lent hom)\n      =+  wug=:(add 1 tab lin)\n      ?.  =+  mir=i.lug\n          |-  ?~  mir\n                |\n              ?|(=(0 wug) ?&amp;(=(' ' i.mir) $(mir t.mir, wug (dec wug))))\n        (rig hom)       :: ^ XX regular form?\n      [(runt [tab ' '] (weld hom `tape`[' ' (slag wug i.lug)])) t.lug]\n    --\n  --\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "show"
        ],
        "doc": "<h1><code>++show</code></h1>\n<pre><code>++  show                            ::  XX deprecated, use span\n  |=  vem/*\n  |^  ^-  tank\n      ?:  ?=(@ vem)\n        [%leaf (mesc (trip vem))]\n      ?-    vem\n          {s/$~ c/*}\n        [%leaf '\\'' (weld (mesc (tape +.vem)) `tape`['\\'' ~])]\n      ::\n          {s/$a c/@}        [%leaf (mesc (trip c.vem))]\n          {s/$b c/*}        (shop c.vem |=(a/@ ~(rub at a)))\n          {s/{$c p/@} c/*}\n        :+  %palm\n          [['.' ~] ['-' ~] ~ ~]\n        [[%leaf (mesc (trip p.s.vem))] $(vem c.vem) ~]\n      ::\n          {s/$d c/*}        (shop c.vem |=(a/@ ~(rud at a)))\n          {s/$k c/*}        (tank c.vem)\n          {s/$h c/*}\n        :+  %rose\n          [['/' ~] ['/' ~] ~]\n        =+  yol=((list @ta) c.vem)\n        (turn yol |=(a/@ta [%leaf (trip a)]))\n      ::\n          {s/$l c/*}        (shol c.vem)\n          {s/$o c/*}\n        %=    $\n            vem\n          :-  [%m '%h:&lt;[%d %d].[%d %d]&gt;']\n          [-.c.vem +&lt;-.c.vem +&lt;+.c.vem +&gt;-.c.vem +&gt;+.c.vem ~]\n        ==\n      ::\n          {s/$p c/*}        (shop c.vem |=(a/@ ~(rup at a)))\n          {s/$q c/*}        (shop c.vem |=(a/@ ~(r at a)))\n          {s/$r c/*}        $(vem [[%r ' ' '{' '}'] c.vem])\n          {s/$t c/*}        (shop c.vem |=(a/@ ~(rt at a)))\n          {s/$v c/*}        (shop c.vem |=(a/@ ~(ruv at a)))\n          {s/$x c/*}        (shop c.vem |=(a/@ ~(rux at a)))\n          {s/{$m p/@} c/*}  (shep p.s.vem c.vem)\n          {s/{$r p/@} c/*}\n        $(vem [[%r ' ' (cut 3 [0 1] p.s.vem) (cut 3 [1 1] p.s.vem)] c.vem])\n      ::\n          {s/{$r p/@ q/@ r/@} c/*}\n        :+  %rose\n          :*  p=(mesc (trip p.s.vem))\n              q=(mesc (trip q.s.vem))\n              r=(mesc (trip r.s.vem))\n          ==\n        |-  ^-  (list tank)\n        ?@  c.vem\n          ~\n        [^$(vem -.c.vem) $(c.vem +.c.vem)]\n      ::\n          {s/$z c/*}        $(vem [[%r %$ %$ %$] c.vem])\n          *                 !!\n      ==\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "shep"
        ],
        "doc": "<h1><code>++shep</code></h1>\n<pre><code>  ++  shep\n    |=  {fom/@ gar/*}\n    ^-  tank\n    =+  l=(met 3 fom)\n    =+  i=0\n    :-  %leaf\n    |-  ^-  tape\n    ?:  (gte i l)\n      ~\n    =+  c=(cut 3 [i 1] fom)\n    ?.  =(37 c)\n      (weld (mesc [c ~]) $(i +(i)))\n    =+  d=(cut 3 [+(i) 1] fom)\n    ?.  .?(gar)\n      ['\\\\' '#' $(i (add 2 i))]\n    (weld ~(ram re (show d -.gar)) $(i (add 2 i), gar +.gar))\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "shop"
        ],
        "doc": "<h1><code>++shop</code></h1>\n<pre><code> ++  shop\n    |=  {aug/* vel/$-(a/@ tape)}\n    ^-  tank\n    ?:  ?=(@ aug)\n      [%leaf (vel aug)]\n    :+  %rose\n      [[' ' ~] ['[' ~] [']' ~]]\n    =&gt;  .(aug `*`aug)\n    |-  ^-  (list tank)\n    ?:  ?=(@ aug)\n      [^$ ~]\n    [^$(aug -.aug) $(aug +.aug)]\n  ::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "last"
        ],
        "doc": "<h1><code>++last</code></h1>\n<p>Farther trace</p>\n<p>Compares two line-column pairs, called <code>++hair</code>s, <code>zyc</code> and <code>naz</code>, producing whichever\nis further along.</p>\n<h2>Accepts</h2>\n<p><code>naz</code> is a hair.</p>\n<p><code>zyc</code> is a hair.</p>\n<h2>Produces</h2>\n<p>a <code>++hair</code>.</p>\n<h2>Source</h2>\n<pre><code>++  last  |=  {zyc/hair naz/hair}                       ::  farther trace\n          ^-  hair\n          ?:  =(p.zyc p.naz)\n            ?:((gth q.zyc q.naz) zyc naz)\n          ?:((gth p.zyc p.naz) zyc naz)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (last [1 1] [1 2])\n[p=1 q=2]\n&gt; (last [2 1] [1 2])\n[p=2 q=1]\n&gt; (last [0 0] [99 0])\n[p=99 q=0]\n&gt; (last [7 7] [7 7])\n[p=7 q=7]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lust"
        ],
        "doc": "<h1><code>++lust</code></h1>\n<p>Detect newline</p>\n<p>Advances the <code>++hair</code> <code>naz</code> by a row if the <code>++char</code> <code>weq</code> is a newline, or by a\ncolumn if <code>weq</code> is any other character.</p>\n<h2>Accepts</h2>\n<p><code>weq</code> is a char.</p>\n<p><code>naz</code> is a hair.</p>\n<h2>Produces</h2>\n<p>A hair.</p>\n<h2>Source</h2>\n<pre><code>++  lust  |=  {weq/char naz/hair}                       ::  detect newline\n          ^-  hair\n          ?:(=(`@`10 weq) [+(p.naz) 1] [p.naz +(q.naz)])\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (lust `a` [1 1])\n[p=1 q=2]\n&gt; (lust `@t`10 [1 1])\n[p=2 q=1]\n&gt; (lust '9' [10 10])\n[p=10 q=11]\n/&gt; (roll \"maze\" [.(+&lt;+ [1 1])]:lust)\n[1 5]\n/&gt; %-  roll  :_  [.(+&lt;+ [1 1])]:lust\n\"\"\"\nSam\nlokes\n\"\"\"\n[2 6]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bend"
        ],
        "doc": "<h1><code>++bend</code></h1>\n<p>Conditional composer</p>\n<p>Parsing composer: connects the <code>++edge</code> <code>vex</code> with the subsequent <code>++rule</code> <code>sab</code>\nas an optional suffix, using gate <code>raq</code> to compose or reject its\nresult. If there is no suffix, or if the suffix fails to be composed\nwith the current result, the current result is produced. Used to map a\ngroup of rules to a specified output.</p>\n<h2>Accepts</h2>\n<p><code>raq</code> is a gate.</p>\n<p><code>sab</code> is a rule.</p>\n<p><code>vex</code> is an edge.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  bend                                                ::  conditional comp\n  ~/  %bend\n  |*  raq/_|*({a/* b/*} [~ u=[a b]])\n  ~/  %fun\n  |*  {vex/edge sab/rule}\n  ?~  q.vex\n    vex\n  =+  yit=(sab q.u.q.vex)\n  =+  yur=(last p.vex p.yit)\n  ?~  q.yit\n    [p=yur q=q.vex]\n  =+  vux=(raq p.u.q.vex p.u.q.yit)\n  ?~  vux\n    [p=yur q=q.vex]\n  [p=yur q=[~ u=[p=u.vux q=q.u.q.yit]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (;~((bend |=([a/char b/char] ?.(=(a b) ~ (some +(a))))) prn prn) [1 1] \"qs\")\n[p=[p=1 q=3] q=[~ u=[p=~~q q=[p=[p=1 q=2] q=\"s\"]]]]\n&gt; (;~((bend |=([a/char b/char] ?.(=(a b) ~ (some +(a))))) prn prn) [1 1] \"qqq\")\n[p=[p=1 q=3] q=[~ u=[p=~~r q=[p=[p=1 q=3] q=\"q\"]]]]\n&gt; (scan \"aa\" ;~((bend |=([a/char b/char] ?.(=(a b) ~ (some +(a))))) prn prn))\n~~b\n&gt; (scan \"ba\" ;~((bend |=([a/char b/char] ?.(=(a b) ~ (some +(a))))) prn prn))\n! {1 3}\n! exit\n&gt; `(unit @tas)`(scan \"\" ;~((bend) (easy ~) sym))\n~\n&gt; `(unit @tas)`(scan \"sep\" ;~((bend) (easy ~) sym))\n[~ %sep]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "comp"
        ],
        "doc": "<h1><code>++comp</code></h1>\n<p>Arbitrary compose</p>\n<p>Parsing composer: connects the <code>++edge</code> <code>vex</code> with a following <code>++rule</code> <code>sab</code>,\ncombining the contents of <code>vex</code> with the result of <code>sab</code> using a binary\ngate <code>raq</code>. Used to fold over the results of several <code>++rules</code>.</p>\n<h2>Accepts</h2>\n<p><code>raq</code> is a gate that accepts a cell of two nouns, <code>a</code> and <code>b</code>, and\nproduces a cell of two nouns.</p>\n<p><code>sab</code> is a rule.</p>\n<p><code>vex</code> is an edge.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  comp\n  ~/  %comp\n  |*  raq/_|*({a/* b/*} [a b])                       ::  arbitrary compose\n  ~/  %fun\n  |*  {vex/edge sab/rule}\n  ~!  +&lt;\n  ?~  q.vex\n    vex\n  =+  yit=(sab q.u.q.vex)\n  =+  yur=(last p.vex p.yit)\n  ?~  q.yit\n    [p=yur q=q.yit]\n  [p=yur q=[~ u=[p=(raq p.u.q.vex p.u.q.yit) q=q.u.q.yit]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"123\" ;~((comp |=([a/@u b/@u] (add a b))) dit dit dit))\n6\n&gt; (scan \"12\" ;~((comp |=([a/@u b/@u] (add a b))) dit dit dit))\n! {1 3}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fail"
        ],
        "doc": "<h1><code>++fail</code></h1>\n<p>Never parse</p>\n<p>Produces an <code>++edge</code> at the same text position (<code>++hair</code>) with a failing\nresult (<code>q=~</code>).</p>\n<h2>Accepts</h2>\n<p><code>tub</code> is a <code>++nail</code>.</p>\n<h2>Produces</h2>\n<p>An <code>++edge</code>.</p>\n<h2>Source</h2>\n<pre><code>++  fail  |=(tub/nail [p=p.tub q=~])                    ::  never parse\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (fail [[1 1] \"abc\"])\n[p=[p=1 q=1] q=~]\n&gt; (fail [[p=1.337 q=70] \"Parse me, please?\"])\n[p=[p=1.337 q=70] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "glue"
        ],
        "doc": "<h1><code>++glue</code></h1>\n<p>Skip delimiter</p>\n<p>Parsing composer: connects an <code>++edge</code> <code>vex</code> with a following <code>++rule</code> <code>sab</code> by\nparsing the <code>++rule</code> <code>bus</code> (the delimiting symbol) and throwing out the\nresult.</p>\n<h2>Accepts</h2>\n<p><code>bus</code> is a <code>++rule</code>.</p>\n<p><code>sab</code> is a <code>++rule</code>.</p>\n<p><code>vex</code> is an <code>++edge</code>.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  glue                                                ::  add rule\n  ~/  %glue\n  |*  bus/rule\n  ~/  %fun\n  |*  {vex/edge sab/rule}\n  (plug vex ;~(pfix bus sab))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"200|mal|bon\" ;~((glue bar) dem sym sym))\n[q=200 7.102.829 7.237.474]\n&gt; `[@u @tas @tas]`(scan \"200|mal|bon\" ;~((glue bar) dem sym sym))\n[200 %mal %bon]\n&gt;  (scan \"200|;|bon\" ;~((glue bar) dem sem sym))\n[q=200 ~~~3b. 7.237.474]\n&gt;  (scan \"200.;.bon\" ;~((glue dot) dem sem sym))\n[q=200 ~~~3b. 7.237.474]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "less"
        ],
        "doc": "<h1><code>++less</code></h1>\n<p>Parse unless</p>\n<p>Parsing composer: if an <code>++edge</code> <code>vex</code> reflects a success, fail. Otherwise,\nconnect <code>vex</code> with the following <code>++rule</code>.</p>\n<h2>Accepts</h2>\n<p><code>sab</code> is a <code>++rule</code>.</p>\n<p><code>vex</code> is an <code>++edge</code>.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  less                                                ::  no first and second\n  |*  {vex/edge sab/rule}\n  ?~  q.vex\n    =+  roq=(sab)\n    [p=(last p.vex p.roq) q=q.roq]\n  (fail +&lt;.sab)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"sas-/lo\" (star ;~(less lus bar prn)))\n\"sas-/lo\"\n&gt; (scan \"sas-/l+o\" (star ;~(less lus bar prn)))\n! {1 8}\n! exit\n&gt; (scan \"sas|-/lo\" (star ;~(less lus bar prn)))\n! {1 5}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pfix"
        ],
        "doc": "<h1><code>++pfix</code></h1>\n<p>Discard first rule</p>\n<p>Parsing composer: connects an <code>++edge</code> <code>vex</code> with two subsequent <code>++rule</code>s,\nignoring the result of the first and producing the result of the second.</p>\n<h2>Accepts</h2>\n<p><code>vex</code> is an edge.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pfix                                                ::  discard first rule\n  ~/  %pfix\n  (comp |*({a/* b/*} b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`(scan \"%him\" ;~(pfix cen sym))\n'him'\n&gt; (scan \"+++10\" ;~(pfix (star lus) dem))\nq=10\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "plug"
        ],
        "doc": "<h1><code>++plug</code></h1>\n<p>Parse to tuple</p>\n<p>Parsing composer: connects an <code>++edge</code> <code>vex</code> with a following <code>++rule</code> <code>sab</code>, producing\na cell of both the results. See also: the monad applicator ;~ for a\nmore detailed explanation.</p>\n<h2>Accepts</h2>\n<p><code>sab</code> is a <code>++rule</code>.</p>\n<p><code>vex</code> is an <code>++edge</code>.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  plug                                                ::  first then second\n  ~/  %plug\n  |*  {vex/edge sab/rule}\n  ?~  q.vex\n    vex\n  =+  yit=(sab q.u.q.vex)\n  =+  yur=(last p.vex p.yit)\n  ?~  q.yit\n    [p=yur q=q.yit]\n  [p=yur q=[~ u=[p=[p.u.q.vex p.u.q.yit] q=q.u.q.yit]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"1..20\" ;~(plug dem dot dot dem))\n[q=1 ~~~. ~~~. q=20]\n&gt; (scan \"moke/~2014.1.1\" ;~(plug sym fas nuck:so))\n[1.701.539.693 ~~~2f. [% p=[p=~.da q=170.141.184.500.766.106.671.844.917.172.921.958.400]]]\n&gt; ;;(,[@tas @t ~ %da @da] (scan \"moke/~2014.1.1\" ;~(plug sym fas nuck:so)))\n[%moke '/' ~ %da ~2014.1.1]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pose"
        ],
        "doc": "<h1><code>++pose</code></h1>\n<p>Parse options</p>\n<p>Parsing composer: if <code>vex</code> reflects a failure, connect it with the\nfollowing rule <code>sab</code>. See also: the monad applicator ;~</p>\n<h2>Accepts</h2>\n<p><code>sab</code> is a <code>++rule</code>.</p>\n<p><code>vex</code> is an <code>++edge</code>.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pose                                                ::  first or second\n  ~/  %pose\n  |*  {vex/edge sab/rule}\n  ?~  q.vex\n    =+  roq=(sab)\n    [p=(last p.vex p.roq) q=q.roq]\n  vex\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`(scan \"+\" ;~(pose lus tar cen))\n'+'\n&gt; `@t`(scan \"*\" ;~(pose lus tar cen))\n'*'\n&gt; `@t`(scan \"%\" ;~(pose lus tar cen))\n'%'\n&gt; `@t`(scan \"-\" ;~(pose lus tar cen))\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sfix"
        ],
        "doc": "<h1><code>++sfix</code></h1>\n<p>Discard second rule</p>\n<p>Parsing composer: connects <code>++edge</code>s <code>vex</code> with two subsequent <code>++rule</code>s returning the\nresult of the first and discarding the result of the second.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is the result of parsing the first <code>++rule</code>.</p>\n<p><code>b</code> is the result of of parsing the second <code>++rule</code>.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  sfix                                                ::  discard second rule\n  ~/  %sfix\n  (comp |*({a/* b/*} a))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`(scan \"him%\" ;~(sfix sym cen))\n'him'\n&gt; (scan \"10+++\" ;~(sfix dem (star lus)))\nq=10\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "simu"
        ],
        "doc": "<h1><code>++simu</code></h1>\n<p>First and second</p>\n<p>Parsing composer: if an <code>++edge</code> <code>vex</code> reflects a failure, fail. Otherwise,\nconnect <code>vex</code> with the following <code>++rule</code>.</p>\n<h2>Accepts</h2>\n<p><code>sab</code> is a <code>++rule</code>.</p>\n<p><code>vex</code> is an <code>++edge</code>.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  simu                                                ::  first and second\n  |*  {vex/edge sab/rule}\n  ?~  q.vex\n    vex\n  =+  roq=(sab)\n  roq\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"~zod\" scat:vast)\n[%dtzy p=%p q=0]\n&gt; (scan \"%zod\" scat:vast)\n[%dtzz p=%tas q=6.582.138]\n&gt; (scan \"%zod\" ;~(simu cen scat:vast))\n[%dtzz p=%tas q=6.582.138]\n&gt; (scan \"~zod\" ;~(simu cen scat:vast))\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bass"
        ],
        "doc": "<h1><code>++bass</code></h1>\n<p>Parser modifier: LSB\nordered <code>++list</code> as atom of a <code>++base</code>.</p>\n<h2>Accepts</h2>\n<p><code>wuc</code> is an atom.</p>\n<p><code>tyd</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  bass\n  |*  {wuc/@ tyd/rule}\n  %+  cook\n    |=  waq/(list @)\n    %+  roll\n      waq\n    =|({p/@ q/@} |.((add p (mul wuc q))))\n  tyd\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"123\" (bass 10 (star dit)))\nq=123\n&gt; (scan \"123\" (bass 8 (star dit)))\nq=83\n&gt; `@ub`(scan \"123\" (bass 8 (star dit)))\n0b101.0011\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "boss"
        ],
        "doc": "<h1><code>++boss</code></h1>\n<p>Parser modifier: LSB</p>\n<p>Ordered <code>++list</code> as atom of a <code>++base</code>.</p>\n<h2>Accepts</h2>\n<p><code>wuc</code> is an atom.</p>\n<p><code>tyd</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  boss\n  |*  {wuc/@ tyd/rule}\n  %+  cook\n    |=  waq/(list @)\n    %+  reel\n      waq\n    =|({p/@ q/@} |.((add p (mul wuc q))))\n  tyd\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"123\" (boss 10 (star dit)))\nq=321\n&gt; `@t`(scan \"bam\" (boss 256 (star alp)))\n'bam'\n&gt; `@ux`(scan \"bam\" (boss 256 (star alp)))\n0x6d.6162\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cold"
        ],
        "doc": "<h1><code>++cold</code></h1>\n<p>Replace with constant</p>\n<p>Parser modifier. Accepts a <code>++rule</code> <code>sef</code> and produces a parser that\nproduces a constant <code>cus</code>, assuming <code>sef</code> is successful.</p>\n<h2>Accepts</h2>\n<p><code>cus</code> is a constant noun.</p>\n<p><code>sef</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>An <code>++edge</code>.</p>\n<h2>Source</h2>\n<pre><code>++  cold                                                ::  replace w+ constant\n  ~/  %cold\n  |*  {cus/* sef/rule}\n  ~/  %fun\n  |=  tub/nail\n  =+  vex=(sef tub)\n  ?~  q.vex\n    vex\n  [p=p.vex q=[~ u=[p=cus q=q.u.q.vex]]]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; ((cold %foo (just 'a')) [[1 1] \"abc\"])\n    [p=[p=1 q=2] q=[~ u=[p=%foo q=[p=[p=1 q=2] q=\"bc\"]]]]\n    &gt; ((cold %foo (just 'a')) [[1 1] \"bc\"])\n    [p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cook"
        ],
        "doc": "<h1><code>++cook</code></h1>\n<p>Apply gate</p>\n<p>Parser modifier. Produces a parser that takes a (successful) result of a\n<code>++rule</code> <code>sef</code> and slams it through <code>poq</code>.</p>\n<h2>Accepts</h2>\n<p><code>poq</code> is a gate.</p>\n<p><code>sef</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>An <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  cook                                                ::  apply gate\n  ~/  %cook\n  |*  {poq/gate sef/rule}\n  ~/  %fun\n  |=  tub/nail\n  =+  vex=(sef tub)\n  ?~  q.vex\n    vex\n  [p=p.vex q=[~ u=[p=(poq p.u.q.vex) q=q.u.q.vex]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; ((cook ,@ud (just 'a')) [[1 1] \"abc\"])\n    [p=[p=1 q=2] q=[~ u=[p=97 q=[p=[p=1 q=2] q=\"bc\"]]]]\n    &gt; ((cook ,@tas (just 'a')) [[1 1] \"abc\"])\n    [p=[p=1 q=2] q=[~ u=[p=%a q=[p=[p=1 q=2] q=\"bc\"]]]]\n    &gt; ((cook |=(a=@ +(a)) (just 'a')) [[1 1] \"abc\"])\n    [p=[p=1 q=2] q=[~ u=[p=98 q=[p=[p=1 q=2] q=\"bc\"]]]]\n    &gt; ((cook |=(a=@ `@t`+(a)) (just 'a')) [[1 1] \"abc\"])\n    [p=[p=1 q=2] q=[~ u=[p='b' q=[p=[p=1 q=2] q=\"bc\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "easy"
        ],
        "doc": "<h1><code>++easy</code></h1>\n<p>Always parse</p>\n<p>Parser generator. Produces a parser that succeeds with given noun <code>huf</code>\nwithout consuming any text.</p>\n<h2>Accepts</h2>\n<p><code>huf</code> is a noun.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  easy                                                ::  always parse\n  ~/  %easy\n  |*  huf=*\n  ~/  %fun\n  |=  tub=nail\n  ^-  (like ,_huf)\n  [p=p.tub q=[~ u=[p=huf q=tub]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((easy %foo) [[1 1] \"abc\"])\n[p=[p=1 q=1] q=[~ [p=%foo q=[p=[p=1 q=1] q=\"abc\"]]]]\n&gt; ((easy %foo) [[1 1] \"bc\"])\n[p=[p=1 q=1] q=[~ [p=%foo q=[p=[p=1 q=1] q=\"bc\"]]]]\n&gt; ((easy 'a') [[1 1] \"bc\"])\n[p=[p=1 q=1] q=[~ [p='a' q=[p=[p=1 q=1] q=\"bc\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "full"
        ],
        "doc": "<h1><code>++full</code></h1>\n<p>Parse to end</p>\n<p>Parser modifier. Accepts a <code>++rule</code> <code>sef</code>, and produces a parser that succeeds only\nwhen the of <code>tub</code> is fully consumed using <code>sef</code>.</p>\n<h2>Accepts</h2>\n<p><code>sef</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  full                                                :: parse to end \n  |*  sef=_rule\n  |=  tub=nail\n  =+  vex=(sef tub)\n  ?~(q.vex vex ?:(=(~ q.q.u.q.vex) vex [p=p.vex q=~]))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((full (just 'a')) [[1 1] \"ab\"])\n[p=[p=1 q=2] q=~]\n&gt; ((full (jest 'ab')) [[1 1] \"ab\"])\n[p=[p=1 q=3] q=[~ u=[p='ab' q=[p=[p=1 q=3] q=\"\"]]]]\n&gt; ((full ;~(plug (just 'a') (just 'b'))) [[1 1] \"ab\"])\n[p=[p=1 q=3] q=[~ u=[p=[~~a ~~b] q=[p=[p=1 q=3] q=\"\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "funk"
        ],
        "doc": "<h1><code>++funk</code></h1>\n<p>Add to tape</p>\n<p>Parser modifier: prepend text to <code>++tape</code> before applying parser.</p>\n<h2>Accepts</h2>\n<p><code>pre</code> is a <code>++tape</code></p>\n<p><code>sef</code> is a <code>++rule</code></p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  funk                                                ::  add to tape first\n  |*  {pre/tape sef/rule}\n  |=  tub/nail\n  (sef p.tub (weld pre q.tub))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((funk \"abc prefix-\" (jest 'abc')) [[1 1] \"to be parsed\"])\n[p=[p=1 q=4] q=[~ [p='abc' q=[p=[p=1 q=4] q=\" prefix-to be parsed\"]]]]\n&gt; ((funk \"parse\" (just 'a')) [[1 4] \" me\"])\n[p=[p=1 q=4] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "here"
        ],
        "doc": "<h1><code>++here</code></h1>\n<p>Place-based apply</p>\n<p>Parser modifier. Similar to <code>++cook</code> in that it produces a parser that takes a\n(successful) result of <code>sef</code> and slams it through <code>hez</code>. <code>hez</code> accepts a\n<code>++pint</code> <code>a</code> and a noun <code>b</code>, which is what the parser parsed.</p>\n<h2>Accepts</h2>\n<p><code>hez</code> is a gate.</p>\n<p><code>sef</code> is a <code>++rule</code></p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  here                                                ::  place-based apply\n  ~/  %here\n  |*  {hez/_|=({a/pint b/*} [a b]) sef/rule}\n  ~/  %fun\n  |=  tub/nail\n  =+  vex=(sef tub)\n  ?~  q.vex\n    vex\n  [p=p.vex q=[~ u=[p=(hez [p.tub p.q.u.q.vex] p.u.q.vex) q=q.u.q.vex]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"abc\" (star alf))\n\"abc\"\n&gt; (scan \"abc\" (here |*(^ +&lt;) (star alf)))\n[[[p=1 q=1] p=1 q=4] \"abc\"]\n&gt; (scan \"abc\" (star (here |*(^ +&lt;) alf)))\n~[[[[p=1 q=1] p=1 q=2] ~~a] [[[p=1 q=2] p=1 q=3] ~~b] [[[p=1 q=3] p=1 q=4] ~~c]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ifix"
        ],
        "doc": "<h1><code>++ifix</code></h1>\n<p>Infix</p>\n<p>Parser modifier: surround with pair of <code>++rule</code>s, the output of which is\ndiscarded.</p>\n<h2>Accepts</h2>\n<p><code>fel</code> is a pair of <code>++rule</code>s.</p>\n<p><code>hof</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  ifix\n  |*  {fel/{rule rule} hof/rule}\n  ~!  +&lt;\n  ~!  +&lt;:-.fel\n  ~!  +&lt;:+.fel\n  ;~(pfix -.fel ;~(sfix hof +.fel))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"-40-\" (ifix [hep hep] dem))\nq=40\n&gt; (scan \"4my4\" (ifix [dit dit] (star alf)))\n\"my\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "jest"
        ],
        "doc": "<h1><code>++jest</code></h1>\n<p>Match a cord</p>\n<p>Match and consume a cord.</p>\n<h2>Accepts</h2>\n<p><code>daf</code> is a <code>@t</code>.</p>\n<h2>Produces</h2>\n<p>An <code>++edge</code>.</p>\n<h2>Source</h2>\n<pre><code>++  jest                                                ::  match a cord\n  |=  daf/@t\n  |=  tub/nail\n  =+  fad=daf\n  |-  ^-  (like @t)\n  ?:  =(`@`0 daf)\n    [p=p.tub q=[~ u=[p=fad q=tub]]]\n  ?:  |(?=($~ q.tub) !=((end 3 1 daf) i.q.tub))\n    (fail tub)\n  $(p.tub (lust i.q.tub p.tub), q.tub t.q.tub, daf (rsh 3 1 daf))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((jest 'abc') [[1 1] \"abc\"])\n[p=[p=1 q=4] q=[~ [p='abc' q=[p=[p=1 q=4] q=\"\"]]]]\n&gt; (scan \"abc\" (jest 'abc'))\n'abc'\n&gt; (scan \"abc\" (jest 'acb'))\n! {1 2}\n! 'syntax-error'\n! exit\n&gt; ((jest 'john doe') [[1 1] \"john smith\"])\n[p=[p=1 q=6] q=~]\n&gt; ((jest 'john doe') [[1 1] \"john doe\"])\n[p=[p=1 q=9] q=[~ [p='john doe' q=[p=[p=1 q=9] q=\"\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "just"
        ],
        "doc": "<h1><code>++just</code></h1>\n<p>Match a char</p>\n<p>Match and consume a single character.</p>\n<h2>Accepts</h2>\n<p><code>daf</code> is a <code>++char</code></p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  just                                                ::  XX redundant, jest\n  ~/  %just                                             ::  match a char\n  |=  daf/char\n  ~/  %fun\n  |=  tub/nail\n  ^-  (like char)\n  ?~  q.tub\n    (fail tub)\n  ?.  =(daf i.q.tub)\n    (fail tub)\n  (next tub)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((just 'a') [[1 1] \"abc\"])\n[p=[p=1 q=2] q=[~ [p=~~a q=[p=[p=1 q=2] q=\"bc\"]]]]\n&gt; (scan \"abc\" (just 'a'))\n! {1 2}\n! 'syntax-error'\n! exit\n&gt; (scan \"a\" (just 'a'))\n~~a\n&gt; (scan \"%\" (just '%'))\n~~~25.\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "knee"
        ],
        "doc": "<h1><code>++knee</code></h1>\n<p>Recursive parsers</p>\n<p>Used for recursive parsers, which would otherwise be infinite when\ncompiled.</p>\n<h2>Accepts</h2>\n<p><code>gar</code> is a noun.</p>\n<p><code>sef</code> is a gate that accepts a <code>++rule</code></p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  knee                                                ::  callbacks\n  |*  {gar/* sef/_|.(*rule)}\n  |=  tub/nail\n  ^-  (like _gar)\n  ((sef) tub)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; |-(;~(plug prn ;~(pose $ (easy ~))))\n! rest-loop\n! exit\n&gt; |-(;~(plug prn ;~(pose (knee *tape |.(^$)) (easy ~))))\n&lt; 1.obo\n  [ c=c=tub=[p=[p=@ud q=@ud] q=\"\"]\n      b\n    &lt; 1.bes\n      [ c=tub=[p=[p=@ud q=@ud] q=\"\"]\n        b=&lt;1.tnv [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.ktu [daf=@tD &lt;414.fvk 101.jzo 1.ypj %164&gt;]&gt;]&gt;\n        a=&lt;1.fvg [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.khu [[les=@ mos=@] &lt;414.fvk 101.jzo 1.ypj %164&gt;]&gt;]&gt;\n        v=&lt;414.fvk 101.jzo 1.ypj %164&gt;\n      ]\n    &gt;\n      a\n    ... 450 lines omitted ...\n  ]\n&gt;\n&gt; (scan \"abcd\" |-(;~(plug prn ;~(pose (knee *tape |.(^$)) (easy ~)))))\n[~~a \"bcd\"]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mask"
        ],
        "doc": "<h1><code>++mask</code></h1>\n<p>Match char</p>\n<p>Parser generator. Matches the next character if it is in a list of\ncharacters.</p>\n<h2>Accepts</h2>\n<p><code>bud</code> is a list of <code>++char</code></p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  mask                                                ::  match char in set\n  ~/  %mask\n  |=  bud/(list char)\n  ~/  %fun\n  |=  tub/nail\n  ^-  (like char)\n  ?~  q.tub\n    (fail tub)\n  ?.  (lien bud |=(a/char =(i.q.tub a)))\n    (fail tub)\n  (next tub)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"a\" (mask \"cba\"))\n~~a\n&gt; ((mask \"abc\") [[1 1] \"abc\"])\n[p=[p=1 q=2] q=[~ [p=~~a q=[p=[p=1 q=2] q=\"bc\"]]]]\n&gt; ((mask \"abc\") [[1 1] \"bbc\"])\n[p=[p=1 q=2] q=[~ [p=~~b q=[p=[p=1 q=2] q=\"bc\"]]]]\n&gt; ((mask \"abc\") [[1 1] \"dbc\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "more"
        ],
        "doc": "<h1><code>++more</code></h1>\n<p>Parse list with delimiter</p>\n<p>Parser modifier: Parse a list of matches using a delimiter <code>++rule</code>.</p>\n<h2>Accepts</h2>\n<p><code>bus</code> is a <code>++rule</code>.</p>\n<p><code>fel</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  more\n  |*  {bus/rule fel/rule}\n  ;~(pose (most bus fel) (easy ~))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"\" (more ace dem))\n~\n&gt; (scan \"40 20\" (more ace dem))\n[q=40 ~[q=20]]\n&gt; (scan \"40 20 60 1 5\" (more ace dem))\n[q=40 ~[q=20 q=60 q=1 q=5]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "most"
        ],
        "doc": "<h1><code>++most</code></h1>\n<p>Parse list of at least one match</p>\n<p>Parser modifier: parse a <code>++list</code> of at least one match using a delimiter <code>++rule</code>.</p>\n<h2>Accepts</h2>\n<p><code>bus</code> is a <code>++rule</code>.</p>\n<p><code>fel</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  most\n  |*  {bus/rule fel/rule}\n  ;~(plug fel (star ;~(pfix bus fel)))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"40 20\" (most ace dem))\n[q=40 ~[q=20]]\n&gt; (scan \"40 20 60 1 5\" (most ace dem))\n[q=40 ~[q=20 q=60 q=1 q=5]]\n&gt; (scan \"\" (most ace dem))\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "next"
        ],
        "doc": "<h1><code>++next</code></h1>\n<p>Consume char</p>\n<p>Consume any character, producing it as a result.</p>\n<h2>Accepts</h2>\n<p><code>tub</code> is a <code>++nail</code></p>\n<h2>Produces</h2>\n<p>An <code>++edge</code>.</p>\n<h2>Source</h2>\n<pre><code>++  next                                                ::  consume a char\n  |=  tub/nail\n  ^-  (like char)\n  ?~  q.tub\n    (fail tub)\n  =+  zac=(lust i.q.tub p.tub)\n  [zac [~ i.q.tub [zac t.q.tub]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (next [[1 1] \"ebc\"])\n[p=[p=1 q=2] q=[~ [p=~~e q=[p=[p=1 q=2] q=\"bc\"]]]] \n&gt; (next [[1 1] \"john jumps jones\"])\n[p=[p=1 q=2] q=[~ [p=~~j q=[p=[p=1 q=2] q=\"ohn jumps jones\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "plus"
        ],
        "doc": "<h1><code>++plus</code></h1>\n<p>List of at least one match.</p>\n<p>Parser modifier: parse <code>++list</code> of at least one match.</p>\n<h2>Accepts</h2>\n<p><code>fel</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  plus  |*(fel/rule ;~(plug fel (star fel)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"&gt;&gt;&gt;&gt;\" (cook lent (plus gar)))\n4\n&gt; (scan \"-  - \" (plus ;~(pose ace hep)))\n[~~- \"  - \"]\n&gt; `tape`(scan \"-  - \" (plus ;~(pose ace hep)))\n\"-  - \"\n&gt; `(pole ,@t)`(scan \"-  - \" (plus ;~(pose ace hep)))\n['-' [' ' [' ' ['-' [' ' ~]]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sear"
        ],
        "doc": "<h1><code>++sear</code></h1>\n<p>Conditional <code>++cook</code></p>\n<p>Conditional <code>++cook</code>. Slams the result through a gate that produces\na unit; if that unit is empty, fail.</p>\n<h2>Accepts</h2>\n<p><code>tub</code> is a <code>++nail</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  sear                                                ::  conditional cook\n  |*  {pyq/$-(* (unit)) sef/rule}\n  |=  tub/nail\n  =+  vex=(sef tub)\n  ?~  q.vex\n    vex\n  =+  gey=(pyq p.u.q.vex)\n  ?~  gey\n    [p=p.vex q=~]\n  [p=p.vex q=[~ u=[p=u.gey q=q.u.q.vex]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((sear |=(a/* ?@(a (some a) ~)) (just `a`)) [[1 1] \"abc\"])\n[p=[p=1 q=2] q=[~ u=[p=97 q=[p=[p=1 q=2] q=\"bc\"]]]]\n&gt; ((sear |=(* ~) (just 'a')) [[1 1] \"abc\"])\n[p=[p=1 q=2] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "shim"
        ],
        "doc": "<h1><code>++shim</code></h1>\n<p>Char in range</p>\n<p>Match characters (<code>++char</code>) within a range.</p>\n<h2>Accepts</h2>\n<p><code>les</code> is an atom.</p>\n<p><code>mos</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  shim                                                ::  match char in range\n  ~/  %shim\n  |=  {les/@ mos/@}\n  ~/  %fun\n  |=  tub/nail\n  ^-  (like char)\n  ?~  q.tub\n    (fail tub)\n  ?.  ?&amp;((gte i.q.tub les) (lte i.q.tub mos))\n    (fail tub)\n  (next tub)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((shim 'a' 'z') [[1 1] \"abc\"])\n[p=[p=1 q=2] q=[~ [p=~~a q=[p=[p=1 q=2] q=\"bc\"]]]]\n&gt; ((shim 'a' 'Z') [[1 1] \"abc\"])\n[p=[p=1 q=1] q=~]\n&gt; ((shim 'a' 'Z') [[1 1] \"Abc\"])\n[p=[p=1 q=2] q=[~ [p=~~~41. q=[p=[p=1 q=2] q=\"bc\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "slug"
        ],
        "doc": "<h1><code>++slug</code></h1>\n<p>Use gate to parse delimited list</p>\n<p>Parser modifier: By composing with a gate, parse a delimited <code>++list</code> of\nmatches.</p>\n<h2>Accepts</h2>\n<p><code>bus</code> is a <code>++rule</code>.</p>\n<p><code>fel</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  slug\n  |*  raq/_|*({a/* b/*} [a b])\n  |*  {bus/rule fel/rule}\n  ;~((comp raq) fel (stir +&lt;+.raq raq ;~(pfix bus fel)))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"20+5+110\" ((slug add) lus dem))\n135\n&gt; `@t`(scan \"a b c\" ((slug |=(a/[@ @t] (cat 3 a))) ace alp))\n'abc'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "stag"
        ],
        "doc": "<h1><code>++stag</code></h1>\n<p>Add label</p>\n<p>Add a label to an edge parsed by a rule.</p>\n<h2>Accepts</h2>\n<p><code>gob</code> is a noun.</p>\n<p><code>sef</code> is a rule.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  stag                                                ::  add a label\n  ~/  %stag\n  |*  {gob/* sef/rule}\n  ~/  %fun\n  |=  tub/nail\n  =+  vex=(sef tub)\n  ?~  q.vex\n    vex\n  [p=p.vex q=[~ u=[p=[gob p.u.q.vex] q=q.u.q.vex]]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((stag %foo (just 'a')) [[1 1] \"abc\"])\n[p=[p=1 q=2] q=[~ u=[p=[%foo ~~a] q=[p=[p=1 q=2] q=\"bc\"]]]]\n&gt; ((stag \"xyz\" (jest 'abc')) [[1 1] \"abc\"])\n[p=[p=1 q=4] q=[~ u=[p=[\"xyz\" 'abc'] q=[p=[p=1 q=4] q=\"\"]]]]\n&gt; ((stag 10.000 (shim 0 100)) [[1 1] \"abc\"])\n[p=[p=1 q=2] q=[~ u=[p=[10.000 ~~a] q=[p=[p=1 q=2] q=\"bc\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "star"
        ],
        "doc": "<h1><code>++star</code></h1>\n<p>List of matches</p>\n<p>Parser modifier: parse <code>++list</code> of matches.</p>\n<h2>Accepts</h2>\n<p><code>fel</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<pre><code>++  star                                                ::  0 or more times\n  |*  fel/rule\n  (stir `(list _(wonk *fel))`~ |*({a/* b/*} [a b]) fel)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"aaaaa\" (just 'a'))\n    ! {1 2}\n    ! 'syntax-error'\n    ! exit\n    &gt; (scan \"aaaaa\" (star (just 'a')))\n    \"aaaaa\"\n    &gt; (scan \"abcdef\" (star (just 'a')))\n    ! {1 2}\n    ! 'syntax-error'\n    ! exit\n    &gt; (scan \"abcabc\" (star (jest 'abc')))\n    &lt;|abc abc|&gt;\n    &gt; (scan \"john smith\" (star (shim 0 200)))\n    \"john smith\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "stet"
        ],
        "doc": "<h1><code>++stet</code></h1>\n<p>Add faces</p>\n<p>Add faces <code>[p q]</code> to range-parser pairs in a list.</p>\n<h2>Accepts</h2>\n<p><code>leh</code> is a list of range-parsers.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  stet\n  |*  leh/(list {?(@ {@ @}) rule})\n  |-\n  ?~  leh\n    ~\n  [i=[p=-.i.leh q=+.i.leh] t=$(leh t.leh)]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (stet (limo [[5 (just 'a')] [1 (jest 'abc')] [[1 1] (shim 0 200)] \n[[1 10] (cold %foo (just 'a'))]~]))\n~[\n  [p=5 q=&lt;1.lrk [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.nqy [daf=@tD &lt;394.imz 97.kdz 1.xlc %164&gt;]&gt;]&gt;]\n  [p=1 q=&lt;1.lrk [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.nqy [daf=@tD &lt;394.imz 97.kdz 1.xlc %164&gt;]&gt;]&gt;]\n  [p=[1 1] q=&lt;1.lrk [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.nqy [daf=@tD &lt;394.imz 97.kdz 1.xlc %164&gt;]&gt;]&gt;]\n  [p=[1 10] q=&lt;1.lrk [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.nqy [daf=@tD &lt;394.imz 97.kdz 1.xlc %164&gt;]&gt;]&gt;]\n]\n&gt; [[[1 1] (just 'a')] [[2 1] (shim 0 200)] ~]\n[ [[1 1] &lt;1.tnv [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.ktu [daf=@tD &lt;414.fvk 101.jzo 1.ypj %164&gt;]&gt;]&gt;]\n  [[2 1] &lt;1.fvg [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.khu [[les=@ mos=@] &lt;414.fvk 101.jzo 1.ypj %164&gt;]&gt;]&gt;]\n  ~\n]\n&gt; (stet (limo [[[1 1] (just 'a')] [[2 1] (shim 0 200)] ~]))\n~[\n  [p=[1 1] q=&lt;1.lrk [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.nqy [daf=@tD &lt;394.imz 97.kdz 1.xlc %164&gt;]&gt;]&gt;] \n  [p=[2 1] q=&lt;1.lrk [tub=[p=[p=@ud q=@ud] q=\"\"] &lt;1.nqy [daf=@tD &lt;394.imz 97.kdz 1.xlc %164&gt;]&gt;]&gt;]\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "stew"
        ],
        "doc": "<h1><code>++stew</code></h1>\n<p>Switch by first</p>\n<pre><code>++  stew                                                ::  switch by first char\n  ~/  %stew\n  |*  leh/(list {p/?(@ {@ @}) q/rule})                  ::  char+range keys\n  =+  ^=  wor                                           ::  range complete lth\n      |=  {ort/?(@ {@ @}) wan/?(@ {@ @})}\n      ?@  ort\n        ?@(wan (lth ort wan) (lth ort -.wan))\n      ?@(wan (lth +.ort wan) (lth +.ort -.wan))\n  =+  ^=  hel                                           ::  build parser map\n      =+  hel=`(tree _?&gt;(?=(^ leh) i.leh))`~\n      |-  ^+  hel\n      ?~  leh\n        ~\n      =+  yal=$(leh t.leh)\n      |-  ^+  hel\n      ?~  yal\n        [i.leh ~ ~]\n      ?:  (wor p.i.leh p.n.yal)\n        =+  nuc=$(yal l.yal)\n        ?&gt;  ?=(^ nuc)\n        ?:  (vor p.n.yal p.n.nuc)\n          [n.yal nuc r.yal]\n        [n.nuc l.nuc [n.yal r.nuc r.yal]]\n      =+  nuc=$(yal r.yal)\n      ?&gt;  ?=(^ nuc)\n      ?:  (vor p.n.yal p.n.nuc)\n        [n.yal l.yal nuc]\n      [n.nuc [n.yal l.yal l.nuc] r.nuc]\n  ~%  %fun  ..^$  ~\n  |=  tub/nail\n  ?~  q.tub\n    (fail tub)\n  |-\n  ?~  hel\n    (fail tub)\n  ?:  ?@  p.n.hel\n        =(p.n.hel i.q.tub)\n      ?&amp;((gte i.q.tub -.p.n.hel) (lte i.q.tub +.p.n.hel))\n    ::  (q.n.hel [(lust i.q.tub p.tub) t.q.tub])\n    (q.n.hel tub)\n  ?:  (wor i.q.tub p.n.hel)\n    $(hel l.hel)\n  $(hel r.hel)\n::\n</code></pre>\n<p>Parser generator. From an associative <code>++list</code> of characters or character\nranges to <code>++rule</code>s, construct a <code>++map</code>, and parse <code>++tape</code>s only\nwith <code>++rules</code> associated with a range that the <code>++tape</code>'s first character falls in.</p>\n<hr>\n"
    },
    {
        "keys": [
            "stir"
        ],
        "doc": "<h1><code>++stir</code></h1>\n<p>Parse repeatedly</p>\n<p>Parse with <code>++rule</code> as many times as possible, and fold over results with a\nbinary gate.</p>\n<h2>Accepts</h2>\n<p><code>rud</code> is a noun.</p>\n<p><code>raq</code> is a gate that takes two nouns and produces a cell.</p>\n<p><code>fel</code> is a rule.</p>\n<h2>Produces</h2>\n<p>A rule.</p>\n<h2>Source</h2>\n<pre><code>++  stun                                                ::  parse several times\n  |*  {lig/{@ @} fel/rule}\n  |=  tub/nail\n  ^-  (like (list _(wonk (fel))))\n  ?:  =(0 +.lig)\n    [p.tub [~ ~ tub]]\n  =+  vex=(fel tub)\n  ?~  q.vex\n    ?:  =(0 -.lig)\n      [p.vex [~ ~ tub]]\n    vex\n  =+  ^=  wag  %=  $\n                 -.lig  ?:(=(0 -.lig) 0 (dec -.lig))\n                 +.lig  ?:(=(0 +.lig) 0 (dec +.lig))\n                 tub  q.u.q.vex\n               ==\n  ?~  q.wag\n    wag\n  [p.wag [~ [p.u.q.vex p.u.q.wag] q.u.q.wag]]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"abc\" (stir *@ add prn))\n294\n&gt; (roll \"abc\" add)\nb=294\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "stun"
        ],
        "doc": "<h1><code>++stun</code></h1>\n<p>Parse several times</p>\n<p>Parse bounded number of times.</p>\n<h2>Accepts</h2>\n<p><code>[les=@ mos=@]</code> is a cell of atoms indicating the bounds.</p>\n<p><code>fel</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  stun                                                ::  parse several times\n  |*  {lig/{@ @} fel/rule}\n  |=  tub/nail\n  ^-  (like (list _(wonk (fel))))\n  ?:  =(0 +.lig)\n    [p.tub [~ ~ tub]]\n  =+  vex=(fel tub)\n  ?~  q.vex\n    ?:  =(0 -.lig)\n      [p.vex [~ ~ tub]]\n    vex\n  =+  ^=  wag  %=  $\n                 -.lig  ?:(=(0 -.lig) 0 (dec -.lig))\n                 +.lig  ?:(=(0 +.lig) 0 (dec +.lig))\n                 tub  q.u.q.vex\n               ==\n  ?~  q.wag\n    wag\n  [p.wag [~ [p.u.q.vex p.u.q.wag] q.u.q.wag]]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ((stun [5 10] prn) [1 1] \"aquickbrownfoxran\")\n[p=[p=1 q=11] q=[~ [p=\"aquickbrow\" q=[p=[p=1 q=11] q=\"nfoxran\"]]]]\n&gt; ((stun [5 10] prn) [1 1] \"aquickbro\")\n[p=[p=1 q=10] q=[~ [p=\"aquickbro\" q=[p=[p=1 q=10] q=\"\"]]]]\n&gt; ((stun [5 10] prn) [1 1] \"aqui\")\n[p=[p=1 q=5] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rash"
        ],
        "doc": "<h1><code>++rash</code></h1>\n<p>Parse or crash</p>\n<p>Parse a cord with a given <code>++rule</code> and crash if the <code>++cord</code> isn't entirely\nparsed.</p>\n<h2>Accepts</h2>\n<p><code>naf</code> is an atom.</p>\n<p><code>sab</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>The value of the parse result, or crash.</p>\n<h2>Source</h2>\n<pre><code>++  rash  |*({naf/@ sab/rule} (scan (trip naf) sab))   ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (rash 'I was the world in which I walked, and what I saw' (star (shim 0 200)))\n\"I was the world in which I walked, and what I saw\"\n&gt; (rash 'abc' (just 'a'))\n! {1 2}\n! 'syntax-error'\n! exit\n&gt; (rash 'abc' (jest 'abc'))\n'abc'\n`&gt; (rash 'abc' (jest 'ab'))\n! {1 3}\n! 'syntax-error'\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rush"
        ],
        "doc": "<h1><code>++rush</code></h1>\n<p>Parse or null</p>\n<p>Parse a given with a given rule and produce null if the cord isn't\nentirely parsed.</p>\n<h2>Accepts</h2>\n<p><code>naf</code> is an atom.</p>\n<p><code>sab</code> is a rule.</p>\n<h2>Produces</h2>\n<p>The value of the parse result, or null.</p>\n<h2>Source</h2>\n<pre><code>++  rush  |*({naf/@ sab/rule} (rust (trip naf) sab))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (rush 'I was the world in which I walked, and what I saw' (star (shim 0 200)))\n    [~ \"I was the world in which I walked, and what I saw\"]\n    &gt; (rush 'abc' (just 'a'))\n    ~\n    &gt; (rush 'abc' (jest 'abc'))\n    [~ 'abc']\n    &gt; (rush 'abc' (jest 'ac'))\n    ~\n    &gt; (rush 'abc' (jest 'ab'))\n    ~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rust"
        ],
        "doc": "<h1><code>++rust</code></h1>\n<p>Parse tape or null</p>\n<p>Parse a <code>++tape</code> with a given <code>++rule</code> and produce null if the <code>++tape</code> isn't\nentirely parsed.</p>\n<h2>Accepts</h2>\n<p><code>los</code> is a <code>++tape</code>.</p>\n<p><code>sab</code> is a <code>++rule</code>.</p>\n<h2>Produces</h2>\n<p>A <code>(unit ,@t)</code></p>\n<h2>Source</h2>\n<pre><code>++  rust  |*  {los/tape sab/rule}\n          =+  vex=((full sab) [[1 1] los])\n          ?~(q.vex ~ [~ u=p.u.q.vex])\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (rust \"I was the world in which I walked, and what I saw\" (star (shim 0 200)))\n    [~ \"I was the world in which I walked, and what I saw\"]\n    &gt; (rust \"Or heard or felt came not but from myself;\" (star (shim 0 200)))\n    [~ \"Or heard or felt came not but from myself;\"]\n    &gt; (rust \"And there I found myself more truly and more strange.\" (jest 'And there I'))\n    ~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "scan"
        ],
        "doc": "<h1><code>++scan</code></h1>\n<p>Parse tape or crash</p>\n<p>Parse a <code>++tape</code> with a given <code>++rule</code> and crash if the <code>++tape</code> isn't entirely\nparsed.</p>\n<h2>Accepts</h2>\n<p><code>los</code> is a tape.</p>\n<p><code>sab</code> is a rule.</p>\n<h2>Produces</h2>\n<p>Either a <code>++tape</code> or a crash.</p>\n<h2>Source</h2>\n<pre><code>++  scan  |*  {los/tape sab/rule}\n          =+  vex=((full sab) [[1 1] los])\n          ?~  q.vex\n            ~_  (show [%m '{%d %d}'] p.p.vex q.p.vex ~)\n            ~|('syntax-error' !!)\n          p.u.q.vex\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"I was the world in which I walked, and what I saw\" (star (shim 0 200)))\n    \"I was the world in which I walked, and what I saw\"\n    &gt; (scan \"Or heard or felt came not but from myself;\" (star (shim 0 200)))\n    \"Or heard or felt came not but from myself;\"\n    &gt; (scan \"And there I found myself more truly and more strange.\" (jest 'And there I'))\n    ! {1 12}\n    ! 'syntax-error'\n    ! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ace"
        ],
        "doc": "<h1><code>++ace</code></h1>\n<p>Parse space</p>\n<p>Parses ASCII character 32, space.</p>\n<h2>Source</h2>\n<pre><code>++  ace  (just ' ')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \" \" ace)\n~~. \n&gt; `cord`(scan \" \" ace)\n' '\n&gt; (ace [[1 1] \" \"])\n[p=[p=1 q=2] q=[~ [p=~~. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (ace [[1 1] \" abc \"])\n[p=[p=1 q=2] q=[~ [p=~~. q=[p=[p=1 q=2] q=\"abc \"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bar"
        ],
        "doc": "<h1><code>++bar</code></h1>\n<p>Parse vertical bar</p>\n<p>Parses ASCII character 124, the vertical bar.</p>\n<h2>Source</h2>\n<pre><code>++  bar  (just '|')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"|\" bar)\n~~~7c. \n&gt; `cord`(scan \"|\" bar)\n'|'\n&gt; (bar [[1 1] \"|\"])\n[p=[p=1 q=2] q=[~ [p=~~~7c. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (bar [[1 1] \"|=\"])\n[p=[p=1 q=2] q=[~ [p=~~~7c. q=[p=[p=1 q=2] q=\"=\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bas"
        ],
        "doc": "<h1><code>++bas</code></h1>\n<p>Parse backslash</p>\n<p>Parses ASCII character 92, the backslash. Note the extra <code>\\</code> in the calling of\n<code>bas</code> with <a href=\"/docs/hoon/library/2ec#++just\"><code>++just</code></a> is to escape the escape\ncharacter, <code>\\</code>.</p>\n<h2>Source</h2>\n<pre><code>++  bas  (just '\\\\')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"\\\\\" bas)\n~~~5c.\n&gt; `cord`(scan \"\\\\\" bas)\n'\\'\n&gt; (bas [[1 1] \"\\\"])\n~ &lt;syntax error at [1 18]&gt;\n&gt; (bas [[1 1] \"\\\\\"])\n[p=[p=1 q=2] q=[~ [p=~~~5c. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (bas [[1 1] \"\\\"\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "buc"
        ],
        "doc": "<h1><code>++buc</code></h1>\n<p>Parse dollar sign</p>\n<p>Parses ASCII character 36, the dollar sign.</p>\n<h2>Source</h2>\n<pre><code>++  buc  (just '$')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"$\" buc)\n~~~24.\n&gt; `cord`(scan \"$\" buc)\n'$'\n&gt; (buc [[1 1] \"$\"])\n[p=[p=1 q=2] q=[~ [p=~~~24. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (buc [[1 1] \"$%\"])\n[p=[p=1 q=2] q=[~ [p=~~~24. q=[p=[p=1 q=2] q=\"%\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cab"
        ],
        "doc": "<h1><code>++cab</code></h1>\n<p>Parse underscore</p>\n<p>Parses ASCII character 95, the underscore.</p>\n<h2>Source</h2>\n<pre><code>++  cab  (just '_')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"_\" cab)\n~~~5f.\n&gt; `cord`(scan \"_\" cab)\n'_'\n&gt; (cab [[1 1] \"_\"])\n[p=[p=1 q=2] q=[~ [p=~~~5f. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (cab [[1 1] \"|_\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cen"
        ],
        "doc": "<h1><code>++cen</code></h1>\n<p>Parses percent sign</p>\n<p>Parses ASCII character 37, the percent sign.</p>\n<h2>Source</h2>\n<pre><code>++  cen  (just '%')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"%\" cen)\n~~~25.\n&gt; `cord`(scan \"%\" cen)\n'%'\n&gt; (cen [[1 1] \"%\"])\n[p=[p=1 q=2] q=[~ [p=~~~25. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (cen [[1 1] \"%^\"])\n[p=[p=1 q=2] q=[~ [p=~~~25. q=[p=[p=1 q=2] q=\"^\"]]]] \n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "col"
        ],
        "doc": "<h1><code>++col</code></h1>\n<p>Parse colon</p>\n<p>Parses ASCII character 58, the colon</p>\n<h2>Source</h2>\n<pre><code>++  col  (just ':')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \":\" col)\n~~~3a.\n&gt; `cord`(scan \":\" col)\n':'\n&gt; (col [[1 1] \":\"])\n[p=[p=1 q=2] q=[~ [p=~~~3a. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (col [[1 1] \":-\"])\n[p=[p=1 q=2] q=[~ [p=~~~3a. q=[p=[p=1 q=2] q=\"-\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "com"
        ],
        "doc": "<h1><code>++com</code></h1>\n<p>Parse comma</p>\n<p>Parses ASCII character 44, the comma.</p>\n<h2>Source</h2>\n<pre><code>++  com  (just ',')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \",\" com)\n~~~2c.\n&gt; `cord`(scan \",\" com)\n','\n&gt; (com [[1 1] \",\"])\n[p=[p=1 q=2] q=[~ [p=~~~2c. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (com [[1 1] \"not com\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "doq"
        ],
        "doc": "<h1><code>++doq</code></h1>\n<p>Parse double quote</p>\n<p>Parses ASCII character 34, the double quote.</p>\n<h2>Source</h2>\n<pre><code>++  doq  (just '\"')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"\\\"\" doq)\n~~~22.\n&gt; `cord`(scan \"\\\"\" doq)\n'\"'\n&gt; (doq [[1 1] \"\\\"\"])\n[p=[p=1 q=2] q=[~ [p=~~~22. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (doq [[1 1] \"not successfully parsed\"])\n[p=[p=1 q=1] q=~]\n&gt; (scan \"see?\" doq)\n! {1 1}\n! 'syntax-error'\n! exit \n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dot"
        ],
        "doc": "<h1><code>++dot</code></h1>\n<p>Parse period</p>\n<p>Parses ASCII character 46, the period.</p>\n<h2>Source</h2>\n<pre><code>++  dot  (just '.')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \".\" dot)\n~~~.\n&gt; `cord`(scan \".\" dot)\n'.'\n&gt; (dot [[1 1] \".\"])\n[p=[p=1 q=2] q=[~ [p=~~~. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (dot [[1 1] \".^\"])\n[p=[p=1 q=2] q=[~ [p=~~~. q=[p=[p=1 q=2] q=\"^\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fas"
        ],
        "doc": "<h1><code>++fas</code></h1>\n<p>Parse forward slash</p>\n<p>Parses ASCII character 47, the forward slash.</p>\n<h2>Source</h2>\n<pre><code>++  fas  (just '/')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"/\" fas)\n~~~2f.\n&gt; `cord`(scan \"/\" fas)\n'/'\n&gt; (fas [[1 1] \"/\"])\n[p=[p=1 q=2] q=[~ [p=~~~2f. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (fas [[1 1] \"|/\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gal"
        ],
        "doc": "<h1><code>++gal</code></h1>\n<p>Parse less-than sign</p>\n<p>Parses ASCII character 60, the less-than sign.</p>\n<h2>Source</h2>\n<pre><code>++  gal  (just '&lt;')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"&lt;\" gal)\n~~~3c.\n&gt; `cord`(scan \"&lt;\" gal)\n'&lt;'\n&gt; (gal [[1 1] \"&lt;\"])\n[p=[p=1 q=2] q=[~ [p=~~~3c. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (gal [[1 1] \"&lt;+\"])\n[p=[p=1 q=2] q=[~ [p=~~~3c. q=[p=[p=1 q=2] q=\"+\"]]]]\n&gt; (gal [[1 1] \"+&lt;\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gar"
        ],
        "doc": "<h1><code>++gar</code></h1>\n<p>Parse greater-than sign</p>\n<p>Parses ASCII character 62, the greater-than sign.</p>\n<h2>Source</h2>\n<pre><code>++  gar  (just '&gt;')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"&gt;\" gar)\n~~~3e.\n&gt; `cord`(scan \"&gt;\" gar)\n'&gt;'\n&gt; (gar [[1 1] \"&gt;\"])\n[p=[p=1 q=2] q=[~ [p=~~~3e. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (gar [[1 1] \"=&gt;\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hax"
        ],
        "doc": "<h1><code>++hax</code></h1>\n<p>Parse number sign</p>\n<p>Parses ASCII character 35, the number sign.</p>\n<h2>Source</h2>\n<pre><code>++  hax  (just '#')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"#\" hax)\n~~~23.\n&gt; `cord`(scan \"#\" hax)\n'#'\n&gt; (hax [[1 1] \"#\"])\n[p=[p=1 q=2] q=[~ [p=~~~23. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (hax [[1 1] \"#!\"])\n[p=[p=1 q=2] q=[~ [p=~~~23. q=[p=[p=1 q=2] q=\"!\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hep"
        ],
        "doc": "<h1><code>++hep</code></h1>\n<p>Parse hyphen</p>\n<p>Parses ASCII character 45, the hyphen.</p>\n<h2>Source</h2>\n<pre><code>++  hep  (just '-')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"-\" hep)\n~~-\n&gt; `cord`(scan \"-\" hep)\n'-'\n&gt; (hep [[1 1] \"-\"])\n[p=[p=1 q=2] q=[~ [p=~~- q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (hep [[1 1] \":-\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "kel"
        ],
        "doc": "<h1><code>++kel</code></h1>\n<p>Parse left curley bracket</p>\n<p>Parses ASCII character 123, the left curly bracket. Note that <code>{</code>\n(<code>kel</code>) and <code>}</code> (<code>ker</code>) open and close a Hoon expression for Hoon string\ninterpolation. To parse either of them, they must be escaped.</p>\n<h2>Source</h2>\n<pre><code>++  kel  (just '{')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"\\{\" kel)\n~~~7b.\n&gt; `cord`(scan \"\\{\" kel)\n'{'\n&gt; (kel [[1 1] \"\\{\"])\n[p=[p=1 q=2] q=[~ [p=~~~7b. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (kel [[1 1] \" \\{\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ker"
        ],
        "doc": "<h1><code>++ker</code></h1>\n<p>Parse right curley bracket</p>\n<p>Parses ASCII character 125, the right curly bracket. Note that <code>{</code>\n(<code>kel</code>) and <code>}</code> (<code>ker</code>) open and close a Hoon expression for Hoon string\ninterpolation. To parse either of them, they must be escaped.</p>\n<h2>Source</h2>\n<pre><code>++  ker  (just '}')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"}\" ker)\n~~~7d.\n&gt; `cord`(scan \"}\" ker)\n'}'\n&gt; (ker [[1 1] \"}\"])\n[p=[p=1 q=2] q=[~ [p=~~~7d. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (ker [[1 1] \"\\{}\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ket"
        ],
        "doc": "<h1><code>++ket</code></h1>\n<p>Parse caret</p>\n<p>Parses ASCII character 94, the caret.</p>\n<h2>Source</h2>\n<pre><code>++  ket  (just '^')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"^\" ket)\n~~~5e.\n&gt; `cord`(scan \"^\" ket)\n'^'\n&gt; (ket [[1 1] \"^\"])\n[p=[p=1 q=2] q=[~ [p=~~~5e. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (ket [[1 1] \".^\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lus"
        ],
        "doc": "<h1><code>++lus</code></h1>\n<p>Parse plus sign</p>\n<p>Parses ASCII character 43, the plus sign.</p>\n<h2>Source</h2>\n<pre><code>++  lus  (just '+')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"+\" lus)\n    ~~~2b.\n    &gt; `cord`(scan \"+\" lus)\n    '+'\n    &gt; (lus [[1 1] \"+\"])\n    [p=[p=1 q=2] q=[~ [p=~~~2b. q=[p=[p=1 q=2] q=\"\"]]]]\n    &gt; (lus [[1 1] \".+\"])\n    [p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pam"
        ],
        "doc": "<h1><code>++pam</code></h1>\n<p>Parse ampersand</p>\n<p>Parses ASCII character 38, the ampersand.</p>\n<h2>Source</h2>\n<pre><code>++  pam  (just '&amp;')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"&amp;\" pam)\n~~~26.\n&gt; `cord`(scan \"&amp;\" pam)\n'&amp;'\n&gt; (pam [[1 1] \"&amp;\"])\n[p=[p=1 q=2] q=[~ [p=~~~26. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (pam [[1 1] \"?&amp;\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pat"
        ],
        "doc": "<h1><code>++pat</code></h1>\n<p>Parse \"at\" sign</p>\n<p>Parses ASCII character 64, the \"at\" sign.</p>\n<h2>Source</h2>\n<pre><code>++  pat  (just '@')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"@\" pat)\n~~~4.\n&gt; `cord`(scan \"@\" pat)\n'@'\n&gt; (pat [[1 1] \"@\"])\n[p=[p=1 q=2] q=[~ [p=~~~4. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (pat [[1 1] \"?@\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pel"
        ],
        "doc": "<h1><code>++pel</code></h1>\n<p>Parse left parenthesis</p>\n<p>Parses ASCII character 40, the left parenthesis.</p>\n<h2>Source</h2>\n<pre><code>++  pel  (just '(')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"(\" pel)\n~~~28.\n&gt; `cord`(scan \"(\" pel)\n'('\n&gt; (pel [[1 1] \"(\"])\n[p=[p=1 q=2] q=[~ [p=~~~28. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (pel [[1 1] \";(\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "per"
        ],
        "doc": "<h1><code>++per</code></h1>\n<p>Parse right parenthesis</p>\n<p>Parses ASCII character 41, the right parenthesis.</p>\n<h2>Source</h2>\n<pre><code>++  per  (just ')')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \")\" per)\n~~~29.\n&gt; `cord`(scan \")\" per)\n')'\n&gt; (per [[1 1] \")\"])\n[p=[p=1 q=2] q=[~ [p=~~~29. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (per [[1 1] \" )\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sel"
        ],
        "doc": "<h1><code>++sel</code></h1>\n<p>Parse left square bracket</p>\n<p>Parses ASCII character 91, the left square bracket.</p>\n<h2>Source</h2>\n<pre><code>++  sel  (just '[')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"[\" sel)\n    ~~~5b.\n    &gt; `cord`(scan \"[\" sel)\n    '['\n    &gt; (sel [[1 1] \"[\"])\n    [p=[p=1 q=2] q=[~ [p=~~~5b. q=[p=[p=1 q=2] q=\"\"]]]]\n    &gt; (sel [[1 1] \"-[\"])\n    [p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sem"
        ],
        "doc": "<h1><code>++sem</code></h1>\n<p>Parse semicolon</p>\n<p>Parses ASCII character 59, the semicolon.</p>\n<h2>Source</h2>\n<pre><code>++  sem  (just ';')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \";\" sem)\n~~~3b.\n&gt; `cord`(scan \";\" sem)\n';'\n&gt; (sem [[1 1] \";\"])\n[p=[p=1 q=2] q=[~ [p=~~~3b. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (sem [[1 1] \" ;\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ser"
        ],
        "doc": "<h1><code>++ser</code></h1>\n<p>Parse right square bracket</p>\n<p>Parses ASCII character 93, the right square bracket.</p>\n<h2>Source</h2>\n<pre><code>++  ser  (just ']')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"]\" ser)\n~~~5d.\n&gt; `cord`(scan \"]\" ser)\n']'\n&gt; (ser [[1 1] \"]\"])\n[p=[p=1 q=2] q=[~ [p=~~~5d. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (ser [[1 1] \"[ ]\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sig"
        ],
        "doc": "<h1><code>++sig</code></h1>\n<p>Parse tilde</p>\n<p>Parses ASCII character 126, the tilde.</p>\n<h2>Source</h2>\n<pre><code>++  sig  (just '~')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"~\" sig)\n~~~~\n&gt; `cord`(scan \"~\" sig)\n'~'\n&gt; (sig [[1 1] \"~\"])\n[p=[p=1 q=2] q=[~ [p=~~~~ q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (sig [[1 1] \"?~\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "soq"
        ],
        "doc": "<h1><code>++soq</code></h1>\n<p>Parse single quote</p>\n<p>Parses ASCII character 39, soq. Note the extra '' is to escape the first\n<code>soq</code> because soq delimits a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  soq  (just '\\'')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"'\" soq)\n~~~27.\n&gt; `cord`(scan \"'\" soq)\n'''\n&gt; (soq [[1 1] \"'\"])\n[p=[p=1 q=2] q=[~ [p=~~~27. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (soq [[1 1] \"&gt;'\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tar"
        ],
        "doc": "<h1><code>++tar</code></h1>\n<p>Parse asterisk</p>\n<p>Parses ASCII character 42, the asterisk.</p>\n<h2>Source</h2>\n<pre><code>++  tar  (just '*')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"*\" tar)\n~~~2a.\n&gt; `cord`(scan \"*\" tar)\n'*'\n&gt; (tar [[1 1] \"*\"])\n[p=[p=1 q=2] q=[~ [p=~~~2a. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (tar [[1 1] \".*\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tec"
        ],
        "doc": "<h1><code>++tec</code></h1>\n<p>Parse backtick</p>\n<p>Parses ASCII character 96, the backtick (also known as the \"grave\naccent\").</p>\n<h2>Source</h2>\n<pre><code>++  tec  (just '`')                                     ::  backTiCk\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"`\" tec)\n~~~6.\n&gt; `cord`(scan \"`\" tec)\n'`'\n&gt; (tec [[1 1] \"`\"])\n[p=[p=1 q=2] q=[~ [p=~~~6. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (tec [[1 1] \" `\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tis"
        ],
        "doc": "<h1><code>++tis</code></h1>\n<p>Parse equals sign</p>\n<p>Parses ASCII character 61, the equals sign.</p>\n<h2>Source</h2>\n<pre><code>++  tis  (just '=')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"=\" tis)\n~~~3d.\n&gt; `cord`(scan \"=\" tis)\n'='\n&gt; (tis [[1 1] \"=\"])\n[p=[p=1 q=2] q=[~ [p=~~~3d. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (tis [[1 1] \"|=\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wut"
        ],
        "doc": "<h1><code>++wut</code></h1>\n<p>Parses question mark</p>\n<p>Parses ASCII character 63, the question mark.</p>\n<h2>Source</h2>\n<pre><code>++  wut  (just '?')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"?\" wut)\n~~~3f.\n&gt; `cord`(scan \"?\" wut)\n'?'\n&gt; (wut [[1 1] \"?\"])\n[p=[p=1 q=2] q=[~ [p=~~~3f. q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (wut [[1 1] \".?\"])\n[p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zap"
        ],
        "doc": "<h1><code>++zap</code></h1>\n<p>Exclamation point</p>\n<p>Parses ASCII character 33, the exclamation point zap.</p>\n<h2>Source</h2>\n<pre><code>++  zap  (just '!')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"!\" zap)\n    ~~~21.\n    &gt; `cord`(scan \"!\" zap)\n    '!'\n    &gt; (zap [[1 1] \"!\"])\n    [p=[p=1 q=2] q=[~ [p=~~~21. q=[p=[p=1 q=2] q=\"\"]]]]\n    &gt; (zap [[1 1] \"?!\"])\n    [p=[p=1 q=1] q=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ab"
        ],
        "doc": "<h1><code>++ab</code></h1>\n<p>Primitive parser engine</p>\n<p>A core containing numeric parser primitives.</p>\n<h2>Source</h2>\n<pre><code>++  ab\n  |%\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ab\n&lt;36.ecc 414.gly 100.xkc 1.ypj %164&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bix"
        ],
        "doc": "<h1><code>++bix</code></h1>\n<p>Parse hex pair</p>\n<p>Parsing <code>++rule</code>. Parses a pair of base-16 digits. Used in escapes.</p>\n<h2>Accepts</h2>\n<p>XX</p>\n<h2>Produces</h2>\n<p>A an atom. XX</p>\n<h2>Source</h2>\n<pre><code>  ++  bix  (bass 16 (stun [2 2] six))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"07\" bix:ab)\nq=7\n&gt; (scan \"51\" bix:ab)\nq=81\n&gt; (scan \"a3\" bix:ab)\nq=163\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hif"
        ],
        "doc": "<h1><code>++hif</code></h1>\n<p>Parse phonetic pair</p>\n<p>Parsing <code>++rule</code>. Parses an atom of odor <code>@pE</code>, a phrase of two bytes\nencoded phonetically.</p>\n<h2>Accepts</h2>\n<p>XX</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  hif  (boss 256 ;~(plug tip tiq (easy ~)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"doznec\" hif:ab)\nq=256\n&gt; (scan \"pittyp\" hif:ab)\nq=48.626\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "huf"
        ],
        "doc": "<h1><code>++huf</code></h1>\n<p>Parse two phonetic pairs</p>\n<p>Parsing <code>++rule</code>. Parses and unscrambles an atom of odor @pF, a phrase\nof two two-byte pairs that are encoded (and scrambled) phonetically.</p>\n<h2>Accepts</h2>\n<p>XX</p>\n<h2>Produces</h2>\n<p>An atom. XX</p>\n<h2>Source</h2>\n<pre><code>  ++  huf  %+  cook\n               |=([a/@ b/@] (wred:un ~(zug mu ~(zag mu [a b]))))\n             ;~(plug hif ;~(pfix hep hif))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"pittyp-pittyp\" huf:ab)\n328.203.557\n&gt; (scan \"tasfyn-partyv\" huf:ab)\n65.792\n&gt; `@ux`(scan \"tasfyn-partyv\" huf:ab)\n0x1.0100\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hyf"
        ],
        "doc": "<h1><code>++hyf</code></h1>\n<p>Parse 8 phonetic bytes</p>\n<p>Parsing <code>++rule</code>. Parses an atom of odor @pG, a phrase of eight of\nphonetic bytes.</p>\n<h2>Accepts</h2>\n<p>An atom of odor <code>@pG</code></p>\n<h2>Produces</h2>\n<p>An atom. XX</p>\n<h2>Source</h2>\n<pre><code>  ++  hyf  (bass 0x1.0000.0000 ;~(plug huf ;~(pfix hep huf) (easy ~)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"sondel-forsut-tillyn-nillyt\" hyf:ab)\nq=365.637.097.828.335.095\n&gt; `@u`~sondel-forsut-tillyn-nillyt\n365.637.097.828.335.095\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pev"
        ],
        "doc": "<h1><code>++pev</code></h1>\n<p>Parse \\&lt;= 5 base-32</p>\n<p>Parsing <code>++rule</code>. Parses up to five base-32 digits without a leading zero.</p>\n<h2>Accepts</h2>\n<p>Up to five @uv (base 64) digits.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  pev  (bass 32 ;~(plug sev (stun [0 4] siv)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"a\" pev:ab)\nq=10\n&gt; (scan \"290j\" pev:ab)\nq=74.771\n&gt; (scan \"123456\" pev:ab)\n! {1 6}\n! exit\n&gt; (scan \"090j\" pev:ab)\n~ &lt;syntax error at [1 11]&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pew"
        ],
        "doc": "<h1><code>++pew</code></h1>\n<p>Parse \\&lt;= 5 base-64</p>\n<p>Parsing <code>++rule</code>. Parses up to five base-64 digits without a leading zero.</p>\n<h2>Accepts</h2>\n<p>Up to five @uw (base 64) digits.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  pew  (bass 64 ;~(plug sew (stun [0 4] siw)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"Q\" pew:ab)\nq=52\n&gt; (scan \"aQ~9\" pew:ab)\nq=2.838.473\n&gt; `@`0waQ~9\n2.838.473\n&gt; (scan \"123456\" pew:ab)\n! {1 6}\n! exit\n&gt; (scan \"012345\" pew:ab)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "piv"
        ],
        "doc": "<h1><code>++piv</code></h1>\n<p>Parse 5 base-32</p>\n<p>Parsing <code>++rule</code>. Parses exactly five base-32 digits.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  piv  (bass 32 (stun [5 5] siv))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"10b3l\" piv:ab)\nq=1.059.957\n&gt; (scan \"1\" piv:ab)\n! {1 2}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "piw"
        ],
        "doc": "<h1><code>++piw</code></h1>\n<p>Parse 5 base-64</p>\n<p>Parsing <code>++rule</code>. Parses exactly five base-64 digits.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  piw  (bass 64 (stun [5 5] siw))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"2C-pZ\" piw:ab)\nq=43.771.517\n&gt; (scan \"2\" piv:ab)\n! {1 2}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qeb"
        ],
        "doc": "<h1><code>++qeb</code></h1>\n<p>Parse \\&lt;= 4 binary</p>\n<p>Parsing <code>++rule</code>. Parses a binary number of up to 4 digits in length without\na leading zero.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  qeb  (bass 2 ;~(plug seb (stun [0 3] sib)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"1\" qeb:ab)\nq=1\n&gt; (scan \"101\" qeb:ab)\nq=5\n&gt; (scan \"1111\" qeb:ab)\nq=15\n&gt; (scan \"11111\" qeb:ab)\n! {1 5}\n! exit\n&gt; (scan \"01\" qeb:ab)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qex"
        ],
        "doc": "<h1><code>++qex</code></h1>\n<p>Parse \\&lt;= 4 hex</p>\n<p>Parsing <code>++rule</code>. Parses a hexadecimal number of up to 4 digits in length\nwithout a leading zero.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  qex  (bass 16 ;~(plug sex (stun [0 3] hit)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"ca\" qex:ab)\nq=202\n&gt; (scan \"18ac\" qex:ab)\nq=6.316\n&gt; (scan \"18acc\" qex:ab)\n! {1 5}\n! exit\n&gt; (scan \"08ac\" qex:ab)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qib"
        ],
        "doc": "<h1><code>++qib</code></h1>\n<p>Parse 4 binary</p>\n<p>Parsing <code>++rule</code>. Parses exactly four binary digits.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  qib  (bass 2 (stun [4 4] sib))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"0001\" qib:ab)\nq=1\n&gt; (scan \"0100\" qib:ab)\nq=4\n&gt; (scan \"110\" qib:ab)\n! {1 4}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qix"
        ],
        "doc": "<h1><code>++qix</code></h1>\n<p>Parse 4 hex</p>\n<p>Parsing <code>++rule</code>. Parses exactly four hexadecimal digits.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  qix  (bass 16 (stun [4 4] six))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"0100\" qix:ab)\nq=256\n&gt; (scan \"10ff\" qix:ab)\nq=4.351\n&gt; (scan \"0\" qix:ab)\n! {1 2}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "seb"
        ],
        "doc": "<h1><code>++seb</code></h1>\n<p>Parse 1</p>\n<p>Parsing <code>++rule</code>. Parses the number 1.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  seb  (cold 1 (just '1'))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"1\" seb:ab)\n1\n&gt; (scan \"0\" seb:ab)\n! ~zod/try/~2014.10.23..22.34.21..bfdd/:&lt;[1 1].[1 18]&gt;\n! {1 1}\n&gt; (scan \"2\" seb:ab)\n! ~zod/try/~2014.10.23..22.34.29..d399/:&lt;[1 1].[1 18]&gt;\n! {1 1}\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sed"
        ],
        "doc": "<h1><code>++sed</code></h1>\n<p>Parse decimal</p>\n<p>Parsing <code>++rule</code>. Parses a nonzero decimal digit.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sed  (cook |=(a/@ (sub a '0')) (shim '1' '9'))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"5\" sed:ab)\n5\n&gt; (scan \"0\" sed:ab)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sev"
        ],
        "doc": "<h1><code>++sev</code></h1>\n<p>Parse base-32</p>\n<p>Parsing <code>++rule</code>. Parses a nonzero base-32 digit</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sev  ;~(pose sed sov)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"c\" sev:ab)\n12\n~zod/socialnet=&gt; (scan \"0\" sev:ab)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sew"
        ],
        "doc": "<h1><code>++sew</code></h1>\n<p>Parse base-64</p>\n<p>Parsing <code>++rule</code>. Parses a nonzero base-64 digit</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sew  ;~(pose sed sow)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"M\" sew:ab)\n48\n&gt; (scan \"0\" sew:ab)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sex"
        ],
        "doc": "<h1><code>++sex</code></h1>\n<p>Parse hex</p>\n<p>Parsing <code>++rule</code>. Parses a nonzero hexadecimal digit.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sex  ;~(pose sed sox)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"e\" sex:ab)\n14\n&gt; (scan \"0\" sex:ab)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sib"
        ],
        "doc": "<h1><code>++sib</code></h1>\n<p>Parse binary</p>\n<p>Parsing <code>++rule</code>. Parses a binary digit.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sib  (cook |=(a/@ (sub a '0')) (shim '0' '1'))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"1\" sib:ab)\n1\n~zod/socialnet=&gt; (scan \"0\" sib:ab)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sid"
        ],
        "doc": "<h1><code>++sid</code></h1>\n<p>Parse decimal</p>\n<p>Parsing <code>++rule</code>. Parses a decimal digit.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sid  (cook |=(a/@ (sub a '0')) (shim '0' '9'))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"5\" sid:ab)\n5\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "siv"
        ],
        "doc": "<h1><code>++siv</code></h1>\n<p>Parse base-32</p>\n<p>Parsing <code>++rule</code>. Parses a base-32 digit.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  siv  ;~(pose sid sov)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"c\" siv:ab)\n12\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "siw"
        ],
        "doc": "<h1><code>++siw</code></h1>\n<p>Parse base-64</p>\n<p>Parsing <code>++rule</code>. Parses a base-64 digit.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  siw  ;~(pose sid sow)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"M\" siw:ab)\n48\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "six"
        ],
        "doc": "<h1><code>++six</code></h1>\n<p>Parse hex</p>\n<p>Parsing <code>++rule</code>. Parses a hexadecimal digit.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  six  ;~(pose sid sox)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"e\" six:ab)\n14\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sov"
        ],
        "doc": "<h1><code>++sov</code></h1>\n<p>Parse base-32</p>\n<p>Parsing <code>++rule</code>. Parses a base-32 letter.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sov  (cook |=(a/@ (sub a 87)) (shim 'a' 'v'))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"c\" sov:ab)\n12\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sow"
        ],
        "doc": "<h1><code>++sow</code></h1>\n<p>Parse base-64</p>\n<p>Parsing <code>++rule</code>. Parses a base-64 letter/symbol.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sow  ;~  pose\n             (cook |=(a/@ (sub a 87)) (shim 'a' 'z'))\n             (cook |=(a/@ (sub a 29)) (shim 'A' 'Z'))\n             (cold 62 (just '-'))\n             (cold 63 (just '~'))\n           ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"M\" sow:ab)\n48\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sox"
        ],
        "doc": "<h1><code>++sox</code></h1>\n<p>Parse hex letter</p>\n<p>Parsing <code>++rule</code>. Parses a hexadecimal letter.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  sox  (cook |=(a/@ (sub a 87)) (shim 'a' 'f'))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"e\" sox:ab)\n14\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ted"
        ],
        "doc": "<h1><code>++ted</code></h1>\n<p>Parse \\&lt;= 3 decimal</p>\n<p>Parsing <code>++rule</code>. Parses a decimal number of up to 3 digits without a\nleading zero.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  ted  (bass 10 ;~(plug sed (stun [0 2] sid)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"21\" ted:ab)\nq=21\n&gt; (scan \"214\" ted:ab)\nq=214\n&gt; (scan \"2140\" ted:ab)\n{1 4}\n&gt; (scan \"0\" ted:ab)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tip"
        ],
        "doc": "<h1><code>++tip</code></h1>\n<p>Leading phonetic byte</p>\n<p>Parsing <code>++rule</code>. Parses the leading phonetic byte, which represents a\nsyllable.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  tip  (sear |=(a/@ (ins:po a)) til)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"doz\" tip:ab)\n0\n&gt; (scan \"pit\" tip:ab)\n242\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tiq"
        ],
        "doc": "<h1><code>++tiq</code></h1>\n<p>Trailing phonetic syllable</p>\n<p>Parsing <code>++rule</code>. Parses the trailing phonetic byte, which represents a\nsyllable.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  tiq  (sear |=(a/@ (ind:po a)) til)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"zod\" tiq:ab)\n0\n&gt; (scan \"nec\" tiq:ab)\n1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tid"
        ],
        "doc": "<h1><code>++tid</code></h1>\n<p>Parse 3 decimal digits</p>\n<p>Parsing <code>++rule</code>. Parses exactly three decimal digits.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  tid  (bass 10 (stun [3 3] sid))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"013\" tid:ab)\nq=13\n&gt; (scan \"01\" tid:ab)\n! {1 3}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "til"
        ],
        "doc": "<h1><code>++til</code></h1>\n<p>Parse 3 lowercase</p>\n<p>Parsing <code>++rule</code>. Parses exactly three lowercase letters.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  til  (boss 256 (stun [3 3] low))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"mer\" til:ab)\nq=7.497.069\n&gt; `@t`(scan \"mer\" til:ab)\n'mer'\n&gt; (scan \"me\" til:ab)\n! {1 3}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "urs"
        ],
        "doc": "<h1><code>++urs</code></h1>\n<p>Parse span characters</p>\n<p>Parsing rule. Parses characters from an atom of the span odor <code>@ta</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  urs  %+  cook\n             |=(a/tape (rap 3 ^-((list @) a)))\n           (star ;~(pose nud low hep dot sig cab))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ta`(scan \"asa-lom_tak\" urs:ab)\n~.asa-lom_tak \n&gt; `@t`(scan \"asa-lom_tak\" urs:ab)\n'asa-lom_tak'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "urt"
        ],
        "doc": "<h1><code>++urt</code></h1>\n<p>Parse non-<code>_</code> span</p>\n<p>Parsing rule. Parses all characters of the span odor <code>@ta</code> except\nfor cab, <code>_</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  urt  %+  cook\n             |=(a/tape (rap 3 ^-((list @) a)))\n           (star ;~(pose nud low hep dot sig))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`(scan \"asa-lom.t0k\" urt:ab)\n'asa-lom.t0k'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "voy"
        ],
        "doc": "<h1><code>++voy</code></h1>\n<p>Parse bas, soq, or bix</p>\n<p>Parsing rule. Parses an escaped backslash, single quote, or hex pair\nbyte.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  voy  ;~(pfix bas ;~(pose bas soq bix))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"\\\\0a\" voy:ab)\nq=10\n&gt; (scan \"\\\\'\" voy:ab)\nq=39\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ag"
        ],
        "doc": "<h1><code>++ag</code></h1>\n<p>Top-level atom parser engine</p>\n<p>A core containing top-level atom parsers.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  ag\n  |%\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ag\n&lt;14.vpu 414.mof 100.xkc 1.ypj %164&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ape"
        ],
        "doc": "<h1><code>++ape</code></h1>\n<p>Parse 0 or rule</p>\n<p>Parser modifier. Parses 0 or the sample rule <code>fel</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>fel</code> is a <code>rule</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  ape  |*(fel/rule ;~(pose (cold 0 (just '0')) fel))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"202\" (star (ape:ag (cold 2 (just '2')))))\n~[2 0 2]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bay"
        ],
        "doc": "<h1><code>++bay</code></h1>\n<p>Parses binary number</p>\n<p>Parsing rule. Parses a binary number without a leading zero.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  bay  (ape (bass 16 ;~(plug qeb:ab (star ;~(pfix dog qib:ab)))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"10.0110\" bay:ag)\nq=38\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bip"
        ],
        "doc": "<h1><code>++bip</code></h1>\n<p>Parse IPv6</p>\n<p>Parsing rule. Parses a <code>@is</code>, an IPv6 address.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  bip  =+  tod=(ape qex:ab)\n           (bass 0x1.0000 ;~(plug tod (stun [7 7] ;~(pfix dog tod))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"0.0.ea.3e6c.0.0.0.0\" bip:ag)\nq=283.183.420.760.121.105.516.068.864\n&gt; `@is`(scan \"0.0.ea.3e6c.0.0.0.0\" bip:ag)\n.0.0.ea.3e6c.0.0.0.0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dem"
        ],
        "doc": "<h1><code>++dem</code></h1>\n<p>Parse decimal with dots</p>\n<p>Parsing rule. Parses a decimal number that includes dot separators.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  dem  (ape (bass 1.000 ;~(plug ted:ab (star ;~(pfix dog tid:ab)))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"52\" dem:ag)\nq=52\n&gt; (scan \"13.507\" dem:ag)\nq=13.507\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dim"
        ],
        "doc": "<h1><code>++dim</code></h1>\n<p>Parse decimal number</p>\n<p>Parsing rule. Parses a decimal number without a leading zero.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  dim  (ape (bass 10 ;~(plug sed:ab (star sid:ab))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"52\" dim:ag)\nq=52\n&gt; (scan \"013507\" dim:ag)\n! {1 2}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dum"
        ],
        "doc": "<h1><code>++dum</code></h1>\n<p>Parse decimal with leading <code>0</code></p>\n<p>Parsing rule. Parses a decmial number with leading zeroes.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  dum  (bass 10 (plus sid:ab))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"52\" dum:ag)\nq=52\n&gt; (scan \"0000052\" dum:ag)\nq=52\n&gt; (scan \"13507\" dim:ag)\nq=13.507\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fed"
        ],
        "doc": "<h1><code>++fed</code></h1>\n<p>Parse phonetic base</p>\n<p>Parsing rule. Parses an atom of odor <code>@p</code>, the phonetic base.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  fed  ;~  pose\n             (bass 0x1.0000.0000.0000.0000 (most doh hyf:ab))\n             huf:ab\n             hif:ab\n             tiq:ab\n           ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"zod\" fed:ag)\n0\n&gt; (scan \"nec\" fed:ag)\n1\n&gt; (scan \"sondel\" fed:ag)\n9.636\n&gt; ~tillyn-nillyt\n~tillyn-nillyt\n&gt; (scan \"tillyn-nillyt\" fed:ag)\n3.569.565.175\n&gt; (scan \"tillyn-nillyt-tasfyn-partyv\" fed:ag)\n15.331.165.687.565.582.592\n&gt; (scan \"tillyn-nillyt-tasfyn-partyv--novweb-talrud-talmud-sonfyr\" fed:ag)\n282.810.089.790.159.633.869.501.053.313.363.681.181\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hex"
        ],
        "doc": "<h1><code>++hex</code></h1>\n<p>Parse hex</p>\n<p>Parsing rule. Parses a hexadecimal number</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  hex  (ape (bass 0x1.0000 ;~(plug qex:ab (star ;~(pfix dog qix:ab)))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"4\" hex:ag)\nq=4\n&gt; (scan \"1a\" hex:ag)\nq=26\n&gt; (scan \"3.ac8d\" hex:ag)\nq=240.781\n&gt; `@ux`(scan \"3.ac8d\" hex:ag)\n0x3.ac8d\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lip"
        ],
        "doc": "<h1><code>++lip</code></h1>\n<p>Parse IPv4 address</p>\n<p>Parsing rule. Parses an IPv4 address.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  lip  =+  tod=(ape ted:ab)\n           (bass 256 ;~(plug tod (stun [3 3] ;~(pfix dog tod))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"127.0.0.1\" lip:ag)\nq=2.130.706.433\n&gt; `@if`(scan \"127.0.0.1\" lip:ag)\n.127.0.0.1\n&gt; `@if`(scan \"8.8.8.8\" lip:ag)\n.8.8.8.8\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "viz"
        ],
        "doc": "<h1><code>++viz</code></h1>\n<p>Parse Base-32 with dots</p>\n<p>Parsing rule. Parses a Base-32 number with dot separators.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  viz  (ape (bass 0x200.0000 ;~(plug pev:ab (star ;~(pfix dog piv:ab)))))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"e2.ol4pm\" viz:ag)\nq=15.125.353.270\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "vum"
        ],
        "doc": "<h1><code>++vum</code></h1>\n<p>Parse base-32 string</p>\n<p>Parsing rule. Parses a raw base-32 string.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  vum  (bass 32 (plus siv:ab))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"e2ol4pm\" vum:ag)\nq=15.125.353.270\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wiz"
        ],
        "doc": "<h1><code>++wiz</code></h1>\n<p>Parse base-64</p>\n<p>Parsing rule. Parses a base-64 number.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  wiz  (ape (bass 0x4000.0000 ;~(plug pew:ab (star ;~(pfix dog piw:ab)))))\n  --\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"e2O.l4Xpm\" wiz:ag)\nq=61.764.130.813.526\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mu"
        ],
        "doc": "<h1><code>++mu</code></h1>\n<p>Core used to scramble 16-bit atoms</p>\n<p>A door that contains arms that are used to scramble two atoms, <code>top</code>\nand <code>bot</code>. Used especially in the phonetic base to disguise the\nrelationship between a destroyer and its cruiser.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>bot</code> is an atom.</p>\n<p><code>top</code> is an atom.</p>\n<h2>Source</h2>\n<pre><code>++  mu\n  |_  [top/@ bot/@]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ~(. mu 0x20e5 0x5901)\n&lt;3.sjm [[@ux @ux] &lt;414.hhh 100.xkc 1.ypj %164&gt;]&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zag"
        ],
        "doc": "<h1><code>++zag</code></h1>\n<p>Add bottom into top</p>\n<p>Produces the cell of <code>top</code> and <code>bot</code> with <code>top</code> scrambled to the result\nof adding <code>bot</code> to <code>top</code> modulo 16. Used to scramble the name of a\ndestroyer.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>bot</code> is an atom.</p>\n<p><code>top</code> is an atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  zag  [p=(end 4 1 (add top bot)) q=bot]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `[@ux @ux]`~(zag mu 0x20e0 0x201)\n[0x22e1 0x201]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zig"
        ],
        "doc": "<h1><code>++zig</code></h1>\n<p>Subtract bottom from top</p>\n<p>The inverse of <code>++zag</code>. Produces the cell of <code>top</code> and <code>bot</code> with\n<code>top</code> unscrambled. The unscrambled <code>top</code> is the sum of the sample <code>top</code>\nand the 16-bit complement of <code>bot</code>. Used to unscramble the name of the\ndestroyer.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>bot</code> is an atom.</p>\n<p><code>top</code> is an atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  zig  [p=(end 4 1 (add top (sub 0x1.0000 bot))) q=bot]\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `[@ux @ux]`~(zig mu 0x2f46 0x1042)\n[0x1f04 0x1042]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zug"
        ],
        "doc": "<h1><code>++zug</code></h1>\n<p>Concatenate into atom</p>\n<p>Produces the concatenation of <code>top</code> and <code>bot</code>. Used to assemble a\ndestroyer name.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>bot</code> is an atom.</p>\n<p><code>top</code> is an atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  zug  (mix (lsh 4 1 top) bot)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@ux`~(zug mu 0x10e1 0xfa)\n0x10e1.00fa\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ne"
        ],
        "doc": "<h1><code>++ne</code></h1>\n<p>Digit rendering engine</p>\n<p>A door containing arms that render digits at bases 10, 16, 32, and\n64.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>tig</code> is an <code>atom</code>.</p>\n<h2>Source</h2>\n<pre><code>++  ne\n  |_  tig/@\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ~(. ne 20)\n&lt;4.gut [@ud &lt;414.hhh 100.xkc 1.ypj %164&gt;]&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "d"
        ],
        "doc": "<h1><code>++d</code></h1>\n<p>Render decimal</p>\n<p>Renders a decimal digit as an atom of an ACII byte value.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>tig</code> is an <code>atom</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  d  (add tig '0')\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`~(d ne 7)\n'7'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "x"
        ],
        "doc": "<h1><code>++x</code></h1>\n<p>Render hex</p>\n<p>Renders a hexadecimal digit as an atom of an ASCII byte value.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>tig</code> is an <code>atom</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  x  ?:((gte tig 10) (add tig 87) d)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`~(x ne 7)\n'7'\n&gt; `@t`~(x ne 14)\n'e'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "v"
        ],
        "doc": "<h1><code>++v</code></h1>\n<p>Render base-32</p>\n<p>Renders a base-32 digit as an atom of an ASCII byte value.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  v  ?:((gte tig 10) (add tig 87) d)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`~(v ne 7)\n'7'\n&gt; `@t`~(v ne 14)\n'e'\n&gt; `@t`~(v ne 25)\n'p'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "w"
        ],
        "doc": "<h1><code>++w</code></h1>\n<p>Render base-64</p>\n<p>Renders a base-64 digit as an atom of an ASCII byte value.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>tig</code> is an <code>atom</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  w  ?:(=(tig 63) '~' ?:(=(tig 62) '-' ?:((gte tig 36) (add tig 29) x)))\n  --\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@t`~(w ne 7)\n'7'\n&gt; `@t`~(w ne 14)\n'e'\n&gt; `@t`~(w ne 25)\n'p'\n&gt; `@t`~(w ne 52)\n'Q'\n&gt; `@t`~(w ne 61)\n'Z'\n&gt; `@t`~(w ne 63)\n'~'\n&gt; `@t`~(w ne 62)\n'-'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "co"
        ],
        "doc": "<h1><code>++co</code></h1>\n<p>Literal rendering engine</p>\n<p>A door that contains arms that operate on the sample coin <code>lot</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>lot</code> is a <code>++coin</code>.</p>\n<h2>Source</h2>\n<pre><code>++  co  !.\n  ~%  %co  ..co  ~\n  =&lt;  |_  lot/coin\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; &lt; 3.nta\n    { lot/{$many {$~ $ta @t} {$~ $ud @ud} $~}\n      &lt;10.cfg 4.jjn {rep/\"\" &lt;402.arm 110.jyx 1.ztu $151&gt;}&gt;\n    }\n    &gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rear"
        ],
        "doc": "<h1><code>++rear</code></h1>\n<p>Prepend &amp; render as tape</p>\n<p>Renders a coin <code>lot</code> as a tape prepended to the sample tape <code>rom</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>rom</code> is a <code>pe</code></p>\n<p><code>lot</code> is a <code>++coin</code>.</p>\n<h2>Source</h2>\n<pre><code>      ++  rear  |=(rom/tape =&gt;(.(rex rom) rend))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (~(rear co %$ %ux 200) \"--ha\")\n\"0xc8--ha\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rent"
        ],
        "doc": "<h1><code>++rent</code></h1>\n<p>Render as span</p>\n<p>Renders a coin <code>lot</code> as a span.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>lot</code> is a <code>++coin</code>.</p>\n<h2>Source</h2>\n<pre><code>      ++  rent  `@ta`(rap 3 rend)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ~(rent co %$ %ux 200)\n~.0xc8\n&gt; `@t`~(rent co %$ %ux 200)\n'0xc8'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "rend"
        ],
        "doc": "<h1><code>++rend</code></h1>\n<p>Render as tape</p>\n<p>Renders a coin <code>lot</code> as a tape.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p><code>lot</code> is a <code>++coin</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  rend\n    ^-  tape\n    ?:  ?=($blob -.lot)\n      ['~' '0' ((v-co 1) (jam p.lot))]\n    ?:  ?=($many -.lot)\n      :-  '.'\n      |-  ^-  tape\n      ?~   p.lot\n        ['_' '_' rep]\n      ['_' (weld (trip (wack rent(lot i.p.lot))) $(p.lot t.p.lot))]\n    =+  [yed=(end 3 1 p.p.lot) hay=(cut 3 [1 1] p.p.lot)]\n    |-  ^-  tape\n    ?+    yed  (z-co q.p.lot)\n        $c   ['~' '-' (weld (rip 3 (wood (tuft q.p.lot))) rep)]\n        $d\n      ?+    hay  (z-co q.p.lot)\n          $a\n        =+  yod=(yore q.p.lot)\n        =&gt;  ^+(. .(rep ?~(f.t.yod rep ['.' (s-co f.t.yod)])))\n        =&gt;  ^+  .\n            %=    .\n                rep\n              ?:  &amp;(=(~ f.t.yod) =(0 h.t.yod) =(0 m.t.yod) =(0 s.t.yod))\n                rep\n              =&gt;  .(rep ['.' (y-co s.t.yod)])\n              =&gt;  .(rep ['.' (y-co m.t.yod)])\n              ['.' '.' (y-co h.t.yod)]\n            ==\n        =&gt;  .(rep ['.' (a-co d.t.yod)])\n        =&gt;  .(rep ['.' (a-co m.yod)])\n        =&gt;  .(rep ?:(a.yod rep ['-' rep]))\n        ['~' (a-co y.yod)]\n      ::\n          $r\n        =+  yug=(yell q.p.lot)\n        =&gt;  ^+(. .(rep ?~(f.yug rep ['.' (s-co f.yug)])))\n        :-  '~'\n        ?:  &amp;(=(0 d.yug) =(0 m.yug) =(0 h.yug) =(0 s.yug))\n          ['s' '0' rep]\n        =&gt;  ^+(. ?:(=(0 s.yug) . .(rep ['.' 's' (a-co s.yug)])))\n        =&gt;  ^+(. ?:(=(0 m.yug) . .(rep ['.' 'm' (a-co m.yug)])))\n        =&gt;  ^+(. ?:(=(0 h.yug) . .(rep ['.' 'h' (a-co h.yug)])))\n        =&gt;  ^+(. ?:(=(0 d.yug) . .(rep ['.' 'd' (a-co d.yug)])))\n        +.rep\n      ==\n    ::\n        $f\n      ?:  =(&amp; q.p.lot)\n        ['.' 'y' rep]\n      ?:(=(| q.p.lot) ['.' 'n' rep] (z-co q.p.lot))\n    ::\n        $n   ['~' rep]\n        $i\n      ?+  hay  (z-co q.p.lot)\n        $f  ((ro-co [3 10 4] |=(a/@ ~(d ne a))) q.p.lot)\n        $s  ((ro-co [4 16 8] |=(a/@ ~(x ne a))) q.p.lot)\n      ==\n    ::\n        $p\n      =+  dyx=(met 3 q.p.lot)\n      :-  '~'\n      ?:  (lte dyx 1)\n        (weld (trip (tod:po q.p.lot)) rep)\n      ?:  =(2 dyx)\n        ;:  weld\n          (trip (tos:po (end 3 1 q.p.lot)))\n          (trip (tod:po (rsh 3 1 q.p.lot)))\n          rep\n        ==\n      =+  [dyz=(met 5 q.p.lot) fin=| dub=&amp;]\n      |-  ^-  tape\n      ?:  =(0 dyz)\n        rep\n      %=    $\n          fin      &amp;\n          dub      !dub\n          dyz      (dec dyz)\n          q.p.lot  (rsh 5 1 q.p.lot)\n          rep\n        =+  syb=(wren:un (end 5 1 q.p.lot))\n        =+  cog=~(zig mu [(rsh 4 1 syb) (end 4 1 syb)])\n        ;:  weld\n          (trip (tos:po (end 3 1 p.cog)))\n          (trip (tod:po (rsh 3 1 p.cog)))\n          `tape`['-' ~]\n          (trip (tos:po (end 3 1 q.cog)))\n          (trip (tod:po (rsh 3 1 q.cog)))\n          `tape`?.(fin ~ ['-' ?.(dub ~ ['-' ~])])\n          rep\n        ==\n      ==\n    ::\n        $r\n      ?+  hay  (z-co q.p.lot)\n        $d  ['.' '~' (r-co (rlyd q.p.lot))]\n        $h  ['.' '~' '~' (r-co (rlyh q.p.lot))]\n        $q  ['.' '~' '~' '~' (r-co (rlyq q.p.lot))]\n        $s  ['.' (r-co (rlys q.p.lot))]\n      ==\n    ::\n        $u\n      ?:  ?=($c hay)\n        %+  welp  ['0' 'c' (reap (pad:fa q.p.lot) '1')]\n        (c-co (enc:fa q.p.lot))\n      =-  (weld p.gam ?:(=(0 q.p.lot) `tape`['0' ~] q.gam))\n      ^=  gam  ^-  {p/tape q/tape}\n      ?+  hay  [~ ((ox-co [10 3] |=(a/@ ~(d ne a))) q.p.lot)]\n        $b  [['0' 'b' ~] ((ox-co [2 4] |=(a/@ ~(d ne a))) q.p.lot)]\n        $i  [['0' 'i' ~] ((d-co 1) q.p.lot)]\n        $x  [['0' 'x' ~] ((ox-co [16 4] |=(a/@ ~(x ne a))) q.p.lot)]\n        $v  [['0' 'v' ~] ((ox-co [32 5] |=(a/@ ~(x ne a))) q.p.lot)]\n        $w  [['0' 'w' ~] ((ox-co [64 5] |=(a/@ ~(w ne a))) q.p.lot)]\n      ==\n    ::\n        $s\n      %+  weld\n        ?:((syn:si q.p.lot) \"--\" \"-\")\n      $(yed 'u', q.p.lot (abs:si q.p.lot))\n    ::\n        $t\n      ?:  =('a' hay)\n        ?:  =('s' (cut 3 [2 1] p.p.lot))\n          (weld (rip 3 q.p.lot) rep)\n        ['~' '.' (weld (rip 3 q.p.lot) rep)]\n      ['~' '~' (weld (rip 3 (wood q.p.lot)) rep)]\n    ==\n  --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ~(rend co ~ %ux 200)\n\"0xc8\"\n&gt; ~(rend co %many ~[[%$ ux+200] [%$ p+40]])\n\"._0xc8_~~tem__\"\n&gt; ~(rend co ~ %p 32.819)\n\"~pillyt\"\n&gt; ~(rend co ~ %ux 18)\n\"0x12\"\n&gt; ~(rend co [~ p=[p=%if q=0x7f00.0001]])\n\".127.0.0.1\"\n&gt; `@ux`.127.0.0.1\n2.130.706.433\n&gt; ~(rend co %many ~[[~ %ud 20] [~ %uw 133] [~ %tas 'sam']])\n\"._20_0w25_sam__\"\n&gt; ~(rend co %blob [1 1])\n\"~0ph\"\n&gt; ~0ph\n[1 1]\n&gt; `@uv`(jam [1 1])\n0vph\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "alf"
        ],
        "doc": "<h1><code>++alf</code></h1>\n<p>Alphabetic characters</p>\n<p>Parse alphabetic characters, both upper and lowercase.</p>\n<h2>Source</h2>\n<pre><code>++  alf  ;~(pose low hig)                               ::  alphabetic\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"a\" alf)\n    ~~a\n    &gt; (scan \"A\" alf)\n    ~~~41.\n    &gt; (scan \"AaBbCc\" (star alf))\n    \"AaBbCc\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "aln"
        ],
        "doc": "<h1><code>++aln</code></h1>\n<p>Alphanumeric characters</p>\n<p>Parse alphanumeric characters - both alphabetic characters and numbers.</p>\n<h2>Source</h2>\n<pre><code>++  aln  ;~(pose low hig nud)                           ::  alphanumeric\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"0\" aln)\n    ~~0\n    &gt; (scan \"alf42\" (star aln))\n    \"alf42\"\n    &gt; (scan \"0123456789abcdef\" (star aln))\n    \"0123456789abcdef\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "alp"
        ],
        "doc": "<h1><code>++alp</code></h1>\n<p>Alphanumeric and <code>-</code></p>\n<p>Parse alphanumeric strings and hep, \"-\".</p>\n<h2>Source</h2>\n<pre><code>++  alp  ;~(pose low hig nud hep)                       ::  alphanumeric and -\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"7\" alp)\n    ~~7\n    &gt; (scan \"s\" alp)\n    ~~s\n    &gt; (scan \"123abc-\" (star alp))\n    \"123abc-\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bet"
        ],
        "doc": "<h1><code>++bet</code></h1>\n<p>Axis syntax <code>-</code>, <code>+</code></p>\n<p>Parse the hep and lus axis syntax.</p>\n<h2>Source</h2>\n<pre><code>++  bet  ;~(pose (cold 2 hep) (cold 3 lus))             ::  axis syntax - +\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"-\" bet)\n    2\n    &gt; (scan \"+\" bet)\n    3\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bin"
        ],
        "doc": "<h1><code>++bin</code></h1>\n<p>Binary to atom</p>\n<p>Parse a tape of binary (0s and 1s) and produce its atomic representation.</p>\n<h2>Source</h2>\n<pre><code>++  bin  (bass 2 (most gon but))                        ::  binary to atom\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"0000\" bin)\n    0\n    &gt; (scan \"0001\" bin)\n    1\n    &gt; (scan \"0010\" bin)\n    2\n    &gt; (scan \"100000001111\" bin)\n    2.063\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "but"
        ],
        "doc": "<h1><code>++but</code></h1>\n<p>Binary digit</p>\n<p>Parse a single binary digit.</p>\n<h2>Source</h2>\n<pre><code>++  but  (cook |=(a=@ (sub a '0')) (shim '0' '1'))      ::  binary digit\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"0\" but)\n    0\n    &gt; (scan \"1\" but)\n    1\n    &gt; (scan \"01\" but)\n    ! {1 2}\n    ! 'syntax-error'\n    ! exit\n    &gt; (scan \"01\" (star but))\n    ~[0 1]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "cit"
        ],
        "doc": "<h1><code>++cit</code></h1>\n<p>Octal digit</p>\n<p>Parse a single octal digit.</p>\n<h2>Source</h2>\n<pre><code>++  cit  (cook |=(a=@ (sub a '0')) (shim '0' '7'))      ::  octal digit\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"1\" cit)\n    1\n    &gt; (scan \"7\" cit)\n    7\n    &gt; (scan \"8\" cit)\n    ! {1 1}\n    ! 'syntax-error'\n    ! exit\n    &gt; (scan \"60\" (star cit))\n    ~[6 0]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dem"
        ],
        "doc": "<h1><code>++dem</code></h1>\n<p>Decimal to atom</p>\n<p>Parse a decimal number to an atom.</p>\n<h2>Source</h2>\n<pre><code>++  dem  (bass 10 (most gon dit))                       ::  decimal to atom\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"7\" dem)\n    7\n    &gt; (scan \"42\" dem)\n    42\n    &gt; (scan \"150000000\" dem)\n    150.000.000\n    &gt; (scan \"12456\" dem)\n    12.456\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dit"
        ],
        "doc": "<h1><code>++dit</code></h1>\n<p>Decimal digit</p>\n<p>Parse a single decimal digit.</p>\n<h2>Source</h2>\n<pre><code>++  dit  (cook |=(a=@ (sub a '0')) (shim '0' '9'))      ::  decimal digit\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"7\" dit)\n    7\n    &gt; (scan \"42\" (star dit))\n    ~[4 2]\n    &gt; (scan \"26000\" (star dit))\n    ~[2 6 0 0 0]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dog"
        ],
        "doc": "<h1><code>++dog</code></h1>\n<p><code>.</code> optional gap</p>\n<p>Dot followed by an optional gap, used with numbers.</p>\n<h2>Source</h2>\n<pre><code>++  dog  ;~(plug dot gay)                               ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; 1.234.\n            703\n1.234.703\n&gt; (scan \"a.        \" ;~(pfix alf dog))\n[~~~. ~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "doh"
        ],
        "doc": "<h1><code>++doh</code></h1>\n<p><code>@p</code> separator</p>\n<p>Phonetic base phrase separator</p>\n<h2>Source</h2>\n<pre><code>++  doh  ;~(plug ;~(plug hep hep) gay)                  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; ~nopfel-botduc-nilnev-dolfyn--haspub-natlun-lodmur-holtyd\n~nopfel-botduc-nilnev-dolfyn--haspub-natlun-lodmur-holtyd\n/&gt; ~nopfel-botduc-nilnev-dolfyn--\n            haspub-natlun-lodmur-holtyd\n~nopfel-botduc-nilnev-dolfyn--haspub-natlun-lodmur-holtyd\n&gt; (scan \"--\" doh)\n[[~~- ~~-] ~]\n&gt; (scan \"--      \" doh)\n[[~~- ~~-] ~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dun"
        ],
        "doc": "<h1><code>++dun</code></h1>\n<p><code>--</code> to <code>~</code></p>\n<p>Parse phep, <code>--</code>, to null, <code>~</code>.</p>\n<h2>Source</h2>\n<pre><code>++  dun  (cold ~ ;~(plug hep hep))                      ::  -- (phep) to ~\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"--\" dun)\n~\n&gt; (dun [[1 1] \"--\"])\n[p=[p=1 q=3] q=[~ u=[p=~ q=[p=[p=1 q=3] q=\"\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "duz"
        ],
        "doc": "<h1><code>++duz</code></h1>\n<p><code>==</code> to <code>~</code></p>\n<p>Parse stet, <code>==</code>, to null <code>~</code>.</p>\n<h2>Source</h2>\n<pre><code>++  duz  (cold ~ ;~(plug tis tis))                      ::  == (stet) to ~\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"==\" duz)\n~\n&gt; (duz [[1 1] \"== |=...\"])\n[p=[p=1 q=3] q=[~ u=[p=~ q=[p=[p=1 q=3] q=\" |=...\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gah"
        ],
        "doc": "<h1><code>++gah</code></h1>\n<p>Newline or ' '</p>\n<p>Whitespace component, either newline or space.</p>\n<h2>Source</h2>\n<pre><code>++  gah  (mask [`@`10 ' ' ~])                           ::  newline or ace\n</code></pre>\n<h2>Examples</h2>\n<pre><code>/&gt; ^-  *  ::  show spaces\n            \"\"\"\n               -\n             -\n              -\n            \"\"\"\n[32 32 32 45 10 32 45 10 32 32 45 0]\n/&gt; ^-  *\n            \"\"\"\n\n            \"\"\"\n[32 32 32 10 32 10 32 32 0]\n/&gt; ^-  (list ,@)\n            %-  scan  :_  (star gah)\n            \"\"\"\n\n            \"\"\"\n~[32 32 32 10 32 10 32 32]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gap"
        ],
        "doc": "<h1><code>++gap</code></h1>\n<p>Plural whitespace</p>\n<p>Separates tall runes</p>\n<h2>Source</h2>\n<pre><code>++  gap  (cold ~ ;~(plug gaq (star ;~(pose vul gah))))  ::  plural whitespace\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gaq"
        ],
        "doc": "<h1><code>++gaq</code></h1>\n<p>End of line</p>\n<p>Two spaces, a newline, or comment.</p>\n<h2>Source</h2>\n<pre><code>++  gaq  ;~  pose                                       ::  end of line\n             (just `@`10)\n             ;~(plug gah ;~(pose gah vul))\n             vul\n         ==\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gaw"
        ],
        "doc": "<h1><code>++gaw</code></h1>\n<p>Classic whitespace</p>\n<p>Terran whitespace.</p>\n<h2>Source</h2>\n<pre><code>++  gaw  (cold ~ (star ;~(pose vul gah)))               ::  classic white\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gay"
        ],
        "doc": "<h1><code>++gay</code></h1>\n<p>Optional gap</p>\n<p>Optional gap.</p>\n<h2>Source</h2>\n<pre><code>++  gay  ;~(pose gap (easy ~))                          ::\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gon"
        ],
        "doc": "<h1><code>++gon</code></h1>\n<p>Long numbers</p>\n<p>Parse long numbers - Numbers which wrap around the shell with the line</p>\n<h2>Source</h2>\n<p>break     ++  gon  ;~(pose ;~(plug bas gay fas) (easy ~))         ::  long numbers \\ /</p>\n<h2>Examples</h2>\n<p>characters bas and fas.</p>\n<pre><code>    &gt; (scan \"\\\\/\" gon)\n    [~~~5c. ~ ~~~2f.]\n    &gt; (gon [[1 1] \"\\\\/\"])\n    [p=[p=1 q=3] q=[~ u=[p=[~~~5c. ~ ~~~2f.] q=[p=[p=1 q=3] q=\"\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "gul"
        ],
        "doc": "<h1><code>++gul</code></h1>\n<p>Axis syntax <code>&lt;</code> or <code>&gt;</code></p>\n<p>Parse the axis gal and gar axis syntax.</p>\n<h2>Source</h2>\n<pre><code>++  gul  ;~(pose (cold 2 gal) (cold 3 gar))             ::  axis syntax &lt; &gt;\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"&lt;\" gul)\n    2\n    &gt; (scan \"&gt;\" gul)\n    3\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hex"
        ],
        "doc": "<h1><code>++hex</code></h1>\n<p>Hex to atom</p>\n<p>Parse any hexadecimal number to an atom.</p>\n<h2>Source</h2>\n<pre><code>++  hex  (bass 16 (most gon hit))                       ::  hex to atom\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"a\" hex)\n    10\n    &gt; (scan \"A\" hex)\n    10\n    &gt; (scan \"2A\" hex)\n    42\n    &gt; (scan \"1ee7\" hex)\n    7.911\n    &gt; (scan \"1EE7\" hex)\n    7.911\n    &gt; (scan \"1EE7F7\" hex)\n    2.025.463\n    &gt; `@ux`(scan \"1EE7F7\" hex)\n    0x1e.e7f7\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hig"
        ],
        "doc": "<h1><code>++hig</code></h1>\n<p>Uppercase</p>\n<p>Parse a single uppercase letter.</p>\n<h2>Source</h2>\n<pre><code>++  hig  (shim 'A' 'Z')                                 ::  uppercase\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"G\" hig)\n    ~~~47.\n    &gt; `cord`(scan \"G\" hig)\n    'G'\n    &gt; (scan \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" (star hig))\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    &gt; (hig [[1 1] \"G\"])\n    [p=[p=1 q=2] q=[~ [p=~~~47. q=[p=[p=1 q=2] q=\"\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hit"
        ],
        "doc": "<h1><code>++hit</code></h1>\n<p>Hex digits</p>\n<p>Parse a single hexadecimal digit.</p>\n<h2>Source</h2>\n<pre><code>++  hit  ;~  pose                                       ::  hex digits\n           dit\n           (cook |=(a=char (sub a 87)) (shim 'a' 'f'))\n           (cook |=(a=char (sub a 55)) (shim 'A' 'F'))\n         ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"a\" hit)\n    10\n    &gt; (scan \"A\" hit)\n    10\n    &gt; (hit [[1 1] \"a\"])\n    [p=[p=1 q=2] q=[~ [p=10 q=[p=[p=1 q=2] q=\"\"]]]]\n    &gt; (scan \"2A\" (star hit))\n    ~[2 10]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "iny"
        ],
        "doc": "<h1><code>++iny</code></h1>\n<p>Indentation block</p>\n<p>Apply <code>++rule</code> to indented block starting at current column number, omitting\nthe leading whitespace.</p>\n<h2>Accepts</h2>\n<p><code>sef</code> is a <code>++rule</code></p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>++  inde  |*  sef/rule                                  :: indentation block\n  |=  nail  ^+  (sef)\n  =+  [har tap]=[p q]:+&lt;\n  =+  lev=(fil 3 (dec q.har) ' ')\n  =+  eol=(just `@t`10)\n  =+  =-  roq=((star ;~(pose prn ;~(sfix eol (jest lev)) -)) har tap)\n      ;~(simu ;~(plug eol eol) eol)\n  ?~  q.roq  roq\n  =+  vex=(sef har(q 1) p.u.q.roq)\n  =+  fur=p.vex(q (add (dec q.har) q.p.vex))\n  ?~  q.vex  vex(p fur)\n  =-  vex(p fur, u.q -)\n  :+  &amp;3.vex\n    &amp;4.vex(q.p (add (dec q.har) q.p.&amp;4.vex))\n  =+  res=|4.vex\n  |-  ?~  res  |4.roq\n  ?.  =(10 -.res)  [-.res $(res +.res)]\n  (welp [`@t`10 (trip lev)] $(res +.res))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"abc\" (iny (star ;~(pose prn (just `@`10)))))\n\"abc\"\n&gt; (scan \"abc\" (star ;~(pose prn (just `@`10))))\n\"abc\"\n&gt; (scan \"  abc\\0ade\" ;~(pfix ace ace (star ;~(pose prn (just `@`10)))))\n\"abc\n    de\"\n&gt; (scan \"  abc\\0ade\" ;~(pfix ace ace (iny (star ;~(pose prn (just `@`10))))))\n! {1 6}\n! exit\n&gt; (scan \"  abc\\0a  de\" ;~(pfix ace ace (iny (star ;~(pose prn (just `@`10))))))\n\"abc\n    de\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "low"
        ],
        "doc": "<h1><code>++low</code></h1>\n<p>Lowercase</p>\n<p>Parse a single lowercase letter.</p>\n<h2>Source</h2>\n<pre><code>++  low  (shim 'a' 'z')                                 ::  lowercase\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"g\" low)\n    ~~g\n    &gt; `cord`(scan \"g\" low)\n    'g'\n    &gt; (scan \"abcdefghijklmnopqrstuvwxyz\" (star low))\n    \"abcdefghijklmnopqrstuvwxyz\"\n    &gt; (low [[1 1] \"g\"])\n    [p=[p=1 q=2] q=[~ [p=~~g q=[p=[p=1 q=2] q=\"\"]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mes"
        ],
        "doc": "<h1><code>++mes</code></h1>\n<p>Hexbyte</p>\n<p>Parse a hexbyte.</p>\n<h2>Source</h2>\n<pre><code>++  mes  %+  cook                                       ::  hexbyte\n           |=({a/@ b/@} (add (mul 16 a) b))\n         ;~(plug hit hit)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>    &gt; (scan \"2A\" mes)\n    42\n    &gt; (mes [[1 1] \"2A\"])\n    [p=[p=1 q=3] q=[~ u=[p=42 q=[p=[p=1 q=3] q=\"\"]]]]\n    &gt; (scan \"42\" mes)\n    66\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "nix"
        ],
        "doc": "<h1><code>++nix</code></h1>\n<p>Letters and <code>-</code></p>\n<p>Parse Letters and <code>-</code>.</p>\n<h2>Source</h2>\n<pre><code>++  nix  (boss 256 (star ;~(pose aln cab)))             ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"as_me\" nix)\nq=435.626.668.897\n&gt; `@t`(scan \"as_me\" nix)\n'as_me'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "nud"
        ],
        "doc": "<h1><code>++nud</code></h1>\n<p>Numeric</p>\n<p>Parse a numeric character - A number.</p>\n<h2>Source</h2>\n<pre><code>++  nud  (shim '0' '9')                                 ::  numeric\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"0\" nud)\n~~0\n&gt; (scan \"7\" nud)\n~~7\n&gt; (nud [[1 1] \"1\"])\n[p=[p=1 q=2] q=[~ [p=~~1 q=[p=[p=1 q=2] q=\"\"]]]]\n&gt; (scan \"0123456789\" (star nud))\n\"0123456789\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "prn"
        ],
        "doc": "<h1><code>++prn</code></h1>\n<p>Printable character</p>\n<p>Parse any printable character.</p>\n<h2>Source</h2>\n<pre><code>++  prn  ;~(less (just `@`127) (shim 32 256))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"h\" prn)\n~~h\n&gt; (scan \"!\" prn)\n~~~21.\n&gt; (scan \"\\01\" prn)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qit"
        ],
        "doc": "<h1><code>++qit</code></h1>\n<p>Chars in cord</p>\n<p>Parse an individual character to its cord atom representation.</p>\n<h2>Source</h2>\n<pre><code>++  qit  ;~  pose                                       ::  chars in a cord\n             ;~(less bas soq prn)\n             ;~(pfix bas ;~(pose bas soq mes))          ::  escape chars\n         ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"%\" qit)\n37\n&gt; `@t`(scan \"%\" qit)\n'%'\n&gt; (scan \"0\" qit)\n48\n&gt; (scan \"E\" qit)\n69\n&gt; (scan \"a\" qit)\n97\n&gt; (scan \"\\\\0a\" qit)\n10\n&gt; `@ux`(scan \"\\\\0a\" qit)\n0xa\n&gt; (scan \"cord\" (star qit))\n~[99 111 114 100]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qit"
        ],
        "doc": "<h1><code>++qit</code></h1>\n<p>Chars in cord</p>\n<p>Parse an individual character to its cord atom representation.</p>\n<h2>Source</h2>\n<pre><code>++  qit  ;~  pose                                       ::  chars in a cord\n             ;~(less bas soq prn)\n             ;~(pfix bas ;~(pose bas soq mes))          ::  escape chars\n         ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"%\" qit)\n37\n&gt; `@t`(scan \"%\" qit)\n'%'\n&gt; (scan \"0\" qit)\n48\n&gt; (scan \"E\" qit)\n69\n&gt; (scan \"a\" qit)\n97\n&gt; (scan \"\\\\0a\" qit)\n10\n&gt; `@ux`(scan \"\\\\0a\" qit)\n0xa\n&gt; (scan \"cord\" (star qit))\n~[99 111 114 100]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "qut"
        ],
        "doc": "<h1><code>++qut</code></h1>\n<p>Cord</p>\n<p>Parse single-soq cord with <code>\\{gap}/</code> anywhere in the middle, or triple-single\nquote (aka triple-soq) cord, between which must be in an indented block.</p>\n<h2>Source</h2>\n<pre><code> ++  qut  ;~  pose                                       ::  cord\n             ;~  less  soqs\n               (ifix [soq soq] (boss 256 (more gon qit)))\n             ==\n             %-  inde  %+  ifix\n               :-  ;~  plug  soqs\n                     ;~(pose ;~(plug (plus ace) vul) (just '\\0a'))\n                   ==\n               ;~(plug (just '\\0a') soqs)\n             (boss 256 (star qat))\n         ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"'cord'\" qut)\nq=1.685.221.219\n&gt; 'cord'\n'cord'\n&gt; `@ud`'cord'\n1.685.221.219\n/&gt; '''\n            Heredoc isn't prohibited from containing quotes\n            '''\n'Heredoc isn't prohibited from containing quotes'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "soz"
        ],
        "doc": "<h1><code>++soz</code></h1>\n<p>Delimiting <code>'''</code></p>\n<p>Parse a triple-single quote, used for multiline strings.</p>\n<h2>Source</h2>\n<pre><code>++  soz  ;~(plug soq soq soq)                          ::  delimiting '''\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"'''\" soz)\n[~~~27. ~~~27. ~~~27.]\n&gt; (rash '\"\"\"' soz)\n! {1 1}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sym"
        ],
        "doc": "<h1><code>++sym</code></h1>\n<p>Term</p>\n<p>A term: a letter(lowercase), followed by letters, numbers, or <code>-</code>.</p>\n<h2>Source</h2>\n<pre><code>++  sym\n  %+  cook\n    |=(a=tape (rap 3 ^-((list ,@) a)))\n  ;~(plug low (star ;~(pose nud low hep)))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"sam-2\" sym)\n215.510.507.891\n&gt; `@t`(scan \"sam-2\" sym)\n'sam-2'\n&gt; (scan \"sym\" sym)\n7.174.515\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ven"
        ],
        "doc": "<h1><code>++ven</code></h1>\n<p><code>+&gt;-</code> axis syntax</p>\n<p>Axis syntax parser</p>\n<h2>Source</h2>\n<pre><code>++  ven  ;~  (comp |=({a/@ b/@} (peg a b)))             ::  +&gt;- axis syntax\n           bet\n           =+  hom=`?`|\n           |=  tub/nail\n           ^-  (like axis)\n           =+  vex=?:(hom (bet tub) (gul tub))\n           ?~  q.vex\n             [p.tub [~ 1 tub]]\n           =+  wag=$(p.tub p.vex, hom !hom, tub q.u.q.vex)\n           ?&gt;  ?=(^ q.wag)\n           [p.wag [~ (peg p.u.q.vex p.u.q.wag) q.u.q.wag]]\n         ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/arvo=/hoon/hoon&gt; (scan \"-&gt;+\" ven)\n11\n~zod/arvo=/hoon/hoon&gt; `@ub`(scan \"-&gt;+\" ven)\n0b1011\n~zod/arvo=/hoon/hoon&gt; (peg (scan \"-&gt;\" ven) (scan \"+\" ven))\n11\n~zod/arvo=/hoon/hoon&gt; -&gt;+:[[1 2 [3 4]] 5]\n[3 4]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "vit"
        ],
        "doc": "<h1><code>++vit</code></h1>\n<p>Base64 digit</p>\n<p>Parse a standard base64 digit.</p>\n<h2>Source</h2>\n<pre><code>++  vit                                                 ::  base64 digit\n  ;~  pose\n    (cook |=(a/@ (sub a 65)) (shim 'A' 'Z'))\n    (cook |=(a/@ (sub a 71)) (shim 'a' 'z'))\n    (cook |=(a/@ (add a 4)) (shim '0' '9'))\n    (cold 62 (just '-'))\n    (cold 63 (just '+'))\n  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/arvo=/hoon/hoon&gt; (scan \"C\" vit)\n2\n~zod/arvo=/hoon/hoon&gt; (scan \"c\" vit)\n28\n~zod/arvo=/hoon/hoon&gt; (scan \"2\" vit)\n54\n~zod/arvo=/hoon/hoon&gt; (scan \"-\" vit)\n62\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "vul"
        ],
        "doc": "<h1><code>++vul</code></h1>\n<p>Comments to null</p>\n<h2>Source</h2>\n<pre><code>++  vul  %+  cold   ~                                   ::  comments\n         ;~  plug  col  col\n           (star prn)\n           (just `@`10)\n         ==\n</code></pre>\n<p>Parse comments and produce a null. Note that a comment must be ended\nwith a newline character.</p>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"::this is a comment \\0a\" vul)\n~\n&gt; (scan \"::this is a comment \" vul)\n! {1 21}\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "so"
        ],
        "doc": "<h1><code>++so</code></h1>\n<p>Coin parser engine</p>\n<p>Core containing arms that parse <code>++coin</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  so\n  |%\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; so\n&lt;10.mkn 414.hhh 100.xkc 1.ypj %164&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bisk"
        ],
        "doc": "<h1><code>++bisk</code></h1>\n<p>Parse odor-atom pair</p>\n<p>Parsing rule. Parses an unsigned integer of any permitted base,\nproducing a <code>++dime</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  bisk\n    ;~  pose\n      ;~  pfix  (just '0')\n        ;~  pose\n          (stag %ub ;~(pfix (just 'b') bay:ag))\n          (stag %ui ;~(pfix (just 'i') dim:ag))\n          (stag %ux ;~(pfix (just 'x') hex:ag))\n          (stag %uv ;~(pfix (just 'v') viz:ag))\n          (stag %uw ;~(pfix (just 'w') wiz:ag))\n        ==\n      ==\n      (stag %ud dem:ag)\n    ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"25\" bisk:so)\n[%ud q=25]\n&gt; (scan \"0x12.6401\" bisk:so)\n[%ux q=1.205.249]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "crub"
        ],
        "doc": "<h1><code>++crub</code></h1>\n<p>Parse <code>@da</code>, <code>@dr</code>, <code>@p</code>, <code>@t</code></p>\n<p>Parsing rule. Parses any atom of any of the following odors after a\nleading sig, <code>~</code> into a <code>++dime</code>: <code>@da</code>, <code>@dr</code>, <code>@p</code>,\nand <code>@t</code>, producing a <code>++dime</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  crub\n    ~+\n    ;~  pose\n      %+  cook\n        |=(det/date `dime`[%da (year det)])\n      ;~  plug\n        %+  cook\n          |=({a/@ b/?} [b a])\n        ;~(plug dim:ag ;~(pose (cold | hep) (easy &amp;)))\n        ;~(pfix dot dim:ag)   ::  month\n        ;~(pfix dot dim:ag)   ::  day\n        ;~  pose\n          ;~  pfix\n            ;~(plug dot dot)\n            ;~  plug\n              dum:ag\n              ;~(pfix dot dum:ag)\n              ;~(pfix dot dum:ag)\n              ;~(pose ;~(pfix ;~(plug dot dot) (most dot qix:ab)) (easy ~))\n            ==\n          ==\n          (easy [0 0 0 ~])\n        ==\n      ==\n    ::\n      %+  cook\n        |=  {a/(list {p/?($d $h $m $s) q/@}) b/(list @)}\n        =+  rop=`tarp`[0 0 0 0 b]\n        |-  ^-  dime\n        ?~  a\n          [%dr (yule rop)]\n        ?-  p.i.a\n          $d  $(a t.a, d.rop (add q.i.a d.rop))\n          $h  $(a t.a, h.rop (add q.i.a h.rop))\n          $m  $(a t.a, m.rop (add q.i.a m.rop))\n          $s  $(a t.a, s.rop (add q.i.a s.rop))\n        ==\n      ;~  plug\n        %+  most\n          dot\n        ;~  pose\n          ;~(pfix (just 'd') (stag %d dim:ag))\n          ;~(pfix (just 'h') (stag %h dim:ag))\n          ;~(pfix (just 'm') (stag %m dim:ag))\n          ;~(pfix (just 's') (stag %s dim:ag))\n        ==\n        ;~(pose ;~(pfix ;~(plug dot dot) (most dot qix:ab)) (easy ~))\n      ==\n    ::\n      (stag %p fed:ag)\n      ;~(pfix dot (stag %ta urs:ab))\n      ;~(pfix sig (stag %t urx:ab))\n      ;~(pfix hep (stag %c (cook turf urx:ab)))\n    ==\n  ++  nuck\n    ~/  %nuck  |=  a/nail  %.  a\n    %+  knee  *coin  |.  ~+\n    %-  stew\n    ^.  stet  ^.  limo\n    :~  :-  ['a' 'z']  (cook |=(a/@ta [%$ %tas a]) sym)\n        :-  ['0' '9']  (stag %$ bisk)\n        :-  '-'        (stag %$ tash)\n        :-  '.'        ;~(pfix dot perd)\n        :-  '~'        ;~(pfix sig ;~(pose twid (easy [%$ %n 0])))\n    ==\n  ++  nusk\n    ~+\n    :(sear |=(a/@ta (rush a nuck)) wick urt:ab)\n  ++  perd\n    ~+\n    ;~  pose\n      (stag %$ zust)\n      (stag %many (ifix [cab ;~(plug cab cab)] (more cab nusk)))\n    ==\n  ++  royl\n    ~+\n    =+  ^=  moo\n      |=  a/tape\n      :-  (lent a)\n      (scan a (bass 10 (plus sid:ab)))\n    =+  ^=  voy\n      %+  cook  royl-cell\n      ;~  pose\n        ;~  plug\n          (easy %d)\n          ;~  pose  (cold | hep)  (easy &amp;)  ==\n          ;~  plug  dim:ag\n            ;~  pose\n              ;~(pfix dot (cook moo (plus (shim '0' '9'))))\n              (easy [0 0])\n            ==\n            ;~  pose\n              ;~  pfix\n                (just 'e')\n                ;~(plug ;~(pose (cold | hep) (easy &amp;)) dim:ag)\n              ==\n              (easy [&amp; 0])\n            ==\n          ==\n        ==\n        ;~  plug\n          (easy %i)\n          ;~  sfix\n            ;~  pose  (cold | hep)  (easy &amp;)  ==\n            (jest 'inf')\n          ==\n        ==\n        ;~  plug\n          (easy %n)\n          (cold ~ (jest 'nan'))\n        ==\n      ==\n    ;~  pose\n      (stag %rh (cook rylh ;~(pfix ;~(plug sig sig) voy)))\n      (stag %rq (cook rylq ;~(pfix ;~(plug sig sig sig) voy)))\n      (stag %rd (cook ryld ;~(pfix sig voy)))\n      (stag %rs (cook ryls voy))\n    ==\n  ::\n  ++  royl-cell\n    |=  rn\n    ^-  dn\n    ?.  ?=({$d *} +&lt;)  +&lt;\n    =+  ^=  h\n      (dif:si (new:si f.b i.b) (sun:si d.b))\n    [%d a h (add (mul c.b (pow 10 d.b)) e.b)]\n  ::\n  ++  tash\n    ~+\n    =+  ^=  neg\n        |=  {syn/? mol/dime}  ^-  dime\n        ?&gt;  =('u' (end 3 1 p.mol))\n        [(cat 3 's' (rsh 3 1 p.mol)) (new:si syn q.mol)]\n    ;~  pfix  hep\n      ;~  pose\n        (cook |=(a/dime (neg | a)) bisk)\n        ;~(pfix hep (cook |=(a/dime (neg &amp; a)) bisk))\n      ==\n    ==\n  ::\n  ++  twid\n    ~+\n    ;~  pose\n      (cook |=(a/@ [%blob (cue a)]) ;~(pfix (just '0') vum:ag))\n      (stag %$ crub)\n    ==\n  ::\n  ++  zust\n    ~+\n    ;~  pose\n      (stag %is bip:ag)\n      (stag %if lip:ag)\n      (stag %f ;~(pose (cold &amp; (just 'y')) (cold | (just 'n'))))\n      royl\n    ==\n  --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"1926.5.12\" crub:so)\n[p=~.da q=170.141.184.449.747.016.871.285.095.307.149.312.000]\n&gt; ([%da @da] (scan \"1926.5.12\" crub:so))\n[%da ~1926.5.12]\n&gt; (scan \"s10\" crub:so)\n[p=~.dr q=184.467.440.737.095.516.160]\n&gt; ([%dr @dr] (scan \"s10\" crub:so))\n[%dr ~s10]\n&gt; (scan \"doznec\" crub:so)\n[%p 256]\n&gt; (scan \".mas\" crub:so)\n[%ta 7.561.581]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "nuck"
        ],
        "doc": "<h1><code>++nuck</code></h1>\n<p>Top-level coin parser</p>\n<p>Parsing rule. Switches on the first character and applies the\ncorresponding <code>++coin</code> parser.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>    ++  nuck\n      ~/  %nuck  |=  a/nail  %.  a\n      %+  knee  *coin  |.  ~+\n      %-  stew\n      ^.  stet  ^.  limo\n      :~  :-  ['a' 'z']  (cook |=(a/@ta [%$ %tas a]) sym)\n          :-  ['0' '9']  (stag %$ bisk)\n          :-  '-'        (stag %$ tash)\n          :-  '.'        ;~(pfix dot perd)\n          :-  '~'        ;~(pfix sig ;~(pose twid (easy [%$ %n 0])))\n      ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"~pillyt\" nuck:so)\n[% p=[p=~.p q=32.819]]\n&gt; (scan \"0x12\" nuck:so)\n[% p=[p=~.ux q=18]]\n&gt; (scan \".127.0.0.1\" nuck:so)\n[% p=[p=~.if q=2.130.706.433]]\n&gt; `@ud`.127.0.0.1\n2.130.706.433\n&gt; (scan \"._20_0w25_sam__\" nuck:so)\n[ %many \n    p\n  ~[[% p=[p=~.ud q=20]] [% p=[p=~.uw q=133]] [% p=[p=~.tas q=7.168.371]]]\n]\n&gt; `@`%sam\n7.168.371\n&gt; (scan \"~0ph\" nuck:so)\n[%blob p=[1 1]]\n&gt; ~0ph\n[1 1]\n&gt; `@uv`(jam [1 1])\n0vph\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "nusk"
        ],
        "doc": "<h1><code>++nusk</code></h1>\n<p>Parse coin literal with escapes</p>\n<p>Parsing rule. Parses a coin literal with escapes. (See also: xx tuple\nformatting).</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  nusk\n    (sear |=(a/@ta (rush (wick a) nuck)) urt:ab)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; ~.asd_a\n~.asd_a\n&gt; ._1_~~.asd~-a__\n[1 ~.asd_a]\n&gt; (scan \"~~.asd~-a\" nusk:so)\n[% p=[p=~.ta q=418.212.246.369]]\n&gt; ([~ %ta @ta] (scan \"~~.asd~-a\" nusk:so))\n[~ %ta ~.asd_a]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "perd"
        ],
        "doc": "<h1><code>++perd</code></h1>\n<p>Parsing rule.</p>\n<p>Parsing rule. Parses a dime or tuple without their respective standard\nprefixes.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  perd\n    ;~  pose\n      (stag ~ zust)\n      (stag %many (ifix [cab ;~(plug cab cab)] (more cab nusk)))\n    ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"y\" perd:so)\n[~ [%f %.y]]\n&gt; (scan \"n\" perd:so)\n[~ [%f %.n]]\n&gt; |\n%.n\n&gt; (scan \"_20_x__\" perd:so)\n[%many [[% p=[p=~.ud q=20]] ~[[% p=[p=~.tas q=120]]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "royl"
        ],
        "doc": "<h1><code>++royl</code></h1>\n<p>Parse dime float</p>\n<p>Parsing rule. Parses a number into a <code>++dime</code> float.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<p>++  royl\n    ~+\n    =+  ^=  moo\n      |=  a/tape\n      :-  (lent a)\n      (scan a (bass 10 (plus sid:ab)))\n    =+  ^=  voy\n      %+  cook  royl-cell\n      ;~  pose\n        ;~  plug\n          (easy %d)\n          ;~  pose  (cold | hep)  (easy &amp;)  ==\n          ;~  plug  dim:ag\n            ;~  pose\n              ;~(pfix dot (cook moo (plus (shim '0' '9'))))</p>\n<pre><code>          (easy [0 0])\n        ==\n        ;~  pose\n          ;~  pfix\n            (just 'e')\n            ;~(plug ;~(pose (cold | hep) (easy &amp;)) dim:ag)\n          ==\n          (easy [&amp; 0])\n        ==\n      ==\n    ==\n    ;~  plug\n      (easy %i)\n      ;~  sfix\n        ;~  pose  (cold | hep)  (easy &amp;)  ==\n        (jest 'inf')\n      ==\n    ==\n    ;~  plug\n      (easy %n)\n      (cold ~ (jest 'nan'))\n    ==\n  ==\n;~  pose\n  (stag %rh (cook rylh ;~(pfix ;~(plug sig sig) voy)))\n  (stag %rq (cook rylq ;~(pfix ;~(plug sig sig sig) voy)))\n  (stag %rd (cook ryld ;~(pfix sig voy)))\n  (stag %rs (cook ryls voy))\n==\n</code></pre>\n<p>::</p>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"~3.14\" royl:so)\n[%rd .~3.13999999999999]\n&gt; .~3.14\n.~3.13999999999999\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "royl-cell"
        ],
        "doc": "<h1><code>++royl-cell</code></h1>\n<p>XX still not fully functional</p>\n<p>Intermediate parsed float convereter</p>\n<pre><code>  ++  royl-cell\n    |=  rn\n    ^-  dn\n    ?.  ?=({$d *} +&lt;)  +&lt;\n    =+  ^=  h\n      (dif:si (new:si f.b i.b) (sun:si d.b))\n    [%d a h (add (mul c.b (pow 10 d.b)) e.b)]\n  ::\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tash"
        ],
        "doc": "<h1><code>++tash</code></h1>\n<p>Parse signed dime</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<p>Parsing rule. Parses a signed number into a <code>++dime</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  tash\n    ~+\n    =+  ^=  neg\n        |=  {syn/? mol/dime}  ^-  dime\n        ?&gt;  =('u' (end 3 1 p.mol))\n        [(cat 3 's' (rsh 3 1 p.mol)) (new:si syn q.mol)]\n    ;~  pfix  hep\n      ;~  pose\n        (cook |=(a/dime (neg | a)) bisk)\n        ;~(pfix hep (cook |=(a/dime (neg &amp; a)) bisk))\n      ==\n    ==\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"-20\" tash:so)\n[p=~.sd q=39]\n&gt; (,[%sd @sd] (scan \"-20\" tash:so))\n[%sd -20]\n&gt; (,[%sd @sd] (scan \"--20\" tash:so))\n[%sd --20]\n&gt; (,[%sx @sx] (scan \"--0x2e\" tash:so))\n[%sx --0x2e]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "twid"
        ],
        "doc": "<h1><code>++twid</code></h1>\n<p>Parse coins without <code>~</code> prefix</p>\n<p>Parsing rule. Parses coins after a leading sig, <code>~</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  twid\n    ;~  pose\n      (cook |=(a/@ [%blob (cue a)]) ;~(pfix (just '0') vum:ag))\n      (stag ~ crub)\n    ==\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"zod\" twid:so)\n[~ [%p 0]]\n&gt; (scan \".sam\" twid:so)\n[~ [%ta 7.168.371]]\n&gt; `@ud`~.sam\n7.168.371\n&gt; `@t`~.sam\n'sam'\n&gt; (scan \"0ph\" twid:so)\n[%blob [1 1]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "zust"
        ],
        "doc": "<h1><code>++zust</code></h1>\n<p>Parse prefixed dimes from <code>@if</code>, <code>@f</code>, <code>@rd</code></p>\n<p>Parsing rule. Parses an atom of either <code>@if</code> (IP address), <code>@f</code>\n(loobean), or <code>rf</code>(floating point) into a <code>++dime</code>.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>  ++  zust\n    ;~  pose\n      (stag %is bip:ag)\n      (stag %if lip:ag)\n      (stag %f ;~(pose (cold &amp; (just 'y')) (cold | (just 'n'))))\n      royl\n    ==\n  --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"127.0.0.1\" zust:so)\n[%if q=2.130.706.433]\n&gt; (scan \"af.0.0.0.0.e7a5.30d2.7\" zust:so)\n[%is q=908.651.950.243.594.834.993.091.554.288.205.831]\n&gt; (,[%is @is] (scan \"af.0.0.0.0.e7a5.30d2.7\" zust:so))\n[%is .af.0.0.0.0.e7a5.30d2.7]\n&gt; (,[%is @ux] (scan \"af.0.0.0.0.e7a5.30d2.7\" zust:so))\n[%is 0xaf.0000.0000.0000.0000.e7a5.30d2.0007]\n&gt; (scan \"y\" zust:so)\n[%f %.y]\n&gt; (scan \"12.09\" zust:so)\n[%rd .~12.00999999999999]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "scot"
        ],
        "doc": "<h1><code>++scot</code></h1>\n<p>Render dime as cord</p>\n<p>Renders a dime <code>mol</code> as a cord.</p>\n<h2>Accepts</h2>\n<p><code>mol</code> is a <code>++dime</code>.</p>\n<h2>Produces</h2>\n<p>A <code>cord</code>.</p>\n<h2>Source</h2>\n<pre><code>++  scot  |=(mol/dime ~(rent co %$ mol))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scot %p ~pillyt)\n~.~pillyt\n&gt; `@t`(scot %p ~pillyt)\n'~pillyt'\n&gt; (scot %ux 0x12)\n~.0x12\n&gt; `@t`(scot %ux 0x12)\n'0x12'\n&gt; (scot %if .127.0.0.1)\n~..127.0.0.1\n&gt; `@t`(scot %if .127.0.0.1)\n'.127.0.0.1'\n&gt; (scot %ta ~.asd_a)\n~.~.asd_a\n&gt; `@t`(scot %ta ~.asd_a)\n'~.asd_a'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "scow"
        ],
        "doc": "<h1><code>++scow</code></h1>\n<p>Render dime as tape</p>\n<p>Renders a dime <code>mol</code> as a tape.</p>\n<h2>Accepts</h2>\n<p><code>mol</code> is a <code>++dime</code>.</p>\n<h2>Produces</h2>\n<p>A <code>tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  scow  |=(mol/dime ~(rend co %$ mol))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scow %p ~pillyt)\n\"~pillyt\"\n&gt; (scow %ux 0x12)\n\"0x12\"\n&gt; (scow %if .127.0.0.1)\n\".127.0.0.1\"\n&gt; (scow %ta ~.asd_a)\n\"~.asd_a\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "slat"
        ],
        "doc": "<h1><code>++slat</code></h1>\n<p>Curried slaw</p>\n<p>Produces a <code>gate</code> that parses a <code>term</code> <code>txt</code> to an atom of the\nodor specified by <code>mod</code>.</p>\n<h2>Accepts</h2>\n<p><code>mod</code> is a term, an atom of odor <code>@tas</code>.</p>\n<p><code>txt</code> is a cord, an atom of odor <code>@ta</code>.</p>\n<h2>Produces</h2>\n<p>A <code>gate</code>.</p>\n<h2>Source</h2>\n<pre><code>++  slat  |=(mod/@tas |=(txt/@ta (slaw mod txt)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `(unit @p)`((slat %p) '~pillyt')\n[~ ~pillyt]\n&gt; `(unit @ux)`((slat %ux) '0x12')\n[~ 0x12]\n&gt; `(unit @if)`((slat %if) '.127.0.0.1')\n[~ .127.0.0.1]\n&gt; `(unit @ta)`((slat %ta) '~.asd_a')\n[~ ~.asd_a\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "slav"
        ],
        "doc": "<h1><code>++slav</code></h1>\n<p>Demand: parse cord with input odor</p>\n<p>Parses a cord <code>txt</code> to an atom of the odor specificed by <code>mod</code>.\nCrashes if it fails to parse.</p>\n<h2>Accepts</h2>\n<p><code>mod</code> is a term, an atom of odor <code>@tas</code>.</p>\n<p><code>txt</code> is a cord, an atom of odor <code>@ta</code>.</p>\n<h2>Produces</h2>\n<p>The atom of a <code>(unit @)</code> from <code>++slaw</code>, or crash.</p>\n<h2>Source</h2>\n<pre><code>++  slav  |=([mod/@tas txt/@ta] (need (slaw mod txt)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `@p`(slav %p '~pillyt')\n~pillyt\n&gt; `@p`(slav %p '~pillam')\n! exit\n&gt; `@ux`(slav %ux '0x12')\n0x12\n&gt; `@ux`(slav %ux '0b10')\n! exit\n&gt; `@if`(slav %if '.127.0.0.1')\n.127.0.0.1\n&gt; `@if`(slav %if '.fe80.0.0.202')\n! exit\n&gt; `@ta`(slav %ta '~.asd_a')\n~.asd_a\n&gt; `@ta`(slav %ta '~~asd-a')\n! exit\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "slaw"
        ],
        "doc": "<h1><code>++slaw</code></h1>\n<p>Parse cord to input odor</p>\n<p>Parses a cord <code>txt</code> to an atom of the odor specified by <code>mod</code>.</p>\n<h2>Accepts</h2>\n<p><code>mod</code> is a term, an atom of odor <code>@tas</code>.</p>\n<p><code>txt</code> is a cord, an atom of odor <code>@ta</code>.</p>\n<h2>Produces</h2>\n<p>A <code>(unit @)</code>.</p>\n<h2>Source</h2>\n<pre><code>++  slaw\n  ~/  %slaw\n  |=  {mod/@tas txt/@ta}\n  ^-  (unit @)\n  =+  con=(slay txt)\n  ?.(&amp;(?=({$~ $$ @ @} con) =(p.p.u.con mod)) ~ [~ q.p.u.con])\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `(unit @p)`(slaw %p '~pillyt')\n[~ ~pillyt]\n&gt; `(unit @p)`(slaw %p '~pillam')\n~\n&gt; `(unit @ux)`(slaw %ux '0x12')\n[~ 0x12]\n&gt; `(unit @ux)`(slaw %ux '0b10')\n~\n&gt; `(unit @if)`(slaw %if '.127.0.0.1')\n[~ .127.0.0.1]\n&gt; `(unit @if)`(slaw %if '.fe80.0.0.202')\n~\n&gt; `(unit @ta)`(slaw %ta '~.asd_a')\n[~ ~.asd_a]\n&gt; `(unit @ta)`(slaw %ta '~~asd-a')\n~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "slay"
        ],
        "doc": "<h1><code>++slay</code></h1>\n<p>Parse cord to coin</p>\n<p>Parses a cord <code>txt</code> to the unit of a <code>++coin</code>.</p>\n<h2>Accepts</h2>\n<p><code>txt</code> is a <code>@ta</code>.</p>\n<h2>Produces</h2>\n<p>A <code>(unit coin)</code>.</p>\n<h2>Source</h2>\n<pre><code>    ++  slay\n      |=  txt/@ta  ^-  (unit coin)\n      =+  ^=  vex\n          ?:  (gth 0x7fff.ffff txt)                         ::  XX  petty cache\n            ~+  ((full nuck:so) [[1 1] (trip txt)])\n          ((full nuck:so) [[1 1] (trip txt)])\n      ?~  q.vex\n        ~\n      [~ p.u.q.vex]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (slay '~pillyt')\n[~ [% p=[p=~.p q=32.819]]]\n&gt; (slay '0x12')\n[~ [% p=[p=~.ux q=18]]]\n&gt; (slay '.127.0.0.1')\n[~ [% p=[p=~.if q=2.130.706.433]]]\n&gt; `@ud`.127.0.0.1\n2.130.706.433\n&gt; (slay '._20_0w25_sam__')\n[ ~\n  [ %many\n    p=~[[% p=[p=~.ud q=20]] [% p=[p=~.uw q=133]] [% p=[p=~.tas q=7.168.371]]]\n  ]\n]\n&gt; `@`%sam\n7.168.371\n&gt; (slay '~0ph')\n[~ [%blob p=[1 1]]]\n&gt; 0ph\n~ &lt;syntax error at [1 2]&gt;\n&gt; ~0ph\n[1 1]\n&gt; `@uv`(jam [1 1])\n0vph\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "smyt"
        ],
        "doc": "<h1><code>++smyt</code></h1>\n<p>Render path as tank</p>\n<p>Renders the path <code>bon</code> as a <code>tank</code>, which is used for\npretty-printing.</p>\n<h2>Accepts</h2>\n<p><code>bon</code> is a <code>++path</code>.</p>\n<h2>Produces</h2>\n<p>A <code>tank</code>.</p>\n<h2>Source</h2>\n<pre><code>++  smyt                                                ::  pretty print path\n  |=  bon/path  ^-  tank\n  :+  %rose  [['/' ~] ['/' ~] ~]\n  (turn bon |=(a/@ [%leaf (trip a)]))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (smyt %)\n[ %rose\n  p=[p=\"/\" q=\"/\" r=\"/\"]\n    q\n  ~[ [%leaf p=\"~zod\"]\n     [%leaf p=\"try\"] \n     [%leaf p=\"~2014.10.28..18.36.58..a280\"]\n   ]\n]\n&gt; (smyt /as/les/top)\n[ %rose\n  p=[p=\"/\" q=\"/\" r=\"/\"]\n  q=~[[%leaf p=\"as\"] [%leaf p=\"les\"] [%leaf p=\"top\"]]\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "spat"
        ],
        "doc": "<h1><code>++spat</code></h1>\n<p>Render path as cord</p>\n<p>Renders a path <code>pax</code> as cord.</p>\n<h2>Accepts</h2>\n<p><code>pax</code> is a <code>path</code>.</p>\n<h2>Produces</h2>\n<p>A <code>cord</code>.</p>\n<h2>Source</h2>\n<pre><code>++  spat  |=(pax/path (crip (spud pax)))               ::  path to cord\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (spat %)\n'~zod/try/~2014.10.28..18.40.20..4287'\n&gt; (spat %/bin)\n'~zod/try/~2014.10.28..18.41.12..3bcd/bin'\n&gt; (spat /as/les/top)\n'/as/les/top'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "spud"
        ],
        "doc": "<h1><code>++spud</code></h1>\n<p>Render path as tape</p>\n<p>Renders a path <code>pax</code> as tape.</p>\n<h2>Accepts</h2>\n<p><code>pax</code> is a <code>path</code>.</p>\n<h2>Produces</h2>\n<p>A <code>tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  spud  |=(pax/path ~(ram re (smyt pax)))             ::  path to tape\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (spud %)\n\"~zod/try/~2014.10.28..18.40.46..e951\"\n&gt; (spud %/bin)\n\"~zod/try/~2014.10.28..18.41.05..16f2/bin\"\n&gt; (spud /as/les/top)\n\"/as/les/top\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "stab"
        ],
        "doc": "<h1><code>++stab</code></h1>\n<p>Parse cord to path</p>\n<p>Parsing rule. Parses a cord <code>zep</code> to a static <code>++path</code>.\nCrashes if it fails to parse.</p>\n<h2>Accepts</h2>\n<p><code>zep</code> is a <code>@t</code>.</p>\n<h2>Produces</h2>\n<p>A <code>path</code>, or crash.</p>\n<h2>Source</h2>\n<pre><code>++  stab                                                ::  parse cord to path\n  =+  fel=;~(pfix fas (more fas urs:ab))\n  |=(zep/@t `path`(rash zep fel))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (stab '/as/lek/tor')\n/as/lek/tor\n&gt; `(pole ,@ta)`(stab '/as/lek/tor')\n[~.as [~.lek [~.tor ~]]]\n&gt; (stab '~zod/arvo/~2014.10.28..18.48.41..335f/zuse')\n~zod/arvo/~2014.10.28..18.48.41..335f/zuse\n&gt; `(pole ,@ta)`(stab '~zod/arvo/~2014.10.28..18.48.41..335f/zuse')\n[~.~zod [~.arvo [~.~2014.10.28..18.48.41..335f [~.zuse ~]]]]\n&gt; (stab '/a/~pillyt/pals/1')\n/a/~pillyt/pals/1\n&gt; `(pole ,@ta)`(stab '/a/~pillyt/pals/1')\n[~.a [~.~pillyt [~.pals [~.1 ~]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mack"
        ],
        "doc": "<h1><code>++mack</code></h1>\n<p>Nock subject to unit</p>\n<p>Accepts a nock subject-formula cell and wraps it into a <code>++unit</code>.\n<code>fol</code> is pure nock, meaning that nock <code>11</code> operations result in a block,\nproducing a <code>~</code>.</p>\n<h2>Accepts</h2>\n<p><code>sub</code> is a subject noun.</p>\n<p><code>fol</code> is a formula noun, which is generally a <code>++nock</code>.</p>\n<h2>Produces</h2>\n<p>The <code>++unit</code> of a noun.</p>\n<h2>Source</h2>\n<pre><code>++  mack\n  |=  {sub/* fol/*}\n  ^-  (unit)\n  =+  ton=(mink [sub fol] |=({* *} ~))\n  ?.(?=({$0 *} ton) ~ [~ p.ton])\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mack [[1 2 3] [0 1]])\n[~ [1 2 3]]\n&gt; (mack [41 4 0 1])\n[~ 42]\n&gt; (mack [4 0 4])\n~\n&gt; (mack [[[0 2] [1 3]] 4 4 4 4 0 5])\n[~ 6]\n&gt; ;;((unit @tas) (mack [[1 %yes %no] 6 [0 2] [0 6] 0 7]))\n[~ %no]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mink"
        ],
        "doc": "<h1><code>++mink</code></h1>\n<p>Mock interpreter</p>\n<p>Bottom-level mock (virtual nock) interpreter. Produces a\n<code>++tone</code>, a nock computation result. If nock 11 is invoked, <code>sky</code>\ncomputes on the subject and produces a <code>++unit</code> result. An empty\nresult becomes a <code>%1</code> <code>++tone</code>, indicating a block.</p>\n<h2>Accepts</h2>\n<p><code>sub</code> is the subject as a noun.</p>\n<p><code>fol</code> is the formula as a noun.</p>\n<p><code>sky</code> is an <code>%iron</code> gate invoked with nock operator 11.</p>\n<h2>Produces</h2>\n<p>A <code>++tone</code>.</p>\n<h2>Source</h2>\n<pre><code>++  mink\n  ~/  %mink\n  |=  {{sub/* fol/*} gul/$-({* *} (unit (unit)))}\n  =+  tax=*(list {@ta *})\n  |-  ^-  tone\n  ?@  fol\n    [%2 tax]\n  ?:  ?=(^ -.fol)\n    =+  hed=$(fol -.fol)\n    ?:  ?=($2 -.hed)\n      hed\n    =+  tal=$(fol +.fol)\n    ?-  -.tal\n      $0  ?-(-.hed $0 [%0 p.hed p.tal], $1 hed)\n      $1  ?-(-.hed $0 tal, $1 [%1 (weld p.hed p.tal)])\n      $2  tal\n    ==\n  ?+    fol\n    [%2 tax]\n  ::\n      {$0 b/@}\n    ?:  =(0 b.fol)  [%2 tax]\n    ?:  =(1 b.fol)  [%0 sub]\n    ?:  ?=(@ sub)   [%2 tax]\n    =+  [now=(cap b.fol) lat=(mas b.fol)]\n    $(b.fol lat, sub ?:(=(2 now) -.sub +.sub))\n  ::\n      {$1 b/*}\n    [%0 b.fol]\n  ::\n      {$2 b/{^ *}}\n    =+  ben=$(fol b.fol)\n    ?.  ?=($0 -.ben)  ben\n    ?&gt;(?=(^ p.ben) $(sub -.p.ben, fol +.p.ben))\n    ::?&gt;(?=(^ p.ben) $([sub fol] p.ben)\n  ::\n      {$3 b/*}\n    =+  ben=$(fol b.fol)\n    ?.  ?=($0 -.ben)  ben\n    [%0 .?(p.ben)]\n  ::\n      {$4 b/*}\n    =+  ben=$(fol b.fol)\n    ?.  ?=($0 -.ben)  ben\n    ?.  ?=(@ p.ben)  [%2 tax]\n    [%0 .+(p.ben)]\n  ::\n      {$5 b/*}\n    =+  ben=$(fol b.fol)\n    ?.  ?=($0 -.ben)  ben\n    ?.  ?=(^ p.ben)  [%2 tax]\n    [%0 =(-.p.ben +.p.ben)]\n  ::\n      {$6 b/* c/* d/*}\n    $(fol =&gt;(fol [2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]))\n  ::\n      {$7 b/* c/*}       $(fol =&gt;(fol [2 b 1 c]))\n      {$8 b/* c/*}       $(fol =&gt;(fol [7 [[0 1] b] c]))\n      {$9 b/* c/*}       $(fol =&gt;(fol [7 c 0 b]))\n      {$10 @ c/*}        $(fol c.fol)\n      {$10 {b/* c/*} d/*}\n    =+  ben=$(fol c.fol)\n    ?.  ?=($0 -.ben)  ben\n    ?:  ?=(?($hunk $hand $lose $mean $spot) b.fol)\n      $(fol d.fol, tax [[b.fol p.ben] tax])\n    $(fol d.fol)\n  ::\n      {$11 b/* c/*}\n    =+  ref=$(fol b.fol)\n    =+  ben=$(fol c.fol)\n    ?.  ?=($0 -.ref)  ref\n    ?.  ?=($0 -.ben)  ben\n    =+  val=(gul p.ref p.ben)\n    ?~(val [%1 p.ben ~] ?~(u.val [%2 [[%hunk (mush p.ben)] tax]] [%0 u.u.val]))\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mink [20 [4 0 1]] $~)\n[%0 p=21]\n&gt; (mink [[90 5 3] [0 3]] $~)\n[%0 p=[5 3]]\n&gt; (mink 20^[4 0 1] $~)\n[%0 p=21]\n&gt; (mink [90 5 3]^[0 3] $~)\n[%0 p=[5 3]]\n&gt; (mink [0]^[11 1 20] $~)\n[%1 p=~[20]]\n&gt; (mink [0]^[11 1 20] |=(a=* `[40 a]))\n[%0 p=[40 20]]\n&gt; (mink [5]^[0 2] $~)\n[%2 p=~]\n&gt; (mink [5]^[10 yelp/[0 1] 0 0] $~)\n[%2 p=~[[~.yelp 5]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mock"
        ],
        "doc": "<h1><code>++mock</code></h1>\n<p>Compute formula on subject with hint</p>\n<p>Produces a <code>++toon</code>, which is either a sucessful, blocked, or\ncrashed result. If nock 11 is invoked, <code>sky</code> computes on the subject and\nproduces a <code>++unit</code> result. An empty result becomes a <code>%1</code> <code>++tune</code>,\nindicating a block.</p>\n<h2>Accepts</h2>\n<p><code>sub</code> is the subject as a noun.</p>\n<p><code>fol</code> is the formula as a noun.</p>\n<p><code>sky</code> is an %iron gate invoked with nock operator 11.</p>\n<h2>Produces</h2>\n<p>The <code>++unit</code> of a noun.</p>\n<h2>Source</h2>\n<pre><code>++  mock\n  |=  {{sub/* fol/*} gul/$-({* *} (unit (unit)))}\n  (mook (mink [sub fol] gul))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mock [5 4 0 1] ,~)\n[%0 p=6]\n&gt; (mock [~ 11 1 0] |=(* `999))\n[%0 p=999]\n&gt; (mock [~ 0 1.337] ,~)\n[%2 p=~]\n&gt; (mock [~ 11 1 1.337] ,~)\n[%1 p=~[1.337]]\n&gt; (mock [[[4 4 4 4 0 3] 10] 11 9 2 0 1] |=(* `[+&lt;]))\n[%0 p=14]\n&gt; (mock [[[4 4 4 4 0 3] 10] 11 9 2 0 1] |=(* `[&lt;+&lt;&gt;]))\n[%0 p=[49 52 0]]\n&gt; ;;(tape +:(mock [[[4 4 4 4 0 3] 10] 11 9 2 0 1] |=(* `[&lt;+&lt;&gt;])))\n\"14\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mong"
        ],
        "doc": "<h1><code>++mong</code></h1>\n<p>Slam gate with sample</p>\n<p>Produces a <code>++toon</code> computation result from slamming <code>gat</code> with\n<code>sam</code>, using <code>sky</code> to compute or block on nock 11 when applicable.</p>\n<h2>Accepts</h2>\n<p><code>gat</code> is a noun that is generally a <code>gate</code>.</p>\n<p><code>sam</code> is a <code>sample</code> noun.</p>\n<p><code>sky</code> is an %iron gate invoked with nock operator 11.</p>\n<h2>Produces</h2>\n<p>A <code>++toon</code>.</p>\n<h2>Source</h2>\n<pre><code>++  mong\n  |=  {{gat/* sam/*} gul/$-({* *} (unit (unit)))}\n  ^-  toon\n  ?.  &amp;(?=(^ gat) ?=(^ +.gat))\n    [%2 ~]\n  (mock [[-.gat [sam +&gt;.gat]] -.gat] gul)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mong [|=(@ 20) ~] ,~)\n[%0 p=20]\n&gt; (mong [|=(@ !!) ~] ,~)\n[%2 p=~]\n&gt; (mong [|=(a/@ (add 20 a)) ~] ,~)\n[%0 p=20]\n&gt; (mong [|=(a/[@ @] (add 20 -.a)) ~] ,~)\n[%2 p=~]\n&gt; (mong [|=(a/[@ @] (add 20 -.a)) [4 6]] ,~)\n[%0 p=24]\n&gt; (mong [|=(a/@ .^(a)) ~] ,~)\n[%1 p=~[0]]\n&gt; (mong [|=(a/@ .^(a)) ~] ,[~ %42])\n[%0 p=42]\n&gt; (mong [|=(a/@ .^(a)) ~] |=(a/* [~ a 6]))\n[%0 p=[0 6]]\n&gt; (mong [|=(a/@ .^(a)) 8] |=(a/* [~ a 6]))\n[%0 p=[8 6]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mook"
        ],
        "doc": "<h1><code>++mook</code></h1>\n<p>Intelligently render crash annotation</p>\n<p>Converts a <code>%2</code> <code>++tone</code> nock stack trace to a list of <code>++tank</code>.\nEach may be a tank, cord, <code>++spot</code>, or trapped tank.</p>\n<h2>Accepts</h2>\n<p><code>ton</code> is a <code>++tone</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++toon</code>.</p>\n<h2>Source</h2>\n<pre><code>++  mook\n  |=  ton/tone\n  ^-  toon\n  ?.  ?=({$2 *} ton)  ton\n  :-  %2\n  :: =.  p.ton  (moop p.ton)\n  =+  yel=(lent p.ton)\n  =.  p.ton\n    ?.  (gth yel 256)  p.ton\n    %+  weld\n      (scag 128 p.ton)\n    ^-  (list {@ta *})\n    :_  (slag (sub yel 128) p.ton)\n    :-  %lose\n    %+  rap  3\n    \"[skipped {(scow %ud (sub yel 256))} frames]\"\n  |-  ^-  (list tank)\n  ?~  p.ton  ~\n  =+  rep=$(p.ton t.p.ton)\n  ?+    -.i.p.ton  rep\n      $hunk  [(tank +.i.p.ton) rep]\n      $lose  [[%leaf (rip 3 (@ +.i.p.ton))] rep]\n      $hand  [[%leaf (scow %p (mug +.i.p.ton))] rep]\n      $mean  :_  rep\n             ?@  +.i.p.ton  [%leaf (rip 3 (@ +.i.p.ton))]\n             =+  mac=(mack +.i.p.ton +&lt;.i.p.ton)\n             ?~(mac [%leaf \"####\"] (tank u.mac))\n      $spot  :_  rep\n             =+  sot=(spot +.i.p.ton)\n             :+  %rose  [\":\" ~ ~]\n             :~  (smyt p.sot)\n                 =&gt;  [ud=|=(a/@u (scow %ud a)) q.sot]\n                 leaf+\"&lt;[{(ud p.p)} {(ud q.p)}].[{(ud p.q)} {(ud q.q)}]&gt;\"\n  ==         ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mook [%0 5 4 5 1])\n[%0 p=[5 4 5 1]]\n&gt; (mook [%2 ~[[%hunk %rose [\"&lt;\" \",\" \"&gt;\"] ~[[%leaf \"err\"]]]]])\n[%2 p=~[[%rose p=[p=\"&lt;\" q=\",\" r=\"&gt;\"] q=[i=[%leaf p=\"err\"] t=~]]]]\n&gt; (mook [%2 ~[[%malformed %elem] [%lose 'do print']]])\n[%2 p=~[[%leaf p=\"do print\"]]]\n&gt; (mook [%2 ~[[%mean |.(&gt;(add 5 6)&lt;)]]])\n[%2 p=~[[%leaf p=\"11\"]]]\n&gt; (mook [%2 ~[[%spot /b/repl [1 1]^[1 2]] [%mean |.(!!)]]])\n[%2 p=~[[%leaf p=\"/b/repl/:&lt;[1 1].[1 2]&gt;\"] [%leaf p=\"####\"]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mule"
        ],
        "doc": "<h1><code>++mule</code></h1>\n<p>Typed virtual</p>\n<p>Kicks a <code>++trap</code>, producing its results or any errors that occur along\nthe way. Used to lazily compute stack traces.</p>\n<h2>Accepts</h2>\n<p><code>taq</code> is a <code>++trap</code>, generally producing a list of <code>++tank</code>s.</p>\n<h2>Produces</h2>\n<p>XX</p>\n<h2>Source</h2>\n<pre><code>++  mule                                                ::  typed virtual\n  ~/  %mule\n  |*  taq/_|.(**)\n  =+  mud=(mute taq)\n  ?-  -.mud\n    $&amp;  [%&amp; p=$:taq]                                    ::  XX transition\n    $|  [%| p=p.mud]\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mule |.(leaf/\"hello\"))\n[%.y p=[%leaf \"hello\"]]\n&gt; (mule |.(!!))\n[%.n p=~]\n&gt; (mule |.(.^(a//=pals/1)))\n[ %.n\n    p\n  ~[\n    [ %rose\n      p=[p=\"/\" q=\"/\" r=\"/\"]\n        q\n      [ i=[%leaf p=\"a\"] \n        t=[i=[%leaf p=\"~zod\"] t=[i=[%leaf p=\"pals\"] t=[i=[%leaf p=\"1\"] t=~]]]\n      ]\n    ]\n  ]\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mute"
        ],
        "doc": "<h1><code>++mute</code></h1>\n<p>Untyped virtual</p>\n<p>Kicks a <code>++trap</code>, producing its result as a noun or the tanks of any\nerror that occurs. Similar to <code>++mule</code>, but preserves no type\ninformation.</p>\n<h2>Accepts</h2>\n<p><code>taq</code> is a <code>++trap</code>.</p>\n<h2>Produces</h2>\n<p>Either a noun or a <code>++list</code> of <code>++tank</code>.</p>\n<h2>Source</h2>\n<pre><code>++  mute                                                ::  untyped virtual\n  |=  taq/_^?(|.(**))\n  ^-  (each * (list tank))\n  =+  ton=(mock [taq 9 2 0 1] |=({* *} ~))\n  ?-  -.ton\n    $0  [%&amp; p.ton]\n    $1  [%| (turn p.ton |=(a/* (smyt (path a))))]\n    $2  [%| p.ton]\n  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt;  (mute |.(leaf/\"hello\"))\n[%.y p=[1.717.658.988 104 101 108 108 111 0]]\n&gt; (mute |.(!!))\n[%.n p=~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "abel"
        ],
        "doc": "<h1><code>++abel</code></h1>\n<p>Biblical names in hoon are primarily aliases for the compiler.</p>\n<h2>Source</h2>\n<pre><code>++  abel  typo                                          ::  original sin: type\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *abel\n%void\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "aura"
        ],
        "doc": "<h1><code>++aura</code></h1>\n<p>'type' of atom</p>\n<p>By convention, a short name for a category of atom. <code>++aura</code> is\ncircularly defined, with <a href=\"\"><code>@ta</code></a> being the <code>++aura</code> of the ASCII subset\ncommonly used in urbit.</p>\n<h2>Source</h2>\n<pre><code>++  aura  ,@ta                                          ::  atom format\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <a href=\"\"><code>++base</code></a>, <a href=\"\">aura reference</a></p>\n<pre><code>&gt; `aura`%ux\n~.ux\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "axis"
        ],
        "doc": "<h1><code>++axis</code></h1>\n<p>Nock axis</p>\n<p>A Nock axis inside a <a href=\"\">noun</a>. After the leading 1, in binary, a <code>1</code> signfies\nright and <code>0</code> left.</p>\n<h2>Source</h2>\n<pre><code>++  axis  ,@                                            ::  tree address\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *axis\n0\n\n&gt; :: 0 is not actually a valid axis\n&gt; [[4 5] 6 7]\n[[4 5] 6 7]\n&gt; `axis`0b110\n6\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "base"
        ],
        "doc": "<h1><code>++base</code></h1>\n<p>Base type</p>\n<p>A base type that <a href=\"\">noun</a>s are built from. A <code>++base</code> is either a noun, cell, boolean or\nnull labelled with an <a href=\"\">odor</a>.</p>\n<h2>Source</h2>\n<pre><code>++  base  ?([%atom p=odor] %noun %cell %bean %null)     ::  axils, @ * ^ ? ~\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *base\n%null\n\n&gt; (ream '=|(^ !!)')\n[%tsbr p=[%axil p=%cell] q=[%zpzp ~]]\n&gt; :: p.p is a ++base\n&gt; (ream '=|(@t !!)')\n[%tsbr p=[%axil p=[%atom p=~.t]] q=[%zpzp ~]]\n&gt; (ream '=|(? !!)')\n[%tsbr p=[%axil p=%bean] q=[%zpzp ~]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "bean"
        ],
        "doc": "<h1><code>++bean</code></h1>\n<p>Boolean</p>\n<p><code>0</code>, <code>&amp;</code>, or <code>%.y</code> are true, and <code>1</code>, <code>|</code>, and <code>%.n</code> are false.</p>\n<h2>Source</h2>\n<pre><code>++  bean  ,?                                            ::  0=&amp;=yes, 1=|=no\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *bean\n%.y\n\n&gt; `bean`&amp;\n%.y\n&gt; `bean`|\n%.n\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "beer"
        ],
        "doc": "<h1><code>++beer</code></h1>\n<p>Tape builder</p>\n<p>Used to build <a href=\"\">tape</a>s internally.</p>\n<h2>Source</h2>\n<pre><code>++  beer  $|(@ [~ p=hoon])                              ::  simple embed\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; `beer`'as'\n29.537\n&gt; `beer`[~ (ream 'lan')]\n[~ p=[%cnzz p=~[%lan]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "beet"
        ],
        "doc": "<h1><code>++beet</code></h1>\n<p>XML interpolation cases</p>\n<p>Used internally.</p>\n<h2>Source</h2>\n<pre><code>++  beet  $|  @                                         ::  advanced embed\n          $%  [%a p=hoon]                               ::  take tape\n              [%b p=hoon]                               ::  take manx\n              [%c p=hoon]                               ::  take marl\n              [%d p=hoon]                               ::  take $+(marl marl)\n              [%e p=hoon q=(list tuna)]                 ::  element literal\n          ==                                            ::\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "chum"
        ],
        "doc": "<h1><code>++chum</code></h1>\n<p>Jet hint information</p>\n<p>Jet hint information that must be present in the body of a <code>~/</code> or <code>~%</code>\nrune. A <code>++chum</code> can optionally contain a kelvin version, jet vendor,\nand \"{major}.{minor}\" version number.</p>\n<h2>Source</h2>\n<pre><code>++  chum  $?  lef=term                                  ::  jet name\n              [std=term kel=@]                          ::  kelvin version\n              [ven=term pro=term kel=@]                 ::  vendor and product\n              [ven=term pro=term ver=@ kel=@]           ::  all of the above\n          ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<p>XX there's a ++chum in zuse that's politely causing this not to work</p>\n<pre><code>&gt; `chum`'hi'\nlef=%hi\n\n&gt; (ream '~/(%lob.314 !!)')\n[%sgfs p=[std=%lob kel=314] q=[%zpzp ~]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "coil"
        ],
        "doc": "<h1><code>++coil</code></h1>\n<p>Tuple of core information</p>\n<p>Variance <code>p</code>, subject type <code>q</code>, and <code>q</code>: optional compiled nock, and arms. Used as an\nintermediate step within Section 2fB. Converted by <code>++core</code> to %core type.</p>\n<h2>Source</h2>\n<pre><code>++  coil  $:  p=?(%gold %iron %lead %zinc)              ::  core type\n              q=type                                    ::\n              r=[p=?(~ ^) q=(map term foot)]            ::\n          ==                                            ::\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "foot"
        ],
        "doc": "<h1><code>++foot</code></h1>\n<p>Cases of arms by variance model.</p>\n<p><code>%ash</code> arms are <a href=\"\"><code>dry</code></a> and <a href=\"\">geometric</a>.</p>\n<h2>Source</h2>\n<pre><code>++  foot  $%  [%ash p=hoon]                             ::  dry arm, geometric\n              [%elm p=hoon]                             ::  wet arm, generic\n              [%oak ~]                                  ::  XX not used\n              [%yew p=(map term foot)]                  ::  XX not used\n          ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <a href=\"\"><code>++ap</code></a>, <a href=\"\"><code>++ut</code></a></p>\n<pre><code> &gt; *foot\n[%yew p={}]\n\n&gt; (ream '|%  ++  $  foo  --')\n[%brcn p={[p=%$ q=[%ash p=[%cnzz p=~[%foo]]]]}]\n&gt; +&lt;+:(ream '|%  ++  $  foo  --')\nt=~[%ash %cnzz %foo]\n&gt; (foot +&lt;+:(ream '|%  ++  $  foo  --'))\n[%ash p=[%cnzz p=~[%foo]]]\n&gt; (foot +&lt;+:(ream '|%  +-  $  foo  --'))\n[%elm p=[%cnzz p=~[%foo]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "limb"
        ],
        "doc": "<h1><code>++limb</code></h1>\n<pre><code>++  limb  $|(term $%([%&amp; p=axis] [%| p=@ud q=term]))    ::\n</code></pre>\n<p>XX move to <code>++ut</code></p>\n<p>Reference into subject by name/axis</p>\n<p>See also: section 2fC-2fD</p>\n<pre><code>&gt; (ream '^^$')\n[%cnzz p=~[[%.n p=2 q=%$]]]\n&gt; (limb &amp;2:(ream '^^$'))\n[%.n p=2 q=%$]\n&gt; (limb &amp;2:(ream '^^^$'))\n[%.n p=3 q=%$]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "line"
        ],
        "doc": "<h1><code>++line</code></h1>\n<p>XX move to <code>++ut</code></p>\n<h2>Source</h2>\n<pre><code>++  line  ,[p=[%leaf p=odor q=@] q=tile]                ::  %kelp case\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (ream '$%([1 a] [%2 b])')\n[ %bccm\n    p\n  [ %kelp\n      p\n    [ i=[p=[%leaf p=~.ud q=1] q=[%herb p=[%cnzz p=~[%a]]]]\n      t=~[[p=[%leaf p=~.ud q=2] q=[%herb p=[%cnzz p=~[%b]]]]]\n    ]\n  ]\n]\n&gt; &amp;3:(ream '$%([1 a] [%2 b])')\np=[p=[%leaf p=%ud q=1] q=[%herb p=[%cnzz p=~[%a]]]]\n&gt; (line &amp;3:(ream '$%([1 a] [%2 b])'))\n[p=[%leaf p=~.ud q=1] q=[%herb p=[%cnzz p=~[%a]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "metl"
        ],
        "doc": "<h1><code>++metl</code></h1>\n<pre><code>++  metl  ?(%gold %iron %zinc %lead)                    ::  core variance\n</code></pre>\n<p>XX move to <code>++ut</code></p>\n<p>See also: <a href=\"\"><code>++coil</code></a></p>\n<hr>\n"
    },
    {
        "keys": [
            "nock"
        ],
        "doc": "<h1><code>++nock</code></h1>\n<p>Virtual machine. See <a href=\"\">Nock doc</a>.</p>\n<h2>Source</h2>\n<pre><code>    ++  nock  $&amp;  [p=nock q=nock]                           ::  autocons\n              [%3 p=nock]                               ::  cell test\n              [%4 p=nock]                               ::  increment\n              [%5 p=nock q=nock]                        ::  equality test\n              [%6 p=nock q=nock r=nock]                 ::  if, then, else\n              [%7 p=nock q=nock]                        ::  serial compose\n              [%8 p=nock q=nock]                        ::  push onto subject\n              [%9 p=@ q=nock]                           ::  select arm and fire\n              [%10 p=?(@ [p=@ q=nock]) q=nock]          ::  hint\n              [%11 p=nock]                              ::  grab data from sky\n          ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; !=([+(.) 20 -&lt;])\n[[4 0 1] [1 20] 0 4]\n&gt; (nock !=([+(.) 20]))\n[p=[%4 p=[%0 p=1]] q=[%1 p=20]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "noun"
        ],
        "doc": "<h1><code>++noun</code></h1>\n<pre><code>++  noun  ,*                                            ::  any noun\n</code></pre>\n<p>Used nowhere XX</p>\n<pre><code>&gt; `noun`~[1 2 3]\n[1 2 3 0]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "null"
        ],
        "doc": "<h1><code>++null</code></h1>\n<pre><code>++  null  ,~                                            ::  null, nil, etc\n</code></pre>\n<p>Used nowhere XX</p>\n<pre><code>&gt; :type; *null\n~\n%~\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "port"
        ],
        "doc": "<h1><code>++port</code></h1>\n<p>XX move to <code>++ut</code></p>\n<p>Type and location of core-shaped thing? XX Compiler Internals</p>\n<h2>Source</h2>\n<pre><code>++  port  $:  p=axis                                    ::\n              $=  q                                     ::\n              $%  [%&amp; p=type]                           ::\n                  [%| p=axis q=(list ,[p=type q=foot])] ::\n              ==                                        ::\n          ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *port\n[p=0 q=[%.y p=%void]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "span"
        ],
        "doc": "<h1><code>++span</code></h1>\n<p>ASCII atom</p>\n<p>A restricted text atom for canonical atom syntaxes. The prefix is <code>~.</code>.\nThere are no escape sequences except <code>~~</code>, which means <code>~</code>, and <code>~-</code>,\nwhich means <code>_</code>. <code>-</code> and <code>.</code> encode themselves. No other characters\nbesides numbers and lowercase letters are permitted.</p>\n<h2>Source</h2>\n<pre><code>    ++  span  ,@ta                                          ::  text-atom (ASCII)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; *span\n~.\n\n&gt; `@t`~.foo\n'foo'\n&gt; `@t`~.foo.bar\n'foo.bar'\n&gt; `@t`~.foo~~bar\n'foo~bar'\n&gt; `@t`~.foo~-bar\n'foo_bar'\n&gt; `@t`~.foo-bar\n'foo-bar'\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tiki"
        ],
        "doc": "<h1><code>++tiki</code></h1>\n<p>XX move to <code>++ut</code></p>\n<h2>Source</h2>\n<pre><code>    ++  tiki                                                ::  test case\n</code></pre>\n<h2>Examples</h2>\n<p>A <code>++wing</code> or <code>++hoon</code>.</p>\n<pre><code>&gt; (ream '=+  a=4  ?-(a @ ~)')\n[ %tsls\n  p=[%ktts p=p=%a q=[%dtzy p=%ud q=4]]\n    q\n  [ %wthz\n    p=[%.y p=~ q=~[%a]]\n    q=~[[p=[%axil p=[%atom p=~.]] q=[%bczp p=%null]]]\n  ]\n]\n&gt; (ream '=+  a=4  ?-(4 @ ~)')\n[ %tsls\n  p=[%ktts p=p=%a q=[%dtzy p=%ud q=4]]\n    q\n  [ %wthz\n    p=[%.n p=~ q=[%dtzy p=%ud q=4]]\n    q=~[[p=[%axil p=[%atom p=~.]] q=[%bczp p=%null]]]\n  ]\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "toga"
        ],
        "doc": "<h1><code>++toga</code></h1>\n<p>Tree of faces</p>\n<p>A <a href=\"\">face</a>, or tree of faces. A <code>++toga</code> is applied to anything assigned\nusing <a href=\"\"><code>^=</code></a>.</p>\n<p>XX move to <code>++ut</code> and rune doc (for \\^= examples)</p>\n<h2>Source</h2>\n<pre><code>    ++  toga                                                ::  face control\n              [2 p=toga q=toga]                         ::  cell toga\n          ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; a=1\na=1\n&gt; (ream 'a=1')\n[%ktts p=p=%a q=[%dtzy p=%ud q=1]]\n&gt; [a b]=[1 2 3]\n[a=1 b=[2 3]]\n&gt; (ream '[a b]=[1 2 3]')\n[ %ktts\n  p=[%2 p=p=%a q=p=%b]\n  q=[%cltr p=~[[%dtzy p=%ud q=1] [%dtzy p=%ud q=2] [%dtzy p=%ud q=3]]]\n]\n\n&gt; [a ~]=[1 2 3]\n[a=1 2 3]\n&gt; (ream '[a ~]=[1 2 3]')\n[ %ktts\n  p=[%2 p=p=%a q=[%0 ~]]\n  q=[%cltr p=~[[%dtzy p=%ud q=1] [%dtzy p=%ud q=2] [%dtzy p=%ud q=3]]]\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tone"
        ],
        "doc": "<h1><code>++tone</code></h1>\n<p>Intermediate Nock computation result</p>\n<p>Similar to <a href=\"\"><code>++toon</code></a>, but stack trace is not yet rendered.</p>\n<h2>Source</h2>\n<pre><code>    ++  tone  $%  [%0 p=*]                                  ::  success\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (mink [[20 21] 0 3] ,~)\n[%0 p=21]\n\n&gt; (mink [[0] !=(.^(cy//=main/1))] ,~)\n[%1 p=~[[31.075 1.685.027.454 1.852.399.981 49 0]]]\n&gt; (path [31.075 1.685.027.454 1.852.399.981 49 0])\n/cy/~zod/main/1\n\n&gt; (mink [[1 2] !=(~|(%hi +(.)))] ,~)\n[%2 p=~[[~.yelp 26.984]]]\n&gt; (mink [[1 2] !=(!:(+(.)))] ,~)\n[ %2\n    p\n  ~[\n    [ ~.spot\n      [ [ 1.685.027.454\n          7.959.156\n          \\/159.445.990.350.374.058.574.398.238.344.143.957.205.628.479.572.65\\/\n            8.112.403.878.526\n          \\/                                                                  \\/\n          0\n        ]\n        [1 20]\n        1\n        24\n      ]\n    ]\n  ]\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "tuna"
        ],
        "doc": "<h1><code>++tuna</code></h1>\n<p>XML template tree</p>\n<p>An XML template tree.</p>\n<h2>Source</h2>\n<pre><code>    ++  tuna                                                ::  tagflow\n              [%d p=hoon]                               ::  dynamic list\n              [%e p=hoon q=(list tuna)]                 ::  element\n              [%f p=(list tuna)]                        ::  subflow\n          ==                                            ::\n</code></pre>\n<h2>Examples</h2>\n<p>Leaf %a contains plain-text, %b an empty tag, %c a static list, %d a\ndynamic list, %e a full node element containing a hoon and a list of\ntuna, and %f is a empty node.</p>\n<p>See also: <a href=\"\"><code>++sail</code></a></p>\n<hr>\n"
    },
    {
        "keys": [
            "tusk"
        ],
        "doc": "<h1><code>++tusk</code></h1>\n<p>List of expressions</p>\n<p>List of <a href=\"\"><code>++hoon</code></a>s. In <a href=\"\"><code>:*</code></a>, for example, your contents is\na <code>++tusk</code>.</p>\n<h2>Source</h2>\n<pre><code>    ++  tusk  (list hoon)                                   ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (ream '[1 2 3]')\n[%cltr p=~[[%dtzy p=%ud q=1] [%dtzy p=%ud q=2] [%dtzy p=%ud q=3]]]\n&gt; (tusk +:(ream '[1 2 3]'))\n~[[%dtzy p=%ud q=1] [%dtzy p=%ud q=2] [%dtzy p=%ud q=3]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hoon"
        ],
        "doc": "<h1><code>++hoon</code></h1>\n<p>Expression</p>\n<p>An expression, or AST.</p>\n<p>See Rune section of Hoon reference</p>\n<hr>\n"
    },
    {
        "keys": [
            "tyke"
        ],
        "doc": "<h1><code>++tyke</code></h1>\n<p>List of 'maybe' hoons</p>\n<p>List of <a href=\"\"><code>++unit</code></a> <a href=\"\"><code>++hoon</code></a>, or gaps left to be inferred, in <a href=\"\"><code>++path</code></a>\nparsing. When you use a path such as <code>/=main=/pub/src/doc</code> the path is in fact\na <code>++tyke</code>, where the <code>=</code> are inferred from your current path.</p>\n<h2>Source</h2>\n<pre><code>    ++  tyke  (list (unit hoon))                            ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>&gt; (scan \"/==as=\" porc:vast)\n[0 ~[~ ~ [~ [%dtzy p=%tas q=29.537]] ~]]\n&gt; `tyke`+:(scan \"/==as=\" porc:vast)\n~[~ ~ [~ [%dtzy p=%tas q=29.537]] ~]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "typo"
        ],
        "doc": "<h1><code>++typo</code></h1>\n<p>Pointer for <code>++type</code></p>\n<p>Pointer for <a href=\"\"><code>++type</code></a>. <code>++typo</code> preserves the previous <code>++type</code> in your\ncontext when upating.</p>\n<h2>Source</h2>\n<pre><code>    ++  typo  type                                          ::  old type\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++seem</code>, <code>++vise</code>, <code>++type</code></p>\n<hr>\n"
    },
    {
        "keys": [
            "tyre"
        ],
        "doc": "<h1><code>++tyre</code></h1>\n<p>List, term hoon</p>\n<p>Associative list of <a href=\"\"><code>++term</code></a> <a href=\"\"><code>++hoon</code></a>, used in <a href=\"\">jet</a> hint processing.</p>\n<h2>Source</h2>\n<pre><code>    ++  tyre  (list ,[p=term q=hoon])                       ::\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "vase"
        ],
        "doc": "<h1><code>++vase</code></h1>\n<p>Typed data. A <code>++vase</code> is used wherever typed data is explicitly worked\nwith.</p>\n<h2>Source</h2>\n<pre><code>    ++  vase  ,[p=type q=*]                                 ::  type-value pair\n</code></pre>\n<h2>Examples</h2>\n<p>See <code>%arvo</code> doc</p>\n<pre><code>&gt; `vase`!&gt;(~)\n[p=[%cube p=0 q=[%atom p=%n]] q=0]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "vise"
        ],
        "doc": "<h1><code>++vise</code></h1>\n<p>Convert during reboot</p>\n<p>Used to convert from previously-typed data during reboot.</p>\n<h2>Source</h2>\n<pre><code>++  vise  ,[p=typo q=*]                                 ::  old vase\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <a href=\"\"><code>++typo</code></a>, <a href=\"\"><code>++seer</code></a></p>\n<hr>\n"
    },
    {
        "keys": [
            "wing"
        ],
        "doc": "<h1><code>++wing</code></h1>\n<pre><code>++  wing  (list limb)                                   ::\n</code></pre>\n<p>Address in subject. A <code>++wing</code> is a path to a value in the subject. A\nterm alone is the trivial case of a <code>++wing</code>.</p>\n<p>See also: <code>++hoon</code></p>\n<pre><code>&gt; (ream 'a.+.c')\n[%cnzz p=~[%a [%.y p=3] %c]]\n&gt; (wing +:(ream 'a.+.c'))\n~[%a [%.y p=3] %c]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mane"
        ],
        "doc": "<h1><code>++mane</code></h1>\n<p>XML name</p>\n<p>An XML name (tag name or attribute name) with an optional namespace.  Parsed by\n<code>++name</code> within <code>++poxa</code>, rendered by <code>++name</code> within <code>++poxo</code>.</p>\n<h2>Source</h2>\n<pre><code>    ++  mane  $@(@tas [@tas @tas])                          ::  XML name/space\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++sail</code></p>\n<pre><code>&gt; *mane\n%$\n\n&gt; `mane`n.g:`manx`;div:namespace;\n%div\n&gt; `mane`n.g:`manx`;div_namespace;\n[%div %namespace]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "manx"
        ],
        "doc": "<h1><code>++manx</code></h1>\n<p>XML node.</p>\n<p>Parsed by <code>++apex</code> within <code>++poxa</code>, rendered by <code>++poxo</code>.</p>\n<h2>Source</h2>\n<pre><code>    ++  manx  {g/marx c/marl}                              ::  XML node\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++sail</code> doc</p>\n<hr>\n"
    },
    {
        "keys": [
            "marl"
        ],
        "doc": "<h1><code>++marl</code></h1>\n<p>List of XML nodes</p>\n<p>A list of <a href=\"\"><code>++manx</code></a>.</p>\n<h2>Source</h2>\n<pre><code>    ++  marl  (list manx)                                   ::  XML node list\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "mars"
        ],
        "doc": "<h1><code>++mars</code></h1>\n<p>XML CDATA</p>\n<p>Implicitly produced by <code>++chrd</code> within <code>++poxa</code></p>\n<h2>Source</h2>\n<pre><code>++  mars  {t/{n/$$ a/{i/{n/$$ v/tape} t/$~}} c/$~}      ::  XML cdata\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "mart"
        ],
        "doc": "<h1><code>++mart</code></h1>\n<p>List of XML attributes</p>\n<p>Each <code>++mart</code> is a list of pairs of <code>++mane</code> and\n<code>++tape</code>.</p>\n<p>Parsed by <code>++attr</code> within <code>++poxa</code>, rendered by <code>++attr</code> within <code>++poxo</code></p>\n<h2>Source</h2>\n<pre><code>++  mart  (list {n/mane v/tape})                       ::  XML attributes\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "marx"
        ],
        "doc": "<h1><code>++marx</code></h1>\n<p>XML tag</p>\n<p>A <code>++marx</code> is a pair of a tag name, <code>++mane</code> and a list of attributes,\n<code>++mart</code>. Parsed by <code>++head</code> <code>++poxa</code>, rendered within <code>++poxo</code>.</p>\n<h2>Source</h2>\n<pre><code>++  marx  {n/mane a/mart}                              ::  XML tag\n</code></pre>\n<h2>Examples</h2>\n<hr>\n"
    },
    {
        "keys": [
            "pass"
        ],
        "doc": "<h1><code>++pass</code></h1>\n<p>Atom alias</p>\n<p>Used primarily in crypto.</p>\n<h2>Source</h2>\n<pre><code>    ++  pass  @                                            ::  public key\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ring"
        ],
        "doc": "<h1><code>++ring</code></h1>\n<p>Atom alias</p>\n<p>Used primarily in crypto.</p>\n<h2>Source</h2>\n<pre><code>    ++  ring  @                                            ::  private key\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "time"
        ],
        "doc": "<h1><code>++time</code></h1>\n<p>Absolute date</p>\n<p>The <code>@da</code> odor designates an absolute date atom.</p>\n<h2>Source</h2>\n<pre><code>    ++  time  @da                                          ::  galactic time\n</code></pre>\n<h2>Examples</h2>\n<p>See also: <code>++date</code>, odor reference</p>\n<pre><code>&gt; `time`~2014.1.1\n~2014.1.1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "berk"
        ],
        "doc": "<h1><code>++berk</code></h1>\n<p>Invert diff patches</p>\n<p>Inverts a list of changes <code>bur</code>. Skips stay constant and replaces are\nswapped. Produces a <code>bur</code>.</p>\n<h2>Accepts</h2>\n<p><code>bur</code> is a <a href=\"\"><code>++urge</code></a>.</p>\n<h2>Produces</h2>\n<p>The <code>++urge</code> of a noun.</p>\n<h2>Source</h2>\n<pre><code>++  berk                                                ::  invert diff patch\n  |*  bur=(urge)\n  |-  ^+  bur\n  ?~  bur  ~\n  :_  $(bur t.bur)\n  ?-  -.i.bur\n    &amp;  i.bur\n    |  [%| q.i.bur p.i.bur]\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (berk `(urge)`~[`10 %|^[~[2] ~[3 4]] `5])\n~[[%.y p=10] [%.n p=~[3 4] q=~[2]] [%.y p=5]]\n~zod/try=&gt; (lurk \"somes\" `(urge char)`~[`1 [%| \"o\" \"a\"] `3])\n\"sames\"\n~zod/try=&gt; (berk `(urge char)`~[`1 [%| \"o\" \"a\"] `3])\n~[[%.y p=1] [%.n p=\"a\" q=\"o\"] [%.y p=3]]\n~zod/try=&gt; (lurk \"sames\" (berk `(urge char)`~[`1 [%| \"o\" \"a\"] `3]))\n\"somes\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "diff"
        ],
        "doc": "<h1><code>++diff</code></h1>\n<p>Generate patch</p>\n<p>Produces a patch between two nouns, by change type</p>\n<h2>Accepts</h2>\n<p><code>pum</code> is an <a href=\"\"><code>++umph</code></a>.</p>\n<h2>Produces</h2>\n<p>An <a href=\"\"><code>++udon</code></a></p>\n<h2>Source</h2>\n<pre><code>++  diff                                                ::  generate patch\n  |=  pum=umph\n  |=  [old=* new=*]  ^-  udon\n  :-  pum\n  ?+  pum  ~|(%unsupported !!)\n    %a  [%d (nude old new)]\n    %b  =+  [hel=(cue ((hard ,@) old)) hev=(cue ((hard ,@) new))]\n        [%d (nude hel hev)]\n    %c  =+  [hel=(lore ((hard ,@) old)) hev=(lore ((hard ,@) new))]\n        [%c (lusk hel hev (loss hel hev))]\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((diff %a) 20 21)\n[p=%a q=[%d p=[%1 p=21] q=[%1 p=20]]]\n~zod/try=&gt; ((diff %a) [1 2 3] [1 2 4])\n[ p=%a\n    q\n  [ %d\n    p=[p=[%0 p=2] q=[p=[%0 p=6] q=[%1 p=4]]] \n    q=[p=[%0 p=2] q=[p=[%0 p=6] q=[%1 p=3]]]\n  ]\n]\n~zod/try=&gt; ~04hh\n[1 2]\n~zod/try=&gt; ~0ph\n[1 1]\n~zod/try=&gt; ((diff %b) 0v4hh 0vph)\n[p=%b q=[%d p=[p=[%0 p=2] q=[%0 p=2]] q=[p=[%0 p=3] q=[%1 p=2]]]]\n~zod/try=&gt; ((diff %c) (role 'sam' 'les' 'les' 'kor' ~) (role 'sam' 'mor' 'kor' ~))\n[p=%c q=[%c p=~[[%.y p=1] [%.n p=~[7.562.604 7.562.604] q=~[7.499.629]] [%.y p=1]]]]\n~[[%.y p=0] [%.y p=0] [%.y p=1] [%.n p=&lt;|les les|&gt; q=&lt;|mor|&gt;] [%.y p=1]]\n~zod/try=&gt; (,[%c %c (urge cord)] ((diff %c) (role 'sam' 'les' 'les' 'kor' ~) (role 'sam' 'mor' 'kor' ~)))\n[%c %c ~[[%.y p=1] [%.n p=&lt;|les les|&gt; q=&lt;|mor|&gt;] [%.y p=1]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "loss"
        ],
        "doc": "<h1><code>++loss</code></h1>\n<p>Longest subsequence</p>\n<p>Finds a subsequence of repeated elements within two <a href=\"\"><code>++list</code></a>s, using\nseveral internal helper arms. Produces a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>hel</code> is a <a href=\"\"><code>++list</code></a> of <a href=\"\">nouns</a>.</p>\n<p><code>hev</code> is a <a href=\"\">++list`</a> of nouns.</p>\n<h2>Produces</h2>\n<p>XX</p>\n<p>A <a href=\"\">++list`</a> of nouns.</p>\n<h2>Source</h2>\n<pre><code>++  loss                                                ::  longest subsequence\n  ~/  %loss\n  |*  [hel=(list) hev=(list)]\n  |-  ^+  hev\n  =+  ^=  sev\n      =+  [inx=0 sev=*(map ,@t (list ,@ud))]\n      |-  ^+  sev\n      ?~  hev  sev\n      =+  guy=(~(get by sev) i.hev)\n      $(hev t.hev, inx +(inx), sev (~(put by sev) i.hev [inx ?~(guy ~ u.guy)]))\n  =|  gox=[p=@ud q=(map ,@ud ,[p=@ud q=_hev])]\n  =&lt;  abet\n  =&lt;  main\n  |%\n  ++  abet  =.(q.rag ?:(=([&amp; 0] p.rag) q.rag [p.rag q.rag]) (flop q.rag))\n  ++  hink                                              ::  extend fits top\n    |=  [inx=@ud goy=@ud]  ^-  ?\n    |(=(p.gox inx) (lth goy p:(need (~(get by q.gox) inx))))\n  ::\n  ++  lonk                                              ::  extend fits bottom\n    |=  [inx=@ud goy=@ud]  ^-  ?\n    |(=(0 inx) (gth goy p:(need (~(get by q.gox) (dec inx)))))\n  ::\n  ++  lune                                              ::  extend\n    |=  [inx=@ud goy=@ud]\n    ^+  +&gt;\n    %_    +&gt;.$\n        gox\n      :-  ?:(=(inx p.gox) +(p.gox) p.gox)\n      %+  ~(put by q.gox)  inx\n      [goy (snag goy hev) ?:(=(0 inx) ~ q:(need (~(get by q.gox) (dec inx))))]\n    ==\n  ::\n  ++  merg                                              ::  merge all matches\n    |=  gay=(list ,@ud)\n    ^+  +&gt;\n    =+  ^=  zes\n        =+  [inx=0 zes=*(list ,[p=@ud q=@ud])]\n        |-  ^+  zes\n        ?:  |(?=(~ gay) (gth inx p.gox))  zes\n        ?.  (lonk inx i.gay)  $(gay t.gay)\n        ?.  (hink inx i.gay)  $(inx +(inx))\n        $(inx +(inx), gay t.gay, zes [[inx i.gay] zes])\n    |-  ^+  +&gt;.^$\n    ?~(zes +&gt;.^$ $(zes t.zes, +&gt;.^$ (lune i.zes)))\n  ::\n  ++  main\n    |-  ^+  +\n    ?~  hel\n      ?~  hev\n        ?&gt;(?=(~ lcs) +)\n      $(hev t.hev, rag (done %| ~ [i.hev ~]))\n    ?~  hev\n      $(hel t.hel, rag (done %| [i.hel ~] ~))\n    ?~  lcs\n      +(rag (done %| (flop hel) (flop hev)))\n    ?:  =(i.hel i.lcs)\n      ?:  =(i.hev i.lcs)\n        $(lcs t.lcs, hel t.hel, hev t.hev, rag (done %&amp; 1))\n      $(hev t.hev, rag (done %| ~ [i.hev ~]))\n    ?:  =(i.hev i.lcs)\n      $(hel t.hel, rag (done %| [i.hel ~] ~))\n    $(hel t.hel, hev t.hev, rag (done %| [i.hel ~] [i.hev ~]))\n  --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (loss \"sam\" \"sem\")\n\"sm\"\n~zod/try=&gt; (loss \"samo\" \"semo\")\n\"smo\"\n~zod/try=&gt; (loss \"sakmo\" \"semo\")\n\"smo\"\n~zod/try=&gt; (loss \"ferdinham\" \"ferdilapos\n~ &lt;syntax error at [1 30]&gt;\n~zod/try=&gt; (loss \"ferdinham\" \"ferdilapos\")\n\"ferdia\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "locz"
        ],
        "doc": "<h1><code>++locz</code></h1>\n<p>Find common</p>\n<p>Finds a subsequence of repeated elements within two\n<a href=\"/docs/hoon/library/1#++list\"><code>++list</code></a>s, producing a <a href=\"\">`++tape</a>.</p>\n<h2>Accepts</h2>\n<p>A cell of two <code>++tape</code>s, <code>hel</code> and <code>hev</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  locz                                                ::  trivial algorithm\n  |=  [hel=tape hev=tape]\n  ^-  tape\n  =+  [leh=(lent hel) veh=(lent hev)]\n  =-  (flop q.yun)\n  ^=  yun\n  |-  ^-  [p=@ud q=tape]\n  ~+\n  ?:  |(=(0 leh) =(0 veh))  [0 ~]\n  =+  [dis=(snag (dec leh) hel) dat=(snag (dec veh) hev)]\n  ?:  =(dis dat)\n    =+  say=$(leh (dec leh), veh (dec veh))\n    [+(p.say) [dis q.say]]\n  =+  [lef=$(leh (dec leh)) rig=$(veh (dec veh))]\n  ?:((gth p.lef p.rig) lef rig)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (locz \"samukot\" \"semelkot\")\n\"smkot\"\n~zod/try=&gt; (locz \"samukot\" \"samelkot\")\n\"samkot\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lore"
        ],
        "doc": "<h1><code>++lore</code></h1>\n<p>Split on <code>\\n</code></p>\n<p>Split on newlines, ascii <code>10</code></p>\n<h2>Accepts</h2>\n<p><code>lub</code> is an atom.</p>\n<h2>Produces</h2>\n<p>XX</p>\n<p>A <code>++list</code> of atoms of odor <a href=\"\"><code>@t</code></a> (<a href=\"\"><code>++cord</code></a>).</p>\n<h2>Source</h2>\n<pre><code>++  lore                                                ::  atom to line list\n  ~/  %lore\n  |=  lub=@\n  =|  tez=(list ,@t)\n  |-  ^+  tez\n  ?:  =(0 lub)  (flop tez)\n  =+  ^=  meg\n      =+  meg=0\n      |-  ^-  @ud\n      =+  gam=(cut 3 [meg 1] lub)\n      ?:(|(=(10 gam) =(0 gam)) meg $(meg +(meg)))\n  =+  res=(rsh 3 +(meg) lub)\n  ?:  &amp;(=(0 (cut 3 [meg 1] lub)) !=(0 res))\n    !!\n  $(lub res, tez [(end 3 meg lub) tez])\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (lore 'soke\\0alas\\0amep')\n&lt;|soke las mep|&gt;\n~zod/try=&gt; (lore '|=  a=@\\0a=+  b=(add a 5)\\0a(mix b a)')\n&lt;||=  a=@ =+  b=(add a 5) (mix b a)|&gt;\n~zod/try=&gt; `wain`[(fil 3 80 ' ') (lore '|=  a=@\\0a=+  b=(add a 5)\\0a(mix b a)')]\n&lt;|                                                                                \n  |=  a=@\n  =+  b=(add a 5)\n  (mix b a)\n|&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "role"
        ],
        "doc": "<h1><code>++role</code></h1>\n<p>Join with <code>\\n</code></p>\n<p>Join line list with newlines.</p>\n<h2>Accepts</h2>\n<p>A <code>++list</code> of atoms of <a href=\"\">odor</a> <a href=\"\"><code>@t</code></a> (<a href=\"\"><code>++cord</code></a>).</p>\n<h2>Produces</h2>\n<p>XX</p>\n<p>An atom of <a href=\"\">odor</a> <a href=\"\"><code>@t</code></a> (<a href=\"\"><code>++cord</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  role                                                ::  line list to atom\n  |=  tez=(list ,@t)\n  (rap 3 (turn tez |=(a=@t (cat 3 a 10))))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (role 'sep' 'tek' 'lap' ~)\n3.230.709.852.558.292.782.985.274.739\n~zod/try=&gt; `@t`(role 'sep' 'tek' 'lap' ~)\n'''\nsep\ntek\nlap\n'''\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lump"
        ],
        "doc": "<h1><code>++lump</code></h1>\n<p>Change with <code>++udon</code></p>\n<p>Use <a href=\"\"><code>++udon</code></a> to change <a href=\"\">noun</a>.</p>\n<h2>Accepts</h2>\n<p>A cell of an <code>++udon</code>, <code>don</code>, and a noun, <code>src</code>.</p>\n<h2>Produces</h2>\n<p>A noun.</p>\n<h2>Source</h2>\n<pre><code>++  lump                                                ::  apply patch\n  |=  [don=udon src=*]\n  ^-  *\n  ?+    p.don  ~|(%unsupported !!)\n      %a\n    ?+  -.q.don  ~|(%unsupported !!)\n      %a  q.q.don\n      %c  (lurk ((hard (list)) src) p.q.don)\n      %d  (lure src p.q.don)\n    ==\n  ::\n      %c\n    =+  dst=(lore ((hard ,@) src))\n    %-  role\n    ?+  -.q.don  ~|(%unsupported !!)\n      %a  ((hard (list ,@t)) q.q.don)\n      %c  (lurk dst p.q.don)\n    ==\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (lump [%a %a 20 25] 20)\n25\n~zod/try=&gt; (lump [%a %d [[%0 1] [%0 1]] [%0 2]] 20)\n[20 20]\n~zod/try=&gt; (lump [%c %a ~['sa' 'le'] ~['sa' 'lo']] 'sa\\0ale')\n11.473.670.267.251\n~zod/try=&gt; (,@t (lump [%c %a ~['sa' 'le'] ~['sa' 'lo']] 'sa\\0ale'))\n'''\nsa\nlo\n'''\n~zod/try=&gt; (,@t (lump [%c %c `1 [%| ~['le'] ~['lo' 'ma']] ~] 'sa\\0ale'))\n'''\nsa\nma\nlo\n'''\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lure"
        ],
        "doc": "<h1><code>++lure</code></h1>\n<p>Patch <code>a</code></p>\n<p>Patch a by references to axis and literal.</p>\n<h2>Accepts</h2>\n<p>A cell of a <a href=\"\">noun</a>, <code>a</code>, and an <a href=\"\"><code>++upas</code></a>, <code>b</code>.</p>\n<h2>Produces</h2>\n<p>A noun.</p>\n<h2>Source</h2>\n<pre><code>++  lure                                                ::  apply tree diff\n  |=  [a=* b=upas]\n  ^-  *\n  ?^  -.b\n    [$(b -.b) $(b +.b)]\n  ?+  -.b  ~|(%unsupported !!)\n    %0  .*(a [0 p.b])\n    %1  .*(a [1 p.b])\n  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (lure ~[1 2] [[%0 2] [%1 3] [%0 7]])\n[1 3 0]\n~zod/try=&gt; (lure ~[1 2 4] [[%0 2] [%1 3] [%0 7]])\n[1 3 4 0]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "limp"
        ],
        "doc": "<h1><code>++limp</code></h1>\n<p>Reverse patch</p>\n<p>Reverse a patch (preprocessor unchanged)</p>\n<h2>Accepts</h2>\n<p><code>don</code> is an <a href=\"\"><code>++udon</code></a>.</p>\n<h2>Produces</h2>\n<p>An <code>++udon</code>.</p>\n<h2>Source</h2>\n<pre><code>++  limp                                                ::  invert patch\n  |=  don=udon  ^-  udon\n  :-  p.don\n  ?+  -.q.don  ~|(%unsupported !!)\n    %a  [%a q.q.don p.q.don]\n    %c  [%c (berk p.q.don)]\n    %d  [%d q.q.don p.q.don]\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (limp [%a %a 20 40])\n[p=%a q=[%a p=40 q=20]]\n~zod/try=&gt; (limp [%c %c ~[`20 [%| ~[52 53] ~[51]] `6]])\n[p=%c q=[%c p=~[[%.y p=20] [%.n p=~[51] q=~[52 53]] [%.y p=6]]]]\n~zod/try=&gt; (limp [%a %d [[%0 1] [%0 1]] [%0 2]])\n[p=%a q=[%d p=[%0 p=2] q=[p=[%0 p=1] q=[%0 p=1]]]]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "hump"
        ],
        "doc": "<h1><code>++hump</code></h1>\n<p>Prep for diff</p>\n<p>Prep atom for diff: leave alone, cue, or split by newlines.</p>\n<h2>Accepts</h2>\n<p>A cell of an <a href=\"\"><code>++umph</code></a>, <code>pum</code>, and a <a href=\"\">noun</a>, <code>src</code>.</p>\n<h2>Produces</h2>\n<p>A noun.</p>\n<h2>Source</h2>\n<pre><code>++  hump                                                ::  general prepatch\n  |=  [pum=umph src=*]  ^-  *\n  ?+  pum  ~|(%unsupported !!)\n    %a  src\n    %b  (cue ((hard ,@) src))\n    %c  (lore ((hard ,@) src))\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (hump %a ~)\n0\n~zod/try=&gt; (hump %a 40)\n40\n~zod/try=&gt; (hump %c 40)\n[40 0]\n~zod/try=&gt; (hump %c 'as')\n[29.537 0]\n~zod/try=&gt; (hump %c 'as\\0alok')\n[29.537 7.040.876 0]\n~zod/try=&gt; (hump %b 0vph)\n[1 1]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "husk"
        ],
        "doc": "<h1><code>++husk</code></h1>\n<p>Atomize post diff</p>\n<p>Re-atomize after diff: leave alone, jam, or join with newlines.</p>\n<h2>Accepts</h2>\n<p>A cell of an <a href=\"\"><code>++umph</code></a>, <code>pum</code>, and a <a href=\"\">noun</a>, <code>dst</code>.</p>\n<h2>Produces</h2>\n<p>A noun.</p>\n<h2>Source</h2>\n<pre><code>++  husk                                                ::  unprepatch\n  |=  [pum=umph dst=*]  ^-  *\n  ?+  pum  ~|(%unsupported !!)\n    %a  dst\n    %b  (jam dst)\n    %c  (role ((hard (list ,@)) dst))\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (husk %a 0)\n0\n~zod/try=&gt; (husk %a 40)\n40\n~zod/try=&gt; (husk %c [40 0])\n2.600\n~zod/try=&gt; (rip 3 (,@ (husk %c [40 0])))\n~[40 10]\n~zod/try=&gt; (husk %c [%as 0])\n684.897\n~zod/try=&gt; (husk %c [%as 0])\n684.897\n~zod/try=&gt; (,@t (husk %c [%as 0]))\n'''\nas\n'''\n~zod/try=&gt; (husk %c [%as %lok 0])\n2.932.876.065.272.673\n~zod/try=&gt; (,@t (husk %c [%as %lok 0]))\n'''\nas\nlok\n'''\n~zod/try=&gt; (husk %b [1 1])\n817\n~zod/try=&gt; (,@uv (husk %b [1 1]))\n0vph\n~zod/try=&gt; ~0ph\n[1 1]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lurk"
        ],
        "doc": "<h1><code>++lurk</code></h1>\n<p>Apply list patch</p>\n<p>Amend list using an urge: <a href=\"\"><code>++list</code></a> of <code>[%&amp; {number skipped}]</code> and\n<code>[%| old new]</code></p>\n<h2>Accepts</h2>\n<p>A cell of a <code>++list</code> of <a href=\"\">noun</a>s, <code>hel</code>, and an <a href=\"\"><code>++urge</code></a> of a noun, <code>rug</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code> of nouns.</p>\n<h2>Source</h2>\n<pre><code>++  lurk                                                ::  apply list patch\n  |*  [hel=(list) rug=(urge)]\n  ^+  hel\n  =+  war=`_hel`~\n  |-  ^+  hel\n  ?~  rug  (flop war)\n  ?-    -.i.rug\n      &amp;\n    %=   $\n      rug  t.rug\n      hel  (slag p.i.rug hel)\n      war  (weld (flop (scag p.i.rug hel)) war)\n    ==\n  ::\n      |\n    %=  $\n      rug  t.rug\n      hel  =+  gur=(flop p.i.rug)\n           |-  ^+  hel\n           ?~  gur  hel\n           ?&gt;(&amp;(?=(^ hel) =(i.gur i.hel)) $(hel t.hel, gur t.gur))\n      war  (weld q.i.rug war)\n    ==\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (lurk \"hema\" `(urge char)`~[`1 [%| \"e\" \"ru\"] `2])\n\"hurma\"\n~zod/try=&gt; (lurk \"koltep\" `(urge char)`~[`3 [%| \"et\" \"\"] `1])\n\"kolp\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lusk"
        ],
        "doc": "<h1><code>++lusk</code></h1>\n<p><code>lcs</code> to list patch</p>\n<p>Using a common sequence, generate urge from two <a href=\"\"><code>++list</code></a>s.</p>\n<h2>Accepts</h2>\n<p>A cell of three <code>++list</code>s of <a href=\"\">noun</a>, <code>hel</code>, <code>hev</code>, and <code>lcs</code>.</p>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  lusk                                                ::  lcs to list patch\n  |*  [hel=(list) hev=(list) lcs=(list)]\n  =+  ^=  rag\n      ^-  $%  [&amp; p=@ud]\n              [| p=_lcs q=_lcs]\n          ==\n      [%&amp; 0]\n  =&gt;  .(rag [p=rag q=*(list ,_rag)])\n  =&lt;  abet  =&lt;  main\n  |%\n  ++  abet  =.(q.rag ?:(=([&amp; 0] p.rag) q.rag [p.rag q.rag]) (flop q.rag))\n  ++  done\n    |=  new=_p.rag\n    ^+  rag\n    ?-  -.p.rag\n      |   ?-  -.new\n            |  [[%| (weld p.new p.p.rag) (weld q.new q.p.rag)] q.rag]\n            &amp;  [new [p.rag q.rag]]\n          ==\n      &amp;   ?-  -.new\n            |  [new ?:(=(0 p.p.rag) q.rag [p.rag q.rag])]\n            &amp;  [[%&amp; (add p.p.rag p.new)] q.rag]\n          ==\n    ==\n  ::\n  ++  main\n    |-  ^+  +\n    ?~  hel\n      ?~  hev\n        ?&gt;(?=(~ lcs) +)\n      $(hev t.hev, rag (done %| ~ [i.hev ~]))\n    ?~  hev\n      $(hel t.hel, rag (done %| [i.hel ~] ~))\n    ?~  lcs\n      +(rag (done %| (flop hel) (flop hev)))\n    ?:  =(i.hel i.lcs)\n      ?:  =(i.hev i.lcs)\n        $(lcs t.lcs, hel t.hel, hev t.hev, rag (done %&amp; 1))\n      $(hev t.hev, rag (done %| ~ [i.hev ~]))\n    ?:  =(i.hev i.lcs)\n      $(hel t.hel, rag (done %| [i.hel ~] ~))\n    $(hel t.hel, hev t.hev, rag (done %| [i.hel ~] [i.hev ~]))\n  --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (lusk \"hamok\" \"hasok\" \"haok\")\n~[[%.y p=2] [%.n p=\"m\" q=\"s\"] [%.y p=2]]\n~zod/try=&gt; (lusk \"hamok\" \"hasok\" \"hak\")\n~[[%.y p=2] [%.n p=\"om\" q=\"os\"] [%.y p=1]]\n~zod/try=&gt; (lusk \"telroga\" \"tesomga\" \"teoga\") \n~[[%.y p=2] [%.n p=\"rl\" q=\"s\"] [%.y p=1] [%.n p=\"\" q=\"m\"] [%.y p=2]]\n~zod/try=&gt; (lurk \"telroga\" `(urge char)`~[[%.y p=2] [%.n p=\"rl\" q=\"s\"] [%.y p=1] [%.n p=\"\" q=\"m\"] [%.y p=2]])\n\"tesomga\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "nude"
        ],
        "doc": "<h1><code>++nude</code></h1>\n<p>Tree change</p>\n<p>Generate tree diff from two nouns.</p>\n<h2>Accepts</h2>\n<p>A cell of two nouns, <code>a</code> and <code>b</code>.</p>\n<h2>Produces</h2>\n<p>A cell of two <a href=\"\"><code>++upas</code></a>, <code>p</code> and <code>q</code>.</p>\n<h2>Source</h2>\n<pre><code>++  nude                                                ::  tree change\n  |=  [a=* b=*]\n  ^-  [p=upas q=upas]\n  =&lt;  [p=(tred a b) q=(tred b a)]\n  |%\n  ++  axes                                              ::  locs of nouns\n    |=  [a=@ b=*]  ^-  (map ,* axis)\n    =+  c=*(map ,* axis)\n    |-  ^-  (map ,* axis)\n    =&gt;  .(c (~(put by c) b a))\n    ?@  b\n      c\n    %-  ~(uni by c)\n    %-  ~(uni by $(a (mul 2 a), b -.b))\n    $(a +((mul 2 a)), b +.b)\n  ::\n  ++  tred                                              ::  diff a-&gt;b\n    |=  [a=* b=*]  ^-  upas\n    =|  c=(unit ,*)\n    =+  d=(axes 1 a)\n    |-  ^-  upas\n    =&gt;  .(c (~(get by d) b))\n    ?~  c\n      ?@  b\n        [%1 b]\n      =+  e=^-(upas [$(b -.b) $(b +.b)])\n      ?-  e\n        [[%1 *] [%1 *]]  [%1 [p.p.e p.q.e]]\n        *  e\n      ==\n    [%0 u.c]\n  --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (nude 40 20)\n[p=[%1 p=20] q=[%1 p=40]]\n~zod/try=&gt; (nude [5 5] 5)\n[p=[%0 p=3] q=[p=[%0 p=1] q=[%0 p=1]]]\n~zod/try=&gt; (nude \"sam\" \"sal\")\n[ p=[p=[%1 p=115] q=[p=[%1 p=97] q=[p=[%1 p=108] q=[%0 p=15]]]]\n  q=[p=[%1 p=115] q=[p=[%1 p=97] q=[p=[%1 p=109] q=[%0 p=15]]]]\n]\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pram"
        ],
        "doc": "<h1><code>++pram</code></h1>\n<p>Probable prime</p>\n<pre><code>++  pram                                                ::  rabin-miller\n  |=  a=@  ^-  ?\n  ?:  ?|  =(0 (end 0 1 a))\n          =(1 a)\n          =+  b=1\n          |-  ^-  ?\n          ?:  =(512 b)\n            |\n          ?|(=+(c=+((mul 2 b)) &amp;(!=(a c) =(a (mul c (div a c))))) $(b +(b)))\n      ==\n    |\n  =+  ^=  b\n      =+  [s=(dec a) t=0]\n      |-  ^-  [s=@ t=@]\n      ?:  =(0 (end 0 1 s))\n        $(s (rsh 0 1 s), t +(t))\n      [s t]\n  ?&gt;  =((mul s.b (bex t.b)) (dec a))\n  =+  c=0\n  |-  ^-  ?\n  ?:  =(c 64)\n    &amp;\n  =+  d=(~(raw og (add c a)) (met 0 a))\n  =+  e=(~(exp fo a) s.b d)\n  ?&amp;  ?|  =(1 e)\n          =+  f=0\n          |-  ^-  ?\n          ?:  =(e (dec a))\n            &amp;\n          ?:  =(f (dec t.b))\n            |\n          $(e (~(pro fo a) e e), f +(f))\n      ==\n      $(c +(c))\n  ==\n::\n</code></pre>\n<p>Probable prime test</p>\n<pre><code>~zod/try=&gt; (pram 31)\n%.y\n~zod/try=&gt; =+(a=2 |-(?:(=(a 31) ~ [i=(mod 31 a) t=$(a +(a))])))\n~[1 1 3 1 1 3 7 4 1 9 7 5 3 1 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1]\n~zod/try=&gt; =+(a=2 |-(?:(=(a 31) ~ [i=(mod 30 a) t=$(a +(a))])))\n~[0 0 2 0 0 2 6 3 0 8 6 4 2 0 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0]\n~zod/try=&gt; (pram 256)\n%.n\n~zod/try=&gt; (pram (dec (bex 127)))\n%.y\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ramp"
        ],
        "doc": "<h1><code>++ramp</code></h1>\n<p><code>r-m</code> prime</p>\n<pre><code>++  ramp                                                ::  make r-m prime\n  |=  [a=@ b=(list ,@) c=@]  ^-  @ux                    ::  [bits snags seed]\n  =&gt;  .(c (shas %ramp c))\n  =+  d=_@\n  |-\n  ?:  =((mul 100 a) d)\n    ~|(%ar-ramp !!)\n  =+  e=(~(raw og c) a)\n  ?:  &amp;((levy b |=(f=@ !=(1 (mod e f)))) (pram e))\n    e\n  $(c +(c), d (shax d))\n::\n</code></pre>\n<p>Random <code>a</code> bit prime, which isn't 1 modulo a list of other numbers,\nusing salt <code>c</code>.</p>\n<pre><code>~zod/try=&gt; (ramp 20 ~ %hamelok)\n0xf.1f0d\n~zod/try=&gt; (ramp 20 ~ %hameloe)\n0x2.d341\n~zod/try=&gt; (ramp 5 ~ %kole)\n0x1f\n~zod/try=&gt; (ramp 7 ~ %kole)\n0x4f\n~zod/try=&gt; (ramp 7 ~[0x4e] %kole)\n0x43\n~zod/try=&gt; `@uw`(ramp 128 ~ %late)\n0w3y.irKIL.l-pp1.2CkG4.3lsTF\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fo"
        ],
        "doc": "<h1><code>++fo</code></h1>\n<p>Prime engine</p>\n<pre><code>++  fo                                                  ::  modulo prime\n  |_  a=@\n</code></pre>\n<p>XX DO NOT RERUN GET.LS, THERE EXIST ARM COLLISIONS</p>\n<p>Core for performing arithmetic modulo a prime number</p>\n<pre><code>~zod/try=&gt; ~(. fo 79)\n&lt;7.get [@ud &lt;373.jdd 100.kzl 1.ypj %164&gt;]&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "dif"
        ],
        "doc": "<h1><code>++dif</code></h1>\n<p>Difference</p>\n<pre><code>  ++  dif\n    |=  [b=@ c=@]\n    (sit (sub (add a b) (sit c)))\n  ::\n</code></pre>\n<p>Subtract</p>\n<pre><code>~zod/try=&gt; (~(dif fo 79) 10 5)\n5\n~zod/try=&gt; (~(dif fo 79) 5 10)\n74\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "exp"
        ],
        "doc": "<h1><code>++exp</code></h1>\n<p>Exponent</p>\n<pre><code>  ++  exp\n    |=  [b=@ c=@]\n    ?:  =(0 b)\n      1\n    =+  d=$(b (rsh 0 1 b))\n    =+  e=(pro d d)\n    ?:(=(0 (end 0 1 b)) e (pro c e))\n  ::\n</code></pre>\n<p>Exponent</p>\n<pre><code>~zod/try=&gt; (~(exp fo 79) 3 5)\n46\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "fra"
        ],
        "doc": "<h1><code>++fra</code></h1>\n<p>Divide</p>\n<pre><code>  ++  fra\n    |=  [b=@ c=@]\n    (pro b (inv c))\n  ::\n</code></pre>\n<p>Divide</p>\n<pre><code>~zod/try=&gt; (~(fra fo 79) 20 4)\n5\n~zod/try=&gt; (~(fra fo 79) 7 11)\n15\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "inv"
        ],
        "doc": "<h1><code>++inv</code></h1>\n<p>Inverse</p>\n<pre><code>  ++  inv\n    |=  b=@\n    =+  c=(dul:si u:(egcd b a) a)\n    c\n  ::\n</code></pre>\n<p>Multiplicative inverse</p>\n<pre><code>~zod/try=&gt; (~(inv fo 79) 12)\n33\n~zod/try=&gt; (~(pro fo 79) 12 33)\n1\n~zod/try=&gt; (~(inv fo 79) 0)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "pro"
        ],
        "doc": "<h1><code>++pro</code></h1>\n<p>Product</p>\n<pre><code>  ++  pro\n    |=  [b=@ c=@]\n    (sit (mul b c))\n  ::\n</code></pre>\n<p>Product</p>\n<pre><code>~zod/try=&gt; (~(pro fo 79) 5 10)\n50\n~zod/try=&gt; (~(pro fo 79) 5 20)\n21\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sit"
        ],
        "doc": "<h1><code>++sit</code></h1>\n<p>Bounds</p>\n<pre><code>  ++  sit\n    |=  b=@\n    (mod b a)\n  ::\n</code></pre>\n<p>Bounds check</p>\n<pre><code>~zod/try=&gt; (~(sit fo 79) 9)\n9\n~zod/try=&gt; (~(sit fo 79) 99)\n20\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "sum"
        ],
        "doc": "<h1><code>++sum</code></h1>\n<p>Sum</p>\n<pre><code>  ++  sum\n    |=  [b=@ c=@]\n    (sit (add b c))\n  --\n</code></pre>\n<p>Add</p>\n<pre><code>~zod/try=&gt; (~(sum fo 79) 9 9)\n18\n~zod/try=&gt; (~(sum fo 79) 70 9)\n0\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "ga"
        ],
        "doc": "<h1><code>++ga</code></h1>\n<pre><code>++  ga                                                  ::  GF (bex p.a)\n  |=  a=[p=@ q=@ r=@]                                   ::  dim poly gen\n  =+  si=(bex p.a)\n  =+  ma=(dec si)\n  =&gt;  |%\n</code></pre>\n<p>RSA internals</p>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "dif"
        ],
        "doc": "<h1><code>++dif</code></h1>\n<pre><code>      ++  dif                                           ::  add and sub\n        |=  [b=@ c=@]\n        ~|  [%dif-ga a]\n        ?&gt;  &amp;((lth b si) (lth c si))\n        (mix b c)\n      ::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "dub"
        ],
        "doc": "<h1><code>++dub</code></h1>\n<pre><code>      ++  dub                                           ::  mul by x\n        |=  b=@\n        ~|  [%dub-ga a]\n        ?&gt;  (lth b si)\n        ?:  =(1 (cut 0 [(dec p.a) 1] b))\n          (dif (sit q.a) (sit (lsh 0 1 b)))\n        (lsh 0 1 b)\n      ::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "pro"
        ],
        "doc": "<h1><code>++pro</code></h1>\n<pre><code>      ++  pro                                           ::  slow multiply\n        |=  [b=@ c=@]\n        ?:  =(0 b)\n          0\n        ?:  =(1 (dis 1 b))\n          (dif c $(b (rsh 0 1 b), c (dub c)))\n        $(b (rsh 0 1 b), c (dub c))\n      ::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "toe"
        ],
        "doc": "<h1><code>++toe</code></h1>\n<pre><code>      ++  toe                                           ::  exp/log tables\n        =+  ^=  nu\n            |=  [b=@ c=@]\n            ^-  (map ,@ ,@)\n            =+  d=*(map ,@ ,@)\n            |-\n            ?:  =(0 c)\n              d\n            %=  $\n              c  (dec c)\n              d  (~(put by d) c b)\n            ==\n        =+  [p=(nu 0 (bex p.a)) q=(nu ma ma)]\n        =+  [b=1 c=0]\n        |-  ^-  [p=(map ,@ ,@) q=(map ,@ ,@)]\n        ?:  =(ma c)\n          [(~(put by p) c b) q]\n        %=  $\n          b  (pro r.a b)\n          c  +(c)\n          p  (~(put by p) c b)\n          q  (~(put by q) b c)\n        ==\n      ::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "sit"
        ],
        "doc": "<h1><code>++sit</code></h1>\n<pre><code>      ++  sit                                           ::  reduce\n        |=  b=@\n        (mod b (bex p.a))\n      --\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "fra"
        ],
        "doc": "<h1><code>++fra</code></h1>\n<pre><code>  ++  fra                                               ::  divide\n    |=  [b=@ c=@]\n    (pro b (inv c))\n  ::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "inv"
        ],
        "doc": "<h1><code>++inv</code></h1>\n<pre><code>  ++  inv                                               ::  invert\n    |=  b=@\n    ~|  [%inv-ga a]\n    =+  c=(~(get by q) b)\n    ?~  c  !!\n    =+  d=(~(get by p) (sub ma u.c))\n    (need d)\n  ::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "pow"
        ],
        "doc": "<h1><code>++pow</code></h1>\n<pre><code>  ++  pow                                               ::  exponent\n    |=  [b=@ c=@]\n    =+  [d=1 e=c f=0]\n    |-\n    ?:  =(p.a f)\n      d\n    ?:  =(1 (cut 0 [f 1] b))\n      $(d (pro d e), e (pro e e), f +(f))\n    $(e (pro e e), f +(f))\n  ::\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "pro"
        ],
        "doc": "<h1><code>++pro</code></h1>\n<pre><code>  ++  pro                                               ::  multiply\n    |=  [b=@ c=@]\n    ~|  [%pro-ga a]\n    =+  d=(~(get by q) b)\n    ?~  d  0\n    =+  e=(~(get by q) c)\n    ?~  e  0\n    =+  f=(~(get by p) (mod (add u.d u.e) ma))\n    (need f)\n  --\n</code></pre>\n<p>XX document</p>\n<hr>\n"
    },
    {
        "keys": [
            "crua"
        ],
        "doc": "<h1><code>++crua</code></h1>\n<pre><code>++  crua  !:                                            ::  cryptosuite A (RSA)\n  ^-  acru\n  =|  [mos=@ pon=(unit ,[p=@ q=@ r=[p=@ q=@] s=_*fu])]\n  =&gt;  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "mx"
        ],
        "doc": "<h1><code>++mx</code></h1>\n<pre><code>      ++  mx  (dec (met 0 mos))                         ::  bit length\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "dap"
        ],
        "doc": "<h1><code>++dap</code></h1>\n<pre><code>      ++  dap                                           ::  OEAP decode\n        |=  [wid=@ xar=@ dog=@]  ^-  [p=@ q=@]\n        =+  pav=(sub wid xar)\n        =+  qoy=(cut 0 [xar pav] dog)\n        =+  dez=(mix (end 0 xar dog) (shaw %pad-b xar qoy))\n        [dez (mix qoy (shaw %pad-a pav dez))]\n      ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pad"
        ],
        "doc": "<h1><code>++pad</code></h1>\n<pre><code>      ++  pad                                           ::  OEAP encode\n        |=  [wid=@ rax=[p=@ q=@] meg=@]  ^-  @\n        =+  pav=(sub wid p.rax)\n        ?&gt;  (gte pav (met 0 meg))\n        ^-  @\n        =+  qoy=(mix meg (shaw %pad-a pav q.rax))\n        =+  dez=(mix q.rax (shaw %pad-b p.rax qoy))\n        (can 0 [p.rax dez] [pav qoy] ~)\n  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pull"
        ],
        "doc": "<h1><code>++pull</code></h1>\n<pre><code>      ++  pull  |=(a=@ (~(exp fo mos) 3 a))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "push"
        ],
        "doc": "<h1><code>++push</code></h1>\n<pre><code>      ++  push  |=(a=@ (~(exp fo mos) 5 a))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pump"
        ],
        "doc": "<h1><code>++pump</code></h1>\n<pre><code>      ++  pump\n        |=  a=@  ^-  @\n        ?~  pon  !!\n        (out.s.u.pon (exp.s.u.pon p.r.u.pon (sit.s.u.pon a)))\n      ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "punt"
        ],
        "doc": "<h1><code>++punt</code></h1>\n<pre><code>      ++  punt\n        |=  a=@  ^-  @\n        ?~  pon  !!\n        (out.s.u.pon (exp.s.u.pon q.r.u.pon (sit.s.u.pon a)))\n  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "as"
        ],
        "doc": "<h1><code>++as</code></h1>\n<pre><code>  ++  as\n    =&gt;  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "haul"
        ],
        "doc": "<h1><code>++haul</code></h1>\n<pre><code>        ++  haul                                        ::  revealing haul\n          |=  a=pass\n          !!\n    ^?\n    |%  ++  seal\n          |=  [a=pass b=@ c=@]\n          ^-  @\n          !!\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "seal"
        ],
        "doc": "<h1><code>++seal</code></h1>\n<pre><code>XX document\n\n###++sign\n\n```\n        ++  sign\n          |=  [a=@ b=@]  ^-  @\n          !!\n```\n\nXX document\n\n###++sure\n\n```\n        ++  sure\n          |=  [a=@ b=@]\n          ^-  (unit ,@)\n          !!\n```\n\nXX document\n\n###++tear\n\n```\n        ++  tear\n          |=  [a=pass b=@]\n          ^-  (unit ,[p=@ q=@])\n          !!\n  ::\n```\n\nXX document\n\n###++de\n\n```\n  ++  de\n    |+  [key=@ cep=@]  ^-  (unit ,@)\n    !!\n  ::\n```\n\nXX document\n\n###++dy\n\n```\n  ++  dy\n    |+  [a=@ b=@]  ^-  @\n    !!\n```\n\nXX document\n\n###++en\n\n```\n  ++  en\n    |+  [key=@ msg=@]  ^-  @ux\n    !!\n  ::\n```\n\nXX document\n\n###++ex\n\n```\n  ++  ex  ^?\n    |%  ++  fig  ^-  @uvH  (shaf %bfig puc)\n```\n\nXX document\n\n###++fig\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pac"
        ],
        "doc": "<h1><code>++pac</code></h1>\n<pre><code>        ++  pac  ^-  @uvG  (end 6 1 (shaf %acod sec))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pub"
        ],
        "doc": "<h1><code>++pub</code></h1>\n<pre><code>        ++  pub  ^-  pass  (cat 3 'b' puc)\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sec"
        ],
        "doc": "<h1><code>++sec</code></h1>\n<pre><code>        ++  sec  ^-  ring  sed\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "nu"
        ],
        "doc": "<h1><code>++nu</code></h1>\n<pre><code>  ++  nu\n    ^?\n    |%  ++  com\n          |=  a=@\n          ^+  ^?(..nu)\n          ..nu(sed ~, puc a)\n        ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "elcm"
        ],
        "doc": "<h1><code>++elcm</code></h1>\n<pre><code>        ++  elcm\n          |=  [a=@ b=@]\n          (div (mul a b) d:(egcd a b))\n        ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "eldm"
        ],
        "doc": "<h1><code>++eldm</code></h1>\n<pre><code>        ++  eldm\n          |=  [a=@ b=@ c=@]\n          (~(inv fo (elcm (dec b) (dec c))) a)\n        ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ersa"
        ],
        "doc": "<h1><code>++ersa</code></h1>\n<pre><code>        ++  ersa\n          |=  [a=@ b=@]\n          [a b [(eldm 3 a b) (eldm 5 a b)] (fu a b)]\n    ^?\n    |%  ++  com\n          |=  a=@\n          ^+  ^?(..nu)\n          ..nu(mos a, pon ~)\n        ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "com"
        ],
        "doc": "<h1><code>++com</code></h1>\n<pre><code>XX document\n\n###++pit\n\n```\n        ++  pit\n          |=  [a=@ b=@]\n          ^+  ^?(..nu)\n          ..nu(sed b, puc (puck:ed b))\n        ::\n```\n\nXX document\n\n###++nol\n\n```\n        ++  nol\n          |=  a=@\n          ^+  ^?(..nu)\n          ..nu(sed a, puc (puck:ed a))\n```\n\nXX document\n\n###++bruw\n\n```\n++  bruw                                                ::  create keypair\n  |=  [a=@ b=@]                                         ::  width seed\n  ^-  acru\n  (pit:nu:crua a b)\n::\n```\n\nXX document\n\n###++haul\n\n```\n        ++  haul                                        ::  revealing haul\n          |=  a=pass\n          !!\n    ^?\n    |%  ++  seal\n          |=  [a=pass b=@ c=@]\n          ^-  @\n          !!\n```\n\nXX document\n\n###++weur\n\n```\n++  weur                                                ::  activate secret key\n  |=  a=ring\n  ^-  acru\n  =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]\n  ?&gt;  =('A' mag)\n  (nol:nu:crua bod)\n::\n```\n\nXX document\n\n###++trua\n\n```\n++  trua                                                ::  test rsa\n  |=  msg=@tas\n  ^-  @\n  =+  ali=(bruw 1.024 (shax 'ali'))\n  =+  bob=(bruw 1.024 (shax 'bob'))\n  =+  tef=(sign:as.ali [0 msg])\n  =+  lov=(sure:as.ali [0 tef])\n  ?.  &amp;(?=(^ lov) =(msg u.lov))\n    ~|(%test-fail-sign !!)\n  =+  key=(shax (shax (shax msg)))\n  =+  sax=(seal:as.ali pub:ex.bob key msg)\n  =+  tin=(tear:as.bob pub:ex.ali sax)\n  ?.  &amp;(?=(^ tin) =(key p.u.tin) =(msg q.u.tin))\n    ~|(%test-fail-seal !!)\n  msg\n::\n```\n\nXX document\n\n###++crub\n\n```\n++  crub                                                ::  cryptosuite B (Ed)\n  ^-  acru\n  =|  [puc=pass sed=ring]\n  =&gt;  |%\n```\n\nXX document\n\n###++dap\n\n```\n      ++  dap                                           ::  OEAP decode\n        |=  [wid=@ xar=@ dog=@]  ^-  [p=@ q=@]\n        =+  pav=(sub wid xar)\n        =+  qoy=(cut 0 [xar pav] dog)\n        =+  dez=(mix (end 0 xar dog) (shaw %pad-b xar qoy))\n        [dez (mix qoy (shaw %pad-a pav dez))]\n      ::\n```\n\nXX document\n\n###++pad\n\n```\n      ++  pad                                           ::  OEAP encode\n        |=  [wid=@ rax=[p=@ q=@] meg=@]  ^-  @\n        =+  pav=(sub wid p.rax)\n        ?&gt;  (gte pav (met 0 meg))\n        ^-  @\n        =+  qoy=(mix meg (shaw %pad-a pav q.rax))\n        =+  dez=(mix q.rax (shaw %pad-b p.rax qoy))\n        (can 0 [p.rax dez] [pav qoy] ~)\n  |%\n```\n\nXX document\n\n###++as\n\n```\n  ++  as\n    =&gt;  |%\n```\n\nXX document\n\n###++haul\n\n```\n        ++  haul                                        ::  revealing haul\n          |=  a=pass\n          !!\n    ^?\n    |%  ++  seal\n          |=  [a=pass b=@ c=@]\n          ^-  @\n          !!\n```\n\nXX document\n\n###++seal\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sign"
        ],
        "doc": "<h1><code>++sign</code></h1>\n<pre><code>        ++  sign\n          |=  [a=@ b=@]  ^-  @\n          !!\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sure"
        ],
        "doc": "<h1><code>++sure</code></h1>\n<pre><code>        ++  sure\n          |=  [a=@ b=@]\n          ^-  (unit ,@)\n          !!\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "tear"
        ],
        "doc": "<h1><code>++tear</code></h1>\n<pre><code>        ++  tear\n          |=  [a=pass b=@]\n          ^-  (unit ,[p=@ q=@])\n          !!\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "de"
        ],
        "doc": "<h1><code>++de</code></h1>\n<pre><code>  ++  de\n    |+  [key=@ cep=@]  ^-  (unit ,@)\n    !!\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "dy"
        ],
        "doc": "<h1><code>++dy</code></h1>\n<pre><code>  ++  dy\n    |+  [a=@ b=@]  ^-  @\n    !!\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "en"
        ],
        "doc": "<h1><code>++en</code></h1>\n<pre><code>  ++  en\n    |+  [key=@ msg=@]  ^-  @ux\n    !!\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "ex"
        ],
        "doc": "<h1><code>++ex</code></h1>\n<pre><code>  ++  ex  ^?\n    |%  ++  fig  ^-  @uvH  (shaf %bfig puc)\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "fig"
        ],
        "doc": "<h1><code>++fig</code></h1>\n<pre><code>XX document\n\n###++pac\n\n```\n        ++  pac  ^-  @uvG  (end 6 1 (shaf %acod sec))\n```\n\nXX document\n\n###++pub\n\n```\n        ++  pub  ^-  pass  (cat 3 'b' puc)\n```\n\nXX document\n\n###++sec\n\n```\n        ++  sec  ^-  ring  sed\n  ::\n```\n\nXX document\n\n###++nu\n\n```\n  ++  nu\n    ^?\n    |%  ++  com\n          |=  a=@\n          ^+  ^?(..nu)\n          ..nu(sed ~, puc a)\n        ::\n```\n\nXX document\n\n###++com\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pit"
        ],
        "doc": "<h1><code>++pit</code></h1>\n<pre><code>        ++  pit\n          |=  [a=@ b=@]\n          ^+  ^?(..nu)\n          ..nu(sed b, puc (puck:ed b))\n        ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "nol"
        ],
        "doc": "<h1><code>++nol</code></h1>\n<pre><code>        ++  nol\n          |=  a=@\n          ^+  ^?(..nu)\n          ..nu(sed a, puc (puck:ed a))\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "brew"
        ],
        "doc": "<h1><code>++brew</code></h1>\n<pre><code>++  brew                                                ::  create keypair\n  |=  [a=@ b=@]                                         ::  width seed\n  ^-  acru\n  (pit:nu:crub a b)\n::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "hail"
        ],
        "doc": "<h1><code>++hail</code></h1>\n<pre><code>++  hail                                                ::  activate public key\n  |=  a=pass\n  ^-  acru\n  =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]\n  ?&gt;  =('b' mag)\n  (com:nu:crub bod)\n::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "wear"
        ],
        "doc": "<h1><code>++wear</code></h1>\n<pre><code>++  wear                                                ::  activate secret key\n  |=  a=ring\n  ^-  acru\n  =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]\n  ?&gt;  =('b' mag)\n  (nol:nu:crub bod)\n::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "trub"
        ],
        "doc": "<h1><code>++trub</code></h1>\n<pre><code>++  trub                                                ::  test ed\n  |=  msg=@tas\n  ^-  @\n  =+  ali=(brew 1.024 (shax 'ali'))\n  =+  bob=(brew 1.024 (shax 'bob'))\n  =+  tef=(sign:as.ali [0 msg])\n  =+  lov=(sure:as.ali [0 tef])\n  ?.  &amp;(?=(^ lov) =(msg u.lov))\n    ~|(%test-fail-sign !!)\n  =+  key=(shax (shax (shax msg)))\n  =+  sax=(seal:as.ali pub:ex.bob key msg)\n  =+  tin=(tear:as.bob pub:ex.ali sax)\n  ?.  &amp;(?=(^ tin) =(key p.u.tin) =(msg q.u.tin))\n    ~|(%test-fail-seal !!)\n  msg\n::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "hmac"
        ],
        "doc": "<h1><code>++hmac</code></h1>\n<pre><code>++  hmac                                                ::  HMAC-SHA1\n  |=  [key=@ mes=@]\n  =+  ip=(fil 3 64 0x36)\n  =+  op=(fil 3 64 0x5c)\n  =+  ^=  kex\n      ?:  (gth (met 3 key) 64)\n        (lsh 3 44 (shan (swap 3 key)))\n      (lsh 3 (sub 64 (met 3 key)) (swap 3 key))\n  =+  inn=(shan (swap 3 (cat 3 (swap 3 mes) (mix ip kex))))\n  (shan (swap 3 (cat 3 inn (mix op kex))))\n::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "epur"
        ],
        "doc": "<h1><code>++epur</code></h1>\n<p>Top-level URL parser</p>\n<p>Parses an entire URL.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <a href=\"/docs/hoon/library/1#++cord\"><code>++cord</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++purl</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  epur                                                ::  url/header parser\n      =&lt;  |=(a=cord (rush a auri))\n      |%\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (epur 'http://127.0.0.1/')\n[~ [p=[p=%.n q=~ r=[%.n p=.127.0.0.1]] q=[p=~ q=&lt;||&gt;] r=~]]\n~zod/main=&gt; (epur 'http://www.google.com/')\n[~ [p=[p=%.n q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;||&gt;] r=~]]\n~zod/main=&gt; (epur 'https://www.google.com/')\n[~ [p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;||&gt;] r=~]]\n~zod/main=&gt; (epur 'https//www.google.com/')\n~\n~zod/main=&gt; (epur 'https://www.google.com:200/')\n[~ [p=[p=%.y q=[~ 200] r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;||&gt;] r=~]]\n~zod/main=&gt; (epur 'https://www.google.com:200/search')\n[ ~\n  [p=[p=%.y q=[~ 200] r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~]\n]\n~zod/main=&gt; (epur 'https://www.google.com/search')\n[~ [p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~]]\n~zod/main=&gt; (epur 'https://www.google.com/search?q=urbit')\n[ ~ \n  [ p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]]\n    q=[p=~ q=&lt;|search|&gt;]\n    r=~[[p='q' q='urbit']]\n  ]\n]\n~zod/main=&gt; (epur 'https://www.google.com/search?q=urb it')\n~\n~zod/main=&gt; (epur 'https://www.google.com/search?q=urb%20it')\n[ ~\n  [ p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] \n    q=[p=~ q=&lt;|search|&gt;] \n    r=~[[p='q' q='urb it']]\n  ]\n]\n~zod/main=&gt; (epur 'https://www.google.com/search?q=urbit%20escaping%3F')\n[ ~ \n  [ p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] \n    q=[p=~ q=&lt;|search|&gt;]\n    r=~[[p='q' q='urbit escaping?']]\n  ]\n]\n</code></pre>\n"
    },
    {
        "keys": [
            "apat"
        ],
        "doc": "<h1><code>++apat</code></h1>\n<p>URL path as ++pork</p>\n<p>Parses a URL path as a <a href=\"\"><code>++pork</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++rule</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  apat                                              ::  2396 abs_path\n        %+  cook  deft\n        (ifix [fas ;~(pose fas (easy ~))] (more fas smeg))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"/foo/mol/lok\" apat:epur)\n[p=~ q=&lt;|foo mol lok|&gt;]\n~zod/try=&gt; (scan \"/foo/mol/lok.htm\" apat:epur)\n[p=[~ ~.htm] q=&lt;|foo mol lok|&gt;]\n</code></pre>\n"
    },
    {
        "keys": [
            "auri"
        ],
        "doc": "<h1><code>++auri</code></h1>\n<p>URL parsing rule</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++purl</code></a>.</p>\n<h2>Produces</h2>\n<p>XX</p>\n<h2>Source</h2>\n<pre><code>++  auri\n        %+  cook\n          |=  a=purl\n          ?.(=([&amp; /localhost] r.p.a) a a(p.p &amp;))\n        ;~  plug\n          ;~  plug\n            %+  sear\n              |=  a=@t\n              ^-  (unit ,?)\n              ?+(a ~ %http [~ %|], %https [~ %&amp;])\n            ;~(sfix scem ;~(plug col fas fas))\n            thor\n          ==\n          ;~(plug ;~(pose apat (easy *pork)) yque)\n        ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (auri:epur [1 1] \"http://127.0.0.1/\")\n[ p=[p=1 q=18] \n    q\n  [ ~\n      u\n    [ p=[p=[p=%.n q=~ r=[%.n p=.127.0.0.1]] q=[p=~ q=&lt;||&gt;] r=~]\n      q=[p=[p=1 q=18] q=\"\"]\n    ]\n  ]\n]\n~zod/main=&gt; (auri:epur [1 1] \"http://www.google.com/\")\n[ p=[p=1 q=23]\n    q\n  [ ~\n     u\n    [ p=[p=[p=%.n q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;||&gt;] r=~] \n      q=[p=[p=1 q=23] q=\"\"]\n    ]\n  ]\n]\n~zod/main=&gt; (auri:epur [1 1] \"https://www.google.com/\")\n[ p=[p=1 q=24]\n    q\n  [ ~\n     u\n    [ p=[p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;||&gt;] r=~] \n      q=[p=[p=1 q=24] q=\"\"]\n    ]\n  ]\n]\n~zod/main=&gt; (auri:epur [1 1] \"https//www.google.com/\")\n[ p=[p=1 q=6] q=~]\n~zod/main=&gt; (auri:epur [1 1] \"https://www.google.com:200/\")\n[ p=[p=1 q=28]\n  q=[~ u=[p=[p=[p=%.y q=[~ 200] r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;||&gt;] r=~] q=[p=[p=1 q=28] q=\"\"]]]\n]\n~zod/main=&gt; (auri:epur [1 1] \"https://www.google.com:200/search\")\n[ p=[p=1 q=34]\n  q=[~ u=[p=[p=[p=%.y q=[~ 200] r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~] q=[p=[p=1 q=34] q=\"\"]]]\n]\n~zod/main=&gt; (auri:epur [1 1] \"https://www.google.com/search\")\n[ p=[p=1 q=30]\n  q=[~ u=[p=[p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~] q=[p=[p=1 q=30] q=\"\"]]]\n]\n~zod/main=&gt; (auri:epur [1 1] \"https://www.google.com/search?q=urbit\")\n[ p=[p=1 q=38]\n    q\n  [ ~\n      u\n    [ p=[p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~[[p='q' q='urbit']]]\n      q=[p=[p=1 q=38] q=\"\"]\n    ]\n  ]\n]\n~zod/main=&gt; (auri:epur [1 1] \"https://www.google.com/search?q=urb it\")\n[ p=[p=1 q=36]\n    q\n  [ ~\n      u\n    [ p=[p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~[[p='q' q='urb']]]\n      q=[p=[p=1 q=36] q=\" it\"]\n    ]\n  ]\n]\n~zod/main=&gt; (auri:epur [1 1] \"https://www.google.com/search?q=urb%20it\")\n[ p=[p=1 q=41]\n    q\n  [ ~\n      u\n    [ p=[p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~[[p='q' q='urb it']]]\n      q=[p=[p=1 q=41] q=\"\"]\n    ]\n  ]\n]\n~zod/main=&gt; (auri:epur [1 1] \"https://www.google.com/search?q=urbit%20escaping%3F\")\n[ p=[p=1 q=52]\n    q\n  [ ~\n      u\n    [ p=[p=[p=%.y q=~ r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~[[p='q' q='urbit escaping?']]]\n      q=[p=[p=1 q=52] q=\"\"]\n    ]\n  ]\n]\n</code></pre>\n"
    },
    {
        "keys": [
            "cock"
        ],
        "doc": "<h1><code>++cock</code></h1>\n<p>HTTP cookies, results in associative list of cord to cord.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  cock                                              ::  cookie\n        (most ;~(plug sem ace) ;~(plug toke ;~(pfix tis tosk)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"sam=lop\" cock:epur)\n[['sam' 'lop'] ~]\n~zod/try=&gt; (scan \"sam=lop; res=\\\"salo don -keg!mo\\\"\" cock:epur)\n[['sam' 'lop'] ~[['res' 'salo don -keg!mo']]]\n~zod/try=&gt; (scan \"sam=lop; res=\\\"salo don -keg!mo\\\";  so\" cock:epur)\n! {1 34}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "dlab"
        ],
        "doc": "<h1><code>++dlab</code></h1>\n<p>Domain label: alphanumeric, with <code>-</code> allowed in middle.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  dlab                                              ::  2396 domainlabel\n        %+  sear\n          |=  a=@ta\n          ?.(=('-' (rsh 3 (dec (met 3 a)) a)) [~ u=a] ~)\n        %+  cook  cass\n        ;~(plug aln (star alp))\n      ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"google\" dlab:epur)\n~.google\n~zod/try=&gt; (scan \"lera2\" dlab:epur)\n~.lera2\n~zod/try=&gt; (scan \"gor-tem\" dlab:epur)\n~.gor-tem\n~zod/try=&gt; (scan \"gortem-\" dlab:epur)\n! {1 8}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "fque"
        ],
        "doc": "<h1><code>++fque</code></h1>\n<p>One or more query string characters</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  fque  (cook crip (plus pquo))                     ::  normal query field\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"%20\" fque:epur)\n' '\n~zod/try=&gt; (scan \"sam\" fque:epur)\n'sam'\n~zod/try=&gt; (scan \"les+tor\" fque:epur)\n'les tor'\n~zod/try=&gt; (scan \"sore-%22mek%22\" fque:epur)\n'sore-\"mek\"'\n~zod/try=&gt; (scan \"\" fque:epur)\n! {1 1}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "fquu"
        ],
        "doc": "<h1><code>++fquu</code></h1>\n<p>Zero or more query string characters</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  fquu  (cook crip (star pquo))                     ::  optional field\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"%20\" fquu:epur)\n' '\n~zod/try=&gt; (scan \"sam\" fquu:epur)\n'sam'\n~zod/try=&gt; (scan \"les+tor\" fquu:epur)\n'les tor'\n~zod/try=&gt; (scan \"sore-%22mek%22\" fquu:epur)\n'sore-\"mek\"'\n~zod/try=&gt; (scan \"\" fquu:epur)\n''\n</code></pre>\n"
    },
    {
        "keys": [
            "pcar"
        ],
        "doc": "<h1><code>++pcar</code></h1>\n<p>Single URL path character: literal, <code>%</code> escape, subpath delimiter, <code>:</code>\nor <code>@</code></p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pcar  ;~(pose pure pesc psub col pat)             ::  2396 path char\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"a\" pcar:epur)\n~~a\n~zod/try=&gt; (scan \"ab\" pcar:epur)\n! {1 2}\n! exit\n~zod/try=&gt; (scan \"-\" pcar:epur)\n~~-\n~zod/try=&gt; (scan \".\" pcar:epur)\n~~~.\n~zod/try=&gt; (scan \"%20\" pcar:epur)\n~~.\n~zod/try=&gt; (scan \"!\" pcar:epur)\n~~~21.\n</code></pre>\n"
    },
    {
        "keys": [
            "pcok"
        ],
        "doc": "<h1><code>++pcok</code></h1>\n<p>Cookie character</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pcok  ;~(less bas sem com doq prn)                ::  cookie char\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"a\" pcok:epur)\n~~a\n~zod/try=&gt; (scan \"ab\" pcok:epur)\n! {1 2}\n! exit\n~zod/try=&gt; (scan \"!\" pcok:epur)\n~~~21.\n~zod/try=&gt; (scan \";\" pcok:epur)\n! {1 2}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "pesc"
        ],
        "doc": "<h1><code>++pesc</code></h1>\n<p>URL <code>%</code> escape, by two hex characters.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pesc  ;~(pfix cen mes)                            ::  2396 escaped\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `@t`(scan \"%22\" pesc:epur)\n'\"'\n~zod/try=&gt; `@t`(scan \"%20\" pesc:epur)\n' '\n</code></pre>\n"
    },
    {
        "keys": [
            "pold"
        ],
        "doc": "<h1><code>++pold</code></h1>\n<p>Old URL <code>' '</code> escape</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pold  (cold ' ' (just '+'))                       ::  old space code\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `@t`(scan \"+\" pold:epur)\n' '\n~zod/try=&gt; `@t`(scan \" \" pold:epur)\n! {1 1}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "pque"
        ],
        "doc": "<h1><code>++pque</code></h1>\n<p>Irregular query string character.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pque  ;~(pose pcar fas wut)                       ::  3986 query char\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `@t`(scan \"a\" pque:epur)\n'a'\n~zod/try=&gt; `@t`(scan \"?\" pque:epur)\n'?'\n~zod/try=&gt; `@t`(scan \"%20\" pque:epur)\n' '\n~zod/try=&gt; `@t`(scan \"+\" pque:epur)\n'+'\n</code></pre>\n"
    },
    {
        "keys": [
            "pquo"
        ],
        "doc": "<h1><code>++pquo</code></h1>\n<p>Character in query string key/value</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pquo  ;~(pose pure pesc pold)                     ::  normal query char\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"a\" pquo:epur)\n'a'\n~zod/try=&gt; (scan \"ab\" pquo:epur)\n! {1 2}\n! exit\n~zod/try=&gt; (scan \"%22\" pquo:epur)\n'\"'\n~zod/try=&gt; (scan \"%20\" pquo:epur)\n' '\n~zod/try=&gt; (scan \"+\" pquo:epur)\n' '\n</code></pre>\n"
    },
    {
        "keys": [
            "pure"
        ],
        "doc": "<h1><code>++pure</code></h1>\n<p>URL-safe character</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  pure  ;~(pose aln hep dot cab sig)                ::  2396 unreserved\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"a\" pure:epur)\n~~a\n~zod/try=&gt; (scan \"%20\" pure:epur)\n! {1 1}\n! exit\n~zod/try=&gt; (scan \".\" pure:epur)\n~~~.\n~zod/try=&gt; (scan \"-\" pure:epur)\n~~-\n</code></pre>\n"
    },
    {
        "keys": [
            "psub"
        ],
        "doc": "<h1><code>++psub</code></h1>\n<p>URL path subdelimeter</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  psub  ;~  pose                                    ::  3986 sub-delims\n                  zap  buc  pam  soq  pel  per\n                  tar  lus  com  sem  tis\n                ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `@t`(scan \"+\" psub:epur)\n'+'\n~zod/try=&gt; `@t`(scan \"(\" psub:epur)\n'('\n~zod/try=&gt; `@t`(scan \"$\" psub:epur)\n'$'\n~zod/try=&gt; `@t`(scan \"a\" psub:epur)\n! {1 1}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "ptok"
        ],
        "doc": "<h1><code>++ptok</code></h1>\n<p>Character valid in HTTP token</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  ptok  ;~  pose                                    ::  2616 token\n                  aln  zap  hax  buc  cen  pam  soq  tar  lus\n                  hep  dot  ket  cab  tec  bar  sig\n                ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `tape`(murn =+(a=' ' |-(`tape`?:(=(0x7f a) ~ [a $(a +(a))]))) (curr rush ptok):epur)\n\"!#$%&amp;'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~\"\n~zod/try=&gt; `tape`(skim =+(a=' ' |-(`tape`?:(=(0x7f a) ~ [a $(a +(a))]))) |=(a=char ?=(~ (rush a ptok:epur))))\n\" \"(),/:;&lt;=&gt;?@[\\]{}\"\n</code></pre>\n"
    },
    {
        "keys": [
            "scem"
        ],
        "doc": "<h1><code>++scem</code></h1>\n<p>URI scheme: alphabetic character, followed by any number of\nalphanumeric, <code>+</code> <code>-</code> or <code>.</code></p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  scem                                              ::  2396 scheme\n        %+  cook  cass\n        ;~(plug alf (star ;~(pose aln lus hep dot)))\n      ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `@t`(scan \"http\" scem:epur)\n'http'\n~zod/try=&gt; `@t`(scan \"https\" scem:epur)\n'https'\n~zod/try=&gt; `@t`(scan \"chrome-extension\" scem:epur)\n'chrome-extension'\n</code></pre>\n"
    },
    {
        "keys": [
            "smeg"
        ],
        "doc": "<h1><code>++smeg</code></h1>\n<p>URL path segment</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  smeg  (cook crip (plus pcar))                     ::  2396 segment\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"foo\" smeg:epur)\n'foo'\n~zod/try=&gt; (scan \"bar%20baz-bam\" smeg:epur)\n'bar baz-bam'\n</code></pre>\n"
    },
    {
        "keys": [
            "tock"
        ],
        "doc": "<h1><code>++tock</code></h1>\n<p>HTTP cookie value</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  tock  (cook crip (plus pcok))                     ::  6265 cookie-value\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rush 'sam' tock:epur)\n[~ 'sam']\n~zod/try=&gt; (rush 'las!tore' tock:epur)\n[~ 'las!tore']\n~zod/try=&gt; (rush '\"sop\"\"les\"tor' tock:epur)\n~\n~zod/try=&gt; (rush '\"zemug\"' tock:epur)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "tosk"
        ],
        "doc": "<h1><code>++tosk</code></h1>\n<p>Possibly quoted HTTP cookie value</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  tosk  ;~(pose tock (ifix [doq doq] tock))         ::  6265 cookie-value\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rush 'sam' tosk:epur)\n[~ 'sam']\n~zod/try=&gt; (rush 'las!tore' tosk:epur)\n[~ 'las!tore']\n~zod/try=&gt; (rush '\"sop\"\"les\"tor' tosk:epur)\n~\n~zod/try=&gt; (rush '\"zemug\"' tosk:epur)\n[~ 'zemug']\n</code></pre>\n"
    },
    {
        "keys": [
            "toke"
        ],
        "doc": "<h1><code>++toke</code></h1>\n<p>HTTP cookie name</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  toke  (cook crip (plus ptok))                     ::  2616 token\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rush 'sam' toke:epur)\n[~ 'sam']\n~zod/try=&gt; (rush 'las!tore' toke:epur)\n[~ 'las!tore']\n~zod/try=&gt; (rush 'sop\"\"les\"tor' toke:epur)\n~\n~zod/try=&gt; (rush '\"zemug\"' toke:epur)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "thor"
        ],
        "doc": "<h1><code>++thor</code></h1>\n<p>Parse ++host and unit <code>@ui</code> port.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  thor                                              ::  2396 host/port\n        %+  cook  |*(a=[* *] [+.a -.a])\n        ;~  plug\n          thos\n          ;~(pose (stag ~ ;~(pfix col dim:ag)) (easy ~))\n        ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"localhost\" thor:epur)\n[~ [%.y i='localhost' t=~]]\n~zod/try=&gt; (scan \"localhost:8080\" thor:epur)\n[[~ q=8.080] [%.y i='localhost' t=~]]\n~zod/try=&gt; (scan \"192.168.0.1:8080\" thor:epur)\n[[~ q=8.080] [%.n q=3.232.235.521]]\n~zod/try=&gt; (scan \"www.google.com\" thor:epur)\n[~ [%.y i='com' t=~['google' 'www']]]\n</code></pre>\n"
    },
    {
        "keys": [
            "thos"
        ],
        "doc": "<h1><code>++thos</code></h1>\n<p>URI host: dot-separated segments, or IP address.</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  thos                                              ::  2396 host, no local\n        ;~  plug\n          ;~  pose\n            %+  stag  %&amp;\n            %+  sear                                        ::  LL parser weak here\n              |=  a=(list ,@t)\n              =+  b=(flop a)\n              ?&gt;  ?=(^ b)\n              =+  c=(end 3 1 i.b)\n              ?.(&amp;((gte c 'a') (lte c 'z')) ~ [~ u=b])\n            (most dot dlab)\n          ::\n            %+  stag  %|\n            =+  tod=(ape:ag ted:ab)\n            %+  bass  256\n            ;~(plug tod (stun [3 3] ;~(pfix dot tod)))\n          ==\n        ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"localhost\" thos:epur)\n[%.y i='localhost' t=~]\n~zod/try=&gt; (scan \"192.168.0.1\" thos:epur)\n[%.n q=3.232.235.521]\n~zod/try=&gt; (scan \"192.168.0.1:80\" thos:epur)\n! {1 12}\n! exit\n~zod/try=&gt; (scan \"www.google.com\" thos:epur)\n[%.y i='com' t=~['google' 'www']]\n</code></pre>\n"
    },
    {
        "keys": [
            "yque"
        ],
        "doc": "<h1><code>++yque</code></h1>\n<p>Parses query string, or lack thereof. Result type ++quay</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  yque                                              ::  query ending\n        ;~  pose\n          ;~(pfix wut yquy)\n          (easy ~)\n        ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"?sar=tok\" yque:epur)\n[['sar' 'tok'] ~]\n~zod/try=&gt; (scan \"?les=urbit%20sep&amp;met=kam\" yque:epur)\n[['les' 'urbit sep'] ~[['met' 'kam']]]\n~zod/try=&gt; (scan \"\" yque:epur)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "yquy"
        ],
        "doc": "<h1><code>++yquy</code></h1>\n<p>Parse query string after <code>?</code></p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  yquy                                              ::  query\n        ;~  pose                                            ::  proper query\n          %+  more\n            ;~(pose pam sem)\n          ;~(plug fque ;~(pose ;~(pfix tis fquu) (easy '')))\n        ::\n          %+  cook                                          ::  funky query\n            |=(a=tape [[%$ (crip a)] ~])\n          (star pque)\n        ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"sar=tok\" yquy:epur)\n[['sar' 'tok'] ~]\n~zod/try=&gt; (scan \"les=urbit%20sep&amp;met=kam\" yquy:epur)\n[['les' 'urbit sep'] ~[['met' 'kam']]]\n~zod/try=&gt; (scan \"\" yquy:epur)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "zest"
        ],
        "doc": "<h1><code>++zest</code></h1>\n<p>Parse ++quri absolute or relative request path</p>\n<h2>Accepts</h2>\n<h2>Produces</h2>\n<h2>Source</h2>\n<pre><code>++  zest                                              ::  2616 request-uri\n        ;~  pose\n          (stag %&amp; (cook |=(a=purl a) auri))\n          (stag %| ;~(plug apat yque))\n        ==\n      --\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"http://www.google.com:80/search?q=foo\" zest:epur)\n[%.y p=[p=%.n q=[~ 80] r=[%.y p=&lt;|com google www|&gt;]] q=[p=~ q=&lt;|search|&gt;] r=~[[p='q' q='foo']]]\n~zod/try=&gt; (scan \"/rel/bat\" zest:epur)\n[%.n [p=~ q=&lt;|rel bat|&gt;] ~]\n</code></pre>\n"
    },
    {
        "keys": [
            "fu"
        ],
        "doc": "<h1><code>++fu</code></h1>\n<pre><code>++  fu                                                  ::  modulo (mul p q)\n  |=  a=[p=@ q=@]\n  =+  b=?:(=([0 0] a) 0 (~(inv fo p.a) (~(sit fo p.a) q.a)))\n  |%\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "dif"
        ],
        "doc": "<h1><code>++dif</code></h1>\n<pre><code>  ++  dif\n    |=  [c=[@ @] d=[@ @]]\n    [(~(dif fo p.a) -.c -.d) (~(dif fo q.a) +.c +.d)]\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "exp"
        ],
        "doc": "<h1><code>++exp</code></h1>\n<pre><code>  ++  exp\n    |=  [c=@ d=[@ @]]\n    :-  (~(exp fo p.a) (mod c (dec p.a)) -.d)\n    (~(exp fo q.a) (mod c (dec q.a)) +.d)\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "out"
        ],
        "doc": "<h1><code>++out</code></h1>\n<pre><code>  ++  out                                               ::  garner's formula\n    |=  c=[@ @]\n    %+  add\n      +.c\n    (mul q.a (~(pro fo p.a) b (~(dif fo p.a) -.c (~(sit fo p.a) +.c))))\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "pro"
        ],
        "doc": "<h1><code>++pro</code></h1>\n<pre><code>  ++  pro\n    |=  [c=[@ @] d=[@ @]]\n    [(~(pro fo p.a) -.c -.d) (~(pro fo q.a) +.c +.d)]\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sum"
        ],
        "doc": "<h1><code>++sum</code></h1>\n<pre><code>  ++  sum\n    |=  [c=[@ @] d=[@ @]]\n    [(~(sum fo p.a) -.c -.d) (~(sum fo q.a) +.c +.d)]\n  ::\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "sit"
        ],
        "doc": "<h1><code>++sit</code></h1>\n<pre><code>  ++  sit\n    |=  c=@\n    [(mod c p.a) (mod c q.a)]\n</code></pre>\n<p>XX document</p>\n"
    },
    {
        "keys": [
            "jo"
        ],
        "doc": "<h1><code>++jo</code></h1>\n<p>JSON reparsing core</p>\n<p>Contains converters of <a href=\"\"><code>++json</code></a> to <a href=\"\"><code>++unit</code></a>s of well-typed structures.</p>\n<h2>Accepts</h2>\n<p>A <code>fist</code> is a gate that produces a <code>grub</code>.</p>\n<p>A <code>grub</code> is a unit of some JSON value.</p>\n<h2>Source</h2>\n<pre><code>++  jo                                                  ::  json reparser\n  =&gt;  |%  ++  grub  (unit ,*) \n          ++  fist  $+(json grub)\n  |%\n</code></pre>\n"
    },
    {
        "keys": [
            "ar"
        ],
        "doc": "<h1><code>++ar</code></h1>\n<p>Parse array to list</p>\n<p>Reparser modifier. Reparses an array to the <a href=\"\"><code>++unit</code></a> of a homogenous\n<a href=\"\"><code>++list</code></a> using <code>wit</code> to reparse every element.</p>\n<p><code>wit</code> is a <a href=\"\"><code>++fist</code></a>, a JSON reparser.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++rule</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  ar                                                ::  array as list\n    |*  wit=fist\n    |=  jon=json\n    ?.  ?=([%a *] jon)  ~\n    %-  zl\n    |-  \n    ?~  p.jon  ~\n    [i=(wit i.p.jon) t=$(p.jon t.p.jon)]\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; :type; ((ar ni):jo a/~[n/'1' n/'2'])\n[~ u=~[1 2]]\n{[%~ u=it(@)] %~}\n</code></pre>\n"
    },
    {
        "keys": [
            "at"
        ],
        "doc": "<h1><code>++at</code></h1>\n<p>Reparse array as tuple</p>\n<p>Reparser generator. Reparses an array as a fixed-length tuple of\n<a href=\"\"><code>++unit</code></a>s, using a list of <code>++fist</code>s.</p>\n<h2>Accepts</h2>\n<p><code>wil</code> is a <a href=\"\"><code>++pole</code></a>, a <a href=\"\"><code>face</code></a>less list of <a href=\"\"><code>++fist</code></a>s.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++rule</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  at                                                ::  array as tuple\n    |*  wil=(pole fist)\n    |=  jon=json\n    ?.  ?=([%a *] jon)  ~\n    =+  raw=((at-raw wil) p.jon)\n    ?.((za raw) ~ (some (zp raw)))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((at ni so ni ~):jo a/~[n/'3' s/'to' n/'4'])\n[~ u=[q=3 ~.to q=4]]\n~zod/try=&gt; :type; ((at ni so ni ~):jo a/~[n/'3' s/'to' n/'4'])\n[~ u=[q=3 ~.to q=4]]\n{{[%~ u=[q=@ @ta q=@]] %~} %~}\n~zod/try=&gt; ((at ni so ni ~):jo a/~[n/'3' s/'to' n/''])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "at-raw"
        ],
        "doc": "<h1><code>++at-raw</code></h1>\n<p>Reparse array to tuple</p>\n<p>Reparser generator. Reparses a list of <a href=\"\"><code>++json</code></a> with <code>wil</code> to a tuple of <a href=\"\"><code>++unit</code></a>s.</p>\n<h2>Accepts</h2>\n<p><code>wil</code> is a <a href=\"\"><code>++pole</code></a>, a <a href=\"\">face</a>less list of <a href=\"\"><code>++fist</code></a>s.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++rule</code></a>.</p>\n<h2>Source</h2>\n<pre><code>    ++  at-raw                                            ::  array as tuple\n    |*  wil=(pole fist)\n    |=  jol=(list json)\n    ?~  wil  ~\n    :-  ?~(jol ~ (-.wil i.jol))\n    ((at-raw +.wil) ?~(jol ~ t.jol))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((at-raw ni ni bo ~):jo ~[s/'hi' n/'1' b/&amp;])\n[~ [~ 1] [~ u=%.y] ~]\n</code></pre>\n"
    },
    {
        "keys": [
            "bo"
        ],
        "doc": "<h1><code>++bo</code></h1>\n<p>Reparse boolean</p>\n<p>Reparser modifier. Reparses a boolean to the <a href=\"\"><code>++unit</code></a> of a\nboolean.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  bo                                                ::  boolean\n    |=(jon=json ?.(?=([%b *] jon) ~ [~ u=p.jon]))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (bo:jo [%b &amp;])\n[~ u=%.y]\n~zod/try=&gt; (bo:jo [%b |])\n[~ u=%.n]\n~zod/try=&gt; (bo:jo [%s 'hi'])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "bu"
        ],
        "doc": "<h1><code>++bu</code></h1>\n<p>Reparse boolean not</p>\n<p>Reparser modifier. Reparses the inverse of a boolean to the <a href=\"\"><code>++unit</code></a>\nof a loobean.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  bu                                                ::  boolean not\n    |=(jon=json ?.(?=([%b *] jon) ~ [~ u=!p.jon]))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (bu:jo [%b &amp;])\n[~ u=%.n]\n~zod/try=&gt; (bu:jo [%b |])\n[~ u=%.y]\n~zod/try=&gt; (bu:jo [%s 'hi'])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "cu"
        ],
        "doc": "<h1><code>++cu</code></h1>\n<p>Reparse and transform</p>\n<p>Reparser modifier. Reparses <code>jon</code> and slams the result through <code>wit</code>,\nproducing a <a href=\"\"><code>++unit</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>wit</code> is a <a href=\"\"><code>++fist</code></a>.</p>\n<p><code>poq</code> is a <a href=\"\"><code>gate</code></a> that accepts and returns a <a href=\"\">noun</a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  cu                                                ::  transform\n    |*  [poq=$+(* *) wit=fist]\n    |=  jon=json\n    (bind (wit jon) poq)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((cu dec ni):jo [%n '20'])\n[~ 19]\n~zod/try=&gt; ((cu dec ni):jo [%b &amp;])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "da"
        ],
        "doc": "<h1><code>++da</code></h1>\n<p>Reparse UTC date</p>\n<p>Reparser modifier. Reparses a UTC date string to a <a href=\"\"><code>++unit</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>jon</code> is a <a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  da                                                ::  UTC date\n    |=  jon=json\n    ?.  ?=([%s *] jon)  ~\n    (bind (stud (trip p.jon)) |=(a=date (year a)))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (da:jo [%s 'Wed, 29 Oct 2014 0:26:15 +0000'])\n[~ ~2014.10.29..00.26.15]\n~zod/try=&gt; (da:jo [%s 'Wed, 29 Oct 2012 0:26:15'])\n[~ ~2012.10.29..00.26.15]\n~zod/try=&gt; (da:jo [%n '20'])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "di"
        ],
        "doc": "<h1><code>++di</code></h1>\n<p>Reparse millisecond date</p>\n<p>Reparser modifier. Reparses the javascript millisecond date integer to a\n<a href=\"\"><code>++unit</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>jon</code> is a <a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  di                                                ::  millisecond date\n    |=  jon=json\n    %+  bind  (ni jon)\n    |=  a=@u  ^-  @da\n    (add ~1970.1.1 (div (mul ~s1 a) 1.000))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (di:jo [%s '2014-10-29'])\n~\n~zod/try=&gt; (di:jo [%n '1414545548325'])\n[~ ~2014.10.29..01.19.08..5333.3333.3333.3333]\n~zod/try=&gt; (di:jo [%n '1414545615128'])\n[~ ~2014.10.29..01.20.15..20c4.9ba5.e353.f7ce]\n~zod/try=&gt; (di:jo [%n '25000'])\n[~ ~1970.1.1..00.00.25]\n</code></pre>\n"
    },
    {
        "keys": [
            "mu"
        ],
        "doc": "<h1><code>++mu</code></h1>\n<p>Reparse unit</p>\n<p>Reparser modifier. Reparses <code>wit</code> to a <a href=\"\"><code>++unit</code></a>.</p>\n<p>JSON units are considered to be either JSON null or the requested\nvalue, and are reparsed to results of ~ or (some {value}) respectively.</p>\n<h2>Accepts</h2>\n<p><code>wit</code> is a <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  mu                                                ::  true unit\n    |*  wit=fist\n    |=  jon=json\n    ?~(jon (some ~) (bind (wit jon) some))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((mu ni):jo [%n '20'])\n[~ [~ u=q=20]]\n~zod/try=&gt; ((mu ni):jo [%n '15'])\n[~ [~ u=q=15]]\n~zod/try=&gt; ((mu ni):jo ~)\n[~ u=~]\n~zod/try=&gt; ((mu ni):jo [%s 'ma'])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "ne"
        ],
        "doc": "<h1><code>++ne</code></h1>\n<p>Reparse number as real</p>\n<p>XX Currently unimplemented</p>\n<p>A- yup, this will eventually reparse a floating point atom, but\ninterfaces for the latter are not currently stable.</p>\n"
    },
    {
        "keys": [
            "ni"
        ],
        "doc": "<h1><code>++ni</code></h1>\n<p>Reparse number as integer</p>\n<p>Reparser modifier. Reparses an integer representation to a <a href=\"\">`++unit</a>.</p>\n<h2>Accepts</h2>\n<p><code>jon</code> is a ++<a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>The <code>++unit</code> of an atom.</p>\n<h2>Source</h2>\n<pre><code>  ++  ni                                                ::  number as integer\n    |=  jon=json \n    ?.  ?=([%n *] jon)  ~\n    (rush p.jon dem)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (ni:jo [%n '0'])\n[~ q=0]\n~zod/try=&gt; (ni:jo [%n '200'])\n[~ q=200]\n~zod/try=&gt; (ni:jo [%n '-2.5'])\n~\n~zod/try=&gt; (ni:jo [%s '10'])\n~\n~zod/try=&gt; (ni:jo [%b |])\n~\n~zod/try=&gt; (ni:jo [%n '4'])\n[~ q=4]\n~zod/try=&gt; (ni:jo [%a ~[b/&amp; b/&amp; b/&amp; b/&amp;]])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "no"
        ],
        "doc": "<h1><code>++no</code></h1>\n<p>Reparse number as text</p>\n<p>Reparser modifier. Reparses a numeric representation to a <a href=\"\">++cord</a>.</p>\n<h2>Accepts</h2>\n<p><code>jon</code> is a <code>++json</code>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++unit</code></a> of a <code>++cord</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  no                                                ::  number as text\n    |=  jon=json\n    ?.  ?=([%n *] jon)  ~\n    (some p.jon)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (no:jo [%n '0'])\n[~ u=~.0]\n~zod/try=&gt; (no:jo [%n '200'])\n[~ u=~.200]\n~zod/try=&gt; (no:jo [%n '-2.5'])\n[~ u=~.-2.5]\n~zod/try=&gt; (no:jo [%s '10'])\n~\n~zod/try=&gt; (no:jo [%b |])\n~\n~zod/try=&gt; (no:jo [%n '4'])\n[~ u=~.4]\n~zod/try=&gt; (no:jo [%a ~[b/&amp; b/&amp; b/&amp; b/&amp;]])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "of"
        ],
        "doc": "<h1><code>++of</code></h1>\n<p>Reparse object to frond</p>\n<p>Reparser generator. Reparses an object, succeeding if it corresponds to\none of the key-value pairs in <code>wer</code>.</p>\n<h2>Accepts</h2>\n<p><code>wer</code> is a <a href=\"\"><code>++pole</code></a>, a <a href=\"\"><code>++face</code></a>less list of <a href=\"\"><code>++cord</code></a> and\n<a href=\"\"><code>++fist</code></a> key-value pairs.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++unit</code></a> of a cell of a.....</p>\n<h2>Source</h2>\n<pre><code>  ++  of                                                ::  object as frond\n    |*  wer=(pole ,[cord fist])\n    |=  jon=json\n    ?.  ?=([%o [@ *] ~ ~] jon)  ~\n    |-\n    ?~  wer  ~\n    ?:  =(-.-.wer p.n.p.jon)  \n      ((pe -.-.wer +.-.wer) q.n.p.jon)\n    ((of +.wer) jon)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((of sem/sa som/ni ~):jo %o [%sem s/'hi'] ~ ~)\n[~ [%sem \"hi\"]]\n~zod/try=&gt; ((of sem/sa som/ni ~):jo %o [%som n/'20'] ~ ~)\n[~ [%som q=20]]\n~zod/try=&gt; ((of sem/sa som/ni ~):jo %o [%som s/'he'] ~ ~)\n~\n~zod/try=&gt; ((of sem/sa som/ni ~):jo %o [%som s/'5'] ~ ~)\n~\n~zod/try=&gt; ((of sem/sa som/ni ~):jo %o [%sem s/'5'] ~ ~)\n[~ [%sem \"5\"]]\n~zod/try=&gt; ((of sem/sa som/ni ~):jo %o [%sem n/'2'] ~ ~)\n~\n~zod/try=&gt; ((of sem/sa som/ni ~):jo %o [%sem b/&amp;] ~ ~)\n~\n~zod/try=&gt; ((of sem/sa som/ni ~):jo %a ~[s/'som' n/'4'])\n~\n~zod/try=&gt; ((of sem/sa som/ni ~):jo %o [%sem s/'hey'] ~ [%sam s/'other value'] ~ ~)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "ot"
        ],
        "doc": "<h1><code>++ot</code></h1>\n<p>Reparse object as tuple</p>\n<p>Reparser generator. For every key in <code>wer</code> that matches a key in the\n[<code>++edge</code>], the fist in <code>wer</code> is applied to the corresponding value in\nthe <a href=\"\"><code>++edge</code></a>, the results of which are produced in a tuple.</p>\n<h2>Accepts</h2>\n<p><code>wer</code> is a <a href=\"\"><code>++pole</code></a> of <a href=\"\"><code>++cord</code></a> to <a href=\"\"><code>++fist</code></a> key-value pairs.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++unit</code></a> of a tuple XX?</p>\n<h2>Source</h2>\n<pre><code>  ++  ot                                                ::  object as tuple\n    |*  wer=(pole ,[cord fist])\n    |=  jon=json\n    ?.  ?=([%o *] jon)  ~\n    =+  raw=((ot-raw wer) p.jon)\n    ?.((za raw) ~ (some (zp raw)))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (jobe [%sem s/'ha'] [%som n/'20'] ~)\n[%o p={[p='sem' q=[%s p=~.ha]] [p='som' q=[%n p=~.20]]}]\n~zod/try=&gt; ((ot sem/sa som/ni sem/sa ~):jo (jobe [%sem s/'ha'] [%som n/'20'] ~))\n[~ u=[\"ha\" q=20 \"ha\"]]\n</code></pre>\n"
    },
    {
        "keys": [
            "ot-raw"
        ],
        "doc": "<h1><code>++ot-raw</code></h1>\n<p>Reparser generator. Reparses a map <code>jom</code> using <code>wer</code>; for every key in\n<code>wer</code> that matches a key in <code>map</code>, the corresponding <code>++fist</code> is applied\nto the corresponding value in <code>jom</code>, the results of which are produced\nin a tuple.</p>\n<h2>Accepts</h2>\n<p><code>wer</code> is a <a href=\"\"><code>++pole</code></a> of <a href=\"\"><code>++cord</code></a> to <a href=\"\"><code>++fist</code></a> key-value pairs.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++unit</code></a> of.</p>\n<h2>Source</h2>\n<pre><code>    ++  ot-raw                                            ::  object as tuple\n    |*  wer=(pole ,[cord fist])\n    |=  jom=(map ,@t json)\n    ?~  wer  ~\n    =+  ten=(~(get by jom) -.-.wer)\n    [?~(ten ~ (+.-.wer u.ten)) ((ot-raw +.wer) jom)]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((ot-raw sem/sa som/ni sem/sa ~):jo (mo [%sem s/'ha'] [%som n/'20'] ~))\n[[~ u=\"ha\"] [~ q=20] [~ u=\"ha\"] ~]\n~zod/try=&gt; ((ot-raw sem/sa som/ni sem/sa ~):jo (mo [%sem s/'ha'] [%som b/|] ~))\n[[~ u=\"ha\"] ~ [~ u=\"ha\"] ~]\n</code></pre>\n"
    },
    {
        "keys": [
            "om"
        ],
        "doc": "<h1><code>++om</code></h1>\n<p>Parse object to map</p>\n<p>Reparser modifier. Reparses a <a href=\"\"><code>++json</code></a> object to a homogenous map\nusing <code>wit</code>.</p>\n<h2>Accepts</h2>\n<p><code>wit</code> is a <a href=\"\"><code>++fist</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++unit</code></a> of...</p>\n<h2>Source</h2>\n<pre><code>    ++  om                                                ::  object as map\n    |*  wit=fist\n    |=  jon=json\n    ?.  ?=([%o *] jon)  ~\n    (zm ~(run by p.jon) wit)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((om ni):jo (jobe [%sap n/'20'] [%sup n/'5'] [%sop n/'177'] ~))\n[~ {[p='sup' q=q=5] [p='sop' q=q=177] [p='sap' q=q=20]}]\n~zod/try=&gt; ((om ni):jo (jobe [%sap n/'20'] [%sup n/'0x5'] [%sop n/'177'] ~))\n~    \n</code></pre>\n"
    },
    {
        "keys": [
            "pe"
        ],
        "doc": "<h1><code>++pe</code></h1>\n<p>Add prefix</p>\n<p>Reparser modifier. Adds a static prefix <code>pre</code> to the parse result of\n<code>wit</code>. See also: <a href=\"\"><code>++stag</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>pre</code> is a prefix <a href=\"\"><code>noun</code></a>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++unit</code></a> of a cell of <a href=\"\">noun</a> and the result of parsing <code>wit</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  pe                                                ::  prefix\n    |*  [pre=* wit=fist]\n    (cu |*(a=* [pre a]) wit)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (ni:jo n/'2')\n[~ q=2]\n~zod/try=&gt; (ni:jo b/|)\n~\n~zod/try=&gt; ((pe %hi ni):jo n/'2')\n[~ [%hi q=2]]\n~zod/try=&gt; ((pe %hi ni):jo b/|)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "sa"
        ],
        "doc": "<h1><code>++sa</code></h1>\n<p>Reparse string to tape</p>\n<p>Reparser modifier. Reparses a <a href=\"\"><code>++json</code></a> string to a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>jon</code> is a <a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++unit</code></a> of a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  sa                                                ::  string as tape\n    |=  jon=json\n    ?.(?=([%s *] jon) ~ (some (trip p.jon)))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (sa:jo s/'value')\n[~ u=\"value\"]\n~zod/try=&gt; (sa:jo n/'46')\n~\n~zod/try=&gt; (sa:jo a/~[s/'val 2'])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "so"
        ],
        "doc": "<h1><code>++so</code></h1>\n<p>Reparse string to cord</p>\n<p>Reparser modifier. Reparses a string to a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>jon</code> is a <a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++unit</code></a> of a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  so                                                ::  string as cord\n    |=  jon=json\n    ?.(?=([%s *] jon) ~ (some p.jon))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (so:jo s/'value')\n[~ u=~.value]\n~zod/try=&gt; (so:jo n/'46')\n~\n~zod/try=&gt; (so:jo a/~[s/'val 2'])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "su"
        ],
        "doc": "<h1><code>++su</code></h1>\n<p>Reparse string</p>\n<p>Reparser generator. Produces a reparser that applies <code>sab</code> to a string.</p>\n<h2>Accepts</h2>\n<p><code>sab</code> is a [<code>++rule</code>].</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++rule</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  su                                                ::  parse string\n    |*  sab=rule\n    |=  jon=json\n    ?.  ?=([%s *] jon)  ~\n    (rush p.jon sab)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; ((su:jo fed:ag) s/'zod')\n[~ 0]\n~zod/try=&gt; ((su:jo fed:ag) s/'doznec')\n[~ 256]\n~zod/try=&gt; ((su:jo fed:ag) s/'notship')\n~\n~zod/try=&gt; ((su:jo fed:ag) n/'20')\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "ul"
        ],
        "doc": "<h1><code>++ul</code></h1>\n<p>Reparse null</p>\n<p>Reparser modifier. Reparses a null value.</p>\n<h2>Accepts</h2>\n<p><code>jon</code> is a <a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++unit</code></a> of null.</p>\n<h2>Source</h2>\n<pre><code>  ++  ul  |=(jon=json ?~(jon (some ~) ~))               ::  null\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (ul:jo `json`~)\n[~ u=~]\n~zod/try=&gt; (ul:jo s/'null')\n~\n~zod/try=&gt; (ul:jo b/|)\n~\n~zod/try=&gt; (ul:jo b/&amp;)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "za"
        ],
        "doc": "<h1><code>++za</code></h1>\n<p>Pole of nonempty units</p>\n<p>Determines if <code>pod</code> contains all non-empty units, producing a boolean. Used\ninternally.</p>\n<h2>Accepts</h2>\n<p><code>pod</code> is a <a href=\"\"><code>++pole</code></a> of <a href=\"\"><code>++unit</code></a>.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>  ++  za                                                ::  full unit pole\n    |*  pod=(pole (unit))\n    ?~  pod  &amp;\n    ?~  -.pod  |\n    (za +.pod)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (za:jo ~[`1 `2 `3])\n%.y\n~zod/try=&gt; (za:jo ~[`1 ~ `3])\n%.n\n</code></pre>\n"
    },
    {
        "keys": [
            "zl"
        ],
        "doc": "<h1><code>++zl</code></h1>\n<p>Collapse unit list</p>\n<p>Produces a unit of the values of <code>lut</code> if every unit in <code>lut</code> is\nnonempty. Otherwise, produces <code>~</code>.</p>\n<h2>Accepts</h2>\n<p><code>lut</code> is a <a href=\"\"><code>++list</code></a> of <a href=\"\"><code>++unit</code></a>s.</p>\n<h2>Produces</h2>\n<p>A boolean.</p>\n<h2>Source</h2>\n<pre><code>  ++  zl                                                ::  collapse unit list\n    |*  lut=(list (unit))\n    ?.  |-  ^-  ?\n        ?~(lut &amp; ?~(i.lut | $(lut t.lut)))\n      ~\n    %-  some\n    |-\n    ?~  lut  ~\n    [i=u:+.i.lut t=$(lut t.lut)]\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (zl:jo `(list (unit))`~[`1 `2 `3])\n[~ u=~[1 2 3]]\n~zod/try=&gt; (zl:jo `(list (unit))`~[`1 `17 `3])\n[~ u=~[1 17 3]]\n~zod/try=&gt; (zl:jo `(list (unit))`~[`1 ~ `3])\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "zp"
        ],
        "doc": "<h1><code>++zp</code></h1>\n<p>XX</p>\n<p>Collapses a <code>++pole</code> of <code>++unit</code>s <code>but</code>, producing a tuple.</p>\n<h2>Accepts</h2>\n<p><code>but</code> is a <a href=\"\"><code>++pole</code></a> of <a href=\"\"><code>++unit</code></a>.</p>\n<h2>Produces</h2>\n<p>??</p>\n<h2>Source</h2>\n<pre><code>  ++  zp                                                ::  unit tuple\n    |*  but=(pole (unit))\n    ?~  but  !!\n    ?~  +.but  \n      u:-&gt;.but\n    [u:-&gt;.but (zp +.but)]\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (zp:jo `(pole (unit))`~[`1 `2 `3])\n[1 2 3]\n~zod/try=&gt; (zp:jo `(pole (unit))`~[`1 `17 `3])\n[1 17 3]\n~zod/try=&gt; (zp:jo `(pole (unit))`~[`1 ~ `3])\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "zm"
        ],
        "doc": "<h1><code>++zm</code></h1>\n<p>Collapse unit map</p>\n<p>Produces a <a href=\"\"><code>++unit</code></a> of the <a href=\"\"><code>++map</code></a> <code>lum</code> of term to <code>++unit</code> key value\npairs, with all of the nonempty values stripped of their <code>++unit</code>\nwrappers. If any of the <code>++units</code> in <code>lum</code> are empty, <code>~</code> is produced.\nSee also: <a href=\"\"><code>++zp</code></a>, <a href=\"\"><code>++zl</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>lum</code> is a map of <a href=\"\"><code>++term</code></a> to <a href=\"\"><code>++unit</code></a>s.</p>\n<h2>Produces</h2>\n<p>The <code>++unit</code> of a tuple of what were the key-value pairs of <code>lum</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  zm                                                ::  collapse unit map\n    |*  lum=(map term (unit))\n    ?:  (~(rep by lum) | |=([[@ a=(unit)] b=?] |(b ?=(~ a))))\n      ~\n    (some (~(run by lum) need))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (zm:jo `(map term (unit ,@u))`(mo a/`4 b/`1 c/`2 ~))\n[~ {[p=%a q=4] [p=%c q=2] [p=%b q=1]}]\n~zod/try=&gt; (zm:jo `(map term (unit ,@u))`(mo a/`4 b/~ c/`2 ~))\n~\n~zod/try=&gt; (~(run by `(map ,@t ,@u)`(mo a/1 b/2 c/3 ~)) (flit |=(a=@ (lth a 5))))\n{[p='a' q=[~ u=1]] [p='c' q=[~ u=3]] [p='b' q=[~ u=2]]}\n~zod/try=&gt; (zm:jo (~(run by `(map ,@t ,@u)`(mo a/1 b/2 c/3 ~)) (flit |=(a=@ (lth a 5)))))\n[~ {[p='a' q=1] [p='c' q=3] [p='b' q=2]}]\n~zod/try=&gt; (zm:jo (~(run by `(map ,@t ,@u)`(mo a/1 b/7 c/3 ~)) (flit |=(a=@ (lth a 5)))))\n~\n~zod/try=&gt; (~(run by `(map ,@t ,@u)`(mo a/1 b/7 c/3 ~)) (flit |=(a=@ (lth a 5))))\n{[p='a' q=[~ u=1]] [p='c' q=[~ u=3]] [p='b' q=~]}\n</code></pre>\n"
    },
    {
        "keys": [
            "poja"
        ],
        "doc": "<h1><code>++poja</code></h1>\n<p>JSON parser core</p>\n<p>JSON parser core: parses a <a href=\"\"><code>++cord</code></a> <code>a</code> to the hoon structure for JSON,\na <a href=\"\"><code>++json</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like json)</code>.</p>\n<h2>Source</h2>\n<pre><code>++  poja                                                ::  JSON parser core\n  =&lt;  |=(a=cord (rush a apex))\n  |%\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (poja '[1,2,3]')\n[~ [%a p=~[[%n p=~.1] [%n p=~.2] [%n p=~.3]]]]\n~zod/try=&gt; (poja 'null')\n[~ ~]\n~zod/try=&gt; (poja 'invalid{json')\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "tops"
        ],
        "doc": "<h1><code>++tops</code></h1>\n<p>Parse object</p>\n<p>Top level parsing <a href=\"\"><code>++rule</code></a>. Parses either a single JSON object, or an array\nof JSON objects to a <a href=\"\"><code>++json</code></a>. See also: <a href=\"\"><code>++abox</code></a>, <a href=\"\"><code>++obox</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like json)</code>.</p>\n<h2>Source</h2>\n<pre><code>   ++  apex  ;~(pose abox obox)                          ::  JSON object\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '[1,2]' apex:poja)\n[%a p=~[[%n p=~.1] [%n p=~.2]]]\n~zod/try=&gt; (rash '{\"sam\": \"kot\"}' apex:poja)\n[%o p={[p=~.sam q=[%s p=~.kot]]}]\n~zod/try=&gt; (rash 'null' apex:poja)\n! {1 1}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "apex"
        ],
        "doc": "<h1><code>++apex</code></h1>\n<p>Parse value</p>\n<p>Parsing <a href=\"\"><code>++rule</code></a>. Parses JSON values to <a href=\"\"><code>++json</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like json)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  valu                                              ::  JSON value\n    %+  knee  *json  |.  ~+\n    ;~  pfix  spac\n      ;~  pose\n        (cold ~ (jest 'null'))\n        (jify %b bool)\n        (jify %s stri)\n        (cook |=(s=tape [%n p=(rap 3 s)]) numb)\n        abox\n        obox\n      ==\n    ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '[1,2]' valu:poja)\n[%a p=~[[%n p=~.1] [%n p=~.2]]]\n~zod/try=&gt; (rash '{\"sam\": \"kot\"}' valu:poja)\n[%o p={[p='sam' q=[%s p=~.kot]]}]\n~zod/try=&gt; (rash 'null' valu:poja)\n~\n~zod/try=&gt; (rash '20' valu:poja)\n[%n p=~.20]\n~zod/try=&gt; (rash '\"str\"' valu:poja)\n[%s p=~.str]\n~zod/try=&gt; (rash 'true' valu:poja)\n[%b p=%.y]\n</code></pre>\n"
    },
    {
        "keys": [
            "abox"
        ],
        "doc": "<h1><code>++abox</code></h1>\n<p>Parse array</p>\n<p>Parsing rule. Parses a JSON array with values enclosed within <code>[]</code> and\ndelimited by a <code>,</code>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like json)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  abox  (stag %a (ifix [sel (ws ser)] (more (ws com) valu)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '[1, 2,4]' abox:poja)\n[[%n p=~.1] ~[[%n p=~.2] [%n p=~.4]]]\n</code></pre>\n<h2>JSON Objects</h2>\n"
    },
    {
        "keys": [
            "pair"
        ],
        "doc": "<h1><code>++pair</code></h1>\n<p>Parse key value pair</p>\n<p>Parsing rule. Parses a <a href=\"\"><code>++json</code></a> from a JSON key-value pair of a\nstring and value delimited by <code>:</code>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like json)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  pair  ;~(plug ;~(sfix (ws stri) (ws col)) valu)\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '\"ham\": 2' pair:poja)\n['ham' [%n p=~.2]]\n</code></pre>\n"
    },
    {
        "keys": [
            "obje"
        ],
        "doc": "<h1><code>++obje</code></h1>\n<p>Parse array of objects</p>\n<p>Parsing rule. Parses a <a href=\"\"><code>++json</code></a> from an array of JSON object\nkey-value pairs that are enclosed within <code>{}</code> and separated by <code>,</code>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like ,[%o p=(map ,@t json)])</code></p>\n<h2>Source</h2>\n<pre><code>  ++  obje  (ifix [(ws kel) (ws ker)] (more (ws com) pair))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '{\"ham\": 2, \"lam\":true}' obje:poja)\n[['ham' [%n p=~.2]] ~[['lam' [%b p=%.y]]]]\n</code></pre>\n"
    },
    {
        "keys": [
            "obox"
        ],
        "doc": "<h1><code>++obox</code></h1>\n<p>Parse boxed object</p>\n<p>Parsing rule. Parses an array of JSON objects to an object of <a href=\"\"><code>++json</code></a>. See also: <a href=\"\"><code>++json</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like ,[%o p=(map ,@t json)])</code></p>\n<h2>Source</h2>\n<pre><code>  ++  obox  (stag %o (cook mo obje))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '{\"ham\": 2, \"lam\":true}' obox:poja)\n[%o {[p='lam' q=[%b p=%.y]] [p='ham' q=[%n p=~.2]]}]\n</code></pre>\n<h2>JSON Booleans</h2>\n"
    },
    {
        "keys": [
            "bool"
        ],
        "doc": "<h1><code>++bool</code></h1>\n<p>Parse boolean</p>\n<p>Parsing rule. Parses a string of either <code>true</code> or <code>false</code> to a\n<a href=\"\"><code>++json</code></a> boolean.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like ,[%b p=?])</code></p>\n<h2>Source</h2>\n<pre><code>  ++  bool  ;~(pose (cold &amp; (jest 'true')) (cold | (jest 'false')))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash 'true' bool:poja)\n%.y\n~zod/try=&gt; (rash 'false' bool:poja)\n%.n\n~zod/try=&gt; (rash 'null' bool:poja)\n! {1 1}\n! exit\n</code></pre>\n<h2>JSON strings</h2>\n"
    },
    {
        "keys": [
            "stri"
        ],
        "doc": "<h1><code>++stri</code></h1>\n<p>Parse string</p>\n<p>Parsing rule. Parse a string to a <a href=\"\"><code>++cord</code></a>. A JSON string is a list\nof characters enclosed in double quotes along with escaping <code>\\</code>s, to a\n<a href=\"\"><code>++cord</code></a>. See also <a href=\"\"><code>++jcha</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like ,[%s p=@t])</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  stri\n    (cook crip (ifix [doq doq] (star jcha)))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '\"ham\"' stri:poja)\n'ham'\n~zod/try=&gt; (rash '\"h\\\\nam\"' stri:poja)\n'h\n  am'\n~zod/try=&gt; (rash '\"This be \\\\\"quoted\\\\\"\"' stri:poja)\n'This be \"quoted\"'\n</code></pre>\n"
    },
    {
        "keys": [
            "jcha"
        ],
        "doc": "<h1><code>++jcha</code></h1>\n<p>Parse char from string</p>\n<p>Parsing rule. Parses either a literal or escaped character from a JSON\nstring to a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like cord)</code>.</p>\n<h2>Source</h2>\n<pre><code> ++  jcha  ;~(pose ;~(less doq bas prn) esca)           :: character in string\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash 'a' jcha:poja)\n'a'.\n~zod/try=&gt; (rash '!' jcha:poja)\n'!'\n~zod/try=&gt; (rash '\\\\\"' jcha:poja)\n'\"'\n~zod/try=&gt; (rash '\\\\u00a4' jcha:poja)\n'\u00a4'\n~zod/try=&gt; (rash '\\\\n' jcha:poja)\n'\n '\n</code></pre>\n"
    },
    {
        "keys": [
            "esca"
        ],
        "doc": "<h1><code>++esca</code></h1>\n<p>Parse escaped char</p>\n<p>Parsing rule. Parses a backslash-escaped special character, low ASCII,\nor UTF16 codepoint, to a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like cord)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  esca                                               :: Escaped character\n    ;~  pfix  bas\n      ;~  pose\n        doq  fas  soq  bas\n        (sear ~(get by `(map ,@t ,@)`(mo b/8 t/9 n/10 f/12 r/13 ~)) low)\n        ;~(pfix (just 'u') (cook tuft qix:ab))           :: 4-digit hex to UTF-8\n      ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash 'b' esca:poja)\n! {1 1}\n! exit\n~zod/try=&gt; (rash '\\n' esca:poja)\n~ &lt;syntax error at [1 9]&gt;\n~zod/try=&gt; (rash '\\\\n' esca:poja)\n'\n '\n~zod/try=&gt; `@`(rash '\\\\r' esca:poja)\n13\n~zod/try=&gt; (rash '\\\\u00c4' esca:poja)\n'\u00c4'\n~zod/try=&gt; (rash '\\\\u00df' esca:poja)\n'\u00df'\n</code></pre>\n<h2>JSON numbers</h2>\n<p>A JSON numbers are stored as cords internally in lieu of full float\nsupport, so ++numb and subarms are really more <em>validators</em> than parsers\nper se.</p>\n"
    },
    {
        "keys": [
            "numb"
        ],
        "doc": "<h1><code>++numb</code></h1>\n<p>Parse number</p>\n<p>Parsing rule. Parses decimal numbers with an optional <code>-</code>, fractional\npart, or exponent part, to a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>An <a href=\"\"><code>++edge</code></a> of a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  numb\n    ;~  (comp twel)\n      (mayb (piec hep))\n      ;~  pose\n        (piec (just '0'))\n        ;~(plug (shim '1' '9') digs)\n      ==\n      (mayb frac)\n      (mayb expo)\n    ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '0' numb:poja)\n~[~~0]\n~zod/try=&gt; (rash '1' numb:poja)\n~[~~1]\n~zod/try=&gt; `tape`(rash '1' numb:poja)\n\"1\"\n~zod/try=&gt; `tape`(rash '12.6' numb:poja)\n\"12.6\"\n~zod/try=&gt; `tape`(rash '-2e20' numb:poja)\n\"-2e20\"\n~zod/try=&gt; `tape`(rash '00e20' numb:poja)\n! {1 2}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "digs"
        ],
        "doc": "<h1><code>++digs</code></h1>\n<p>Parse 1-9</p>\n<p>Parsing rule. Parses digits <code>0</code> through <code>9</code> to a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++edge</code></a> of a <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  digs  (star (shim '0' '9'))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '' digs:poja)\n\"\"\n~zod/try=&gt; (rash '25' digs:poja)\n\"25\"\n~zod/try=&gt; (rash '016' digs:poja)\n\"016\"\n~zod/try=&gt; (rash '7' digs:poja)\n\"7\"\n</code></pre>\n"
    },
    {
        "keys": [
            "expo"
        ],
        "doc": "<h1><code>++expo</code></h1>\n<p>Parse exponent part</p>\n<p>Parsing rule. Parses an exponent to a <a href=\"\"><code>++tape</code></a> .An exponent is an\n<code>e</code> or 'E', followed by an optional <code>+</code> or <code>-</code>, and then by digits.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++edge</code></a> of a <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  expo                                               :: Exponent part\n    ;~  (comp twel)\n      (piec (mask \"eE\"))\n      (mayb (piec (mask \"+-\")))\n      digs\n    ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `tape`(rash 'e7' expo:poja)\n\"e7\"\n~zod/try=&gt; `tape`(rash 'E17' expo:poja)\n\"E17\"\n~zod/try=&gt; `tape`(rash 'E-4' expo:poja)\n\"E-4\"\n</code></pre>\n"
    },
    {
        "keys": [
            "frac"
        ],
        "doc": "<h1><code>++frac</code></h1>\n<p>Fractional part</p>\n<p>Parsing rule. Parses a dot followed by digits to a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <code>++nail</code>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++edge</code></a> of a <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  frac   ;~(plug dot digs)                          :: Fractional part\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '.25' frac:poja)\n[~~~. \"25\"]\n~zod/try=&gt; (rash '.016' frac:poja)\n[~~~. \"016\"]\n~zod/try=&gt; (rash '.7' frac:poja)\n[~~~. \"7\"]\n</code></pre>\n<h2>whitespace</h2>\n"
    },
    {
        "keys": [
            "spac"
        ],
        "doc": "<h1><code>++spac</code></h1>\n<p>Parse whitespace</p>\n<p>Parsing rule. Parses a whitespace to a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like tape)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  spac  (star (mask [`@`9 `@`10 `@`13 ' ' ~]))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"\" spac:poja)\n\"\"\n~zod/try=&gt; (scan \"   \" spac:poja)\n\"   \"\n~zod/try=&gt; `*`(scan `tape`~[' ' ' ' ' ' `@`9 ' ' ' ' `@`13] spac:poja)\n[32 32 32 9 32 32 13 0]\n~zod/try=&gt; (scan \"   m \" spac:poja)\n! {1 4}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "ws"
        ],
        "doc": "<h1><code>++ws</code></h1>\n<p>Allow prefix whitespace</p>\n<p>Parser modifier. Produces a rule that allows for a whitespace before\napplying <code>sef</code>.</p>\n<h2>Accepts</h2>\n<p><code>sef</code> is a <a href=\"\"><code>++rule</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  ws  |*(sef=_rule ;~(pfix spac sef))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '   4' digs:poja)\n! {1 1}\n! exit\n~zod/try=&gt; (rash '   4' (ws digs):poja)\n\"4\"\n~zod/try=&gt; (rash '''\n\n                 4\n                 ''' (ws digs):poja)\n\"4\"\n</code></pre>\n<h2>Plumbing</h2>\n"
    },
    {
        "keys": [
            "mayb"
        ],
        "doc": "<h1><code>++mayb</code></h1>\n<p>Maybe parse</p>\n<p>Parser modifier. Need to document, an example showing failure.</p>\n<h2>Accepts</h2>\n<p>XX</p>\n<h2>Produces</h2>\n<p>XX</p>\n<h2>Source</h2>\n<pre><code>  ++  mayb  |*(bus=_rule ;~(pose bus (easy \"\")))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (abox:poja 1^1 \"not-an-array\")\n[p=[p=1 q=1] q=~]\n~zod/try=&gt; ((mayb abox):poja 1^1 \"not-an-array\")\n[p=[p=1 q=1] q=[~ [p=\"\" q=[p=[p=1 q=1] q=\"not-an-array\"]]]]\n</code></pre>\n"
    },
    {
        "keys": [
            "twel"
        ],
        "doc": "<h1><code>++twel</code></h1>\n<p>Weld two tapes</p>\n<p>Concatenates two tapes, <code>a</code> and <code>b</code>, producing a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <a href=\"\"><code>++tape</code></a>.</p>\n<p><code>b</code> is a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++edge</code></a> of a <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  twel  |=([a=tape b=tape] (weld a b))\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (twel \"sam\" \"hok\"):poja\n~[~~s ~~a ~~m ~~h ~~o ~~k]\n~zod/try=&gt; (twel \"kre\" \"\"):poja\n~[~~k ~~r ~~e]\n</code></pre>\n"
    },
    {
        "keys": [
            "piec"
        ],
        "doc": "<h1><code>++piec</code></h1>\n<p>Parse char to list</p>\n<p>Parser modifer. Parses an atom with <code>bus</code> and then wraps it in a\n<a href=\"\"><code>++list</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>bus</code> is a <a href=\"\"><code>++rule</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++rule</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  piec\n    |*  bus=_rule\n    (cook |=(a=@ [a ~]) bus)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>d~zod/try=&gt; (scan \"4\" (piec:poja dem:ag))\n[4 ~]\n</code></pre>\n"
    },
    {
        "keys": [
            "poxa"
        ],
        "doc": "<h1><code>++poxa</code></h1>\n<p>Parse XML</p>\n<p>Parses an XML node from a <a href=\"\"><code>++cord</code></a>, producing a <a href=\"\"><code>++unit</code></a> <a href=\"\"><code>++manx</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(unit manx)</code>.</p>\n<h2>Source</h2>\n<pre><code>++  poxa                                                ::  xml parser\n  =&lt;  |=(a=cord (rush a apex))\n  |%\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (poxa '&lt;div /&gt;')\n[~ [g=[n=%div a=~] c=~]]\n~zod/try=&gt; (poxa '&lt;html&gt;&lt;head/&gt; &lt;body/&gt;&lt;/html&gt;')\n[~ [g=[n=%html a=~] c=~[[g=[n=%head a=~] c=~] [g=[n=%body a=~] c=~]]]]\n~zod/try=&gt; (poxa '&lt;script src=\"/gep/hart.js\"/&gt;')\n[~ [g=[n=%script a=~[[n=%src v=\"/gep/hart.js\"]]] c=~]]\n~zod/try=&gt; (poxa '&lt;&lt;&lt;&lt;')\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "apex"
        ],
        "doc": "<h1><code>++apex</code></h1>\n<p>Top level parser</p>\n<p>Parses a node of XML, type <a href=\"\"><code>++manx</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++manx</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  apex\n    =+  spa=;~(pose comt whit)\n    %+  knee  *manx  |.  ~+\n    %+  ifix  [(star spa) (star spa)]\n    ;~  pose\n      %+  sear  |=([a=marx b=marl c=mane] ?.(=(c n.a) ~ (some [a b])))\n        ;~(plug head (more (star comt) ;~(pose apex chrd)) tail)\n      empt\n    == \n  :: \n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '&lt;div /&gt;' apex:poxa)\n[g=[n=%div a=~] c=~]\n~zod/try=&gt; (rash '&lt;html&gt;&lt;head/&gt; &lt;body/&gt;&lt;/html&gt;' apex:poxa)\n[g=[n=%html a=~] c=~[[g=[n=%head a=~] c=~] [g=[n=%body a=~] c=~]]]\n~zod/try=&gt; (rash '&lt;script src=\"/gep/hart.js\"/&gt;' apex:poxa)\n[g=[n=%script a=~[[n=%src v=\"/gep/hart.js\"]]] c=~]\n~zod/try=&gt; (rash '&lt;&lt;&lt;&lt;' apex:poxa)\n! {1 2}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "attr"
        ],
        "doc": "<h1><code>++attr</code></h1>\n<p>Parse XML attributes</p>\n<p>Parses the list of attributes inside the opening XML tag, which is zero\nor more space-prefixed name to string values.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++mart</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  attr                                              ::  attributes\n    %+  knee  *mart  |.  ~+ \n    %-  star\n    ;~  plug\n        ;~(sfix name tis)\n        ;~  pose \n            (ifix [doq doq] (star ;~(less doq escp)))\n            (ifix [soq soq] (star ;~(less soq escp)))\n        ==\n      ==  \n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '' attr:poxa)\n~\n~zod/try=&gt; (rash 'sam=\"\"' attr:poxa)\n! {1 1}\n! exit\n~zod/try=&gt; (rash ' sam=\"\"' attr:poxa)\n~[[n=%sam v=\"\"]]\n~zod/try=&gt; (rash ' sam=\"hek\"' attr:poxa)\n~[[n=%sam v=\"hek\"]]\n~zod/try=&gt; (rash ' sam=\"hek\" res=\"actor\"' attr:poxa)\n~[[n=%sam v=\"hek\"] [n=%res v=\"actor\"]]\n~zod/try=&gt; (rash ' sam=\\'hek\\' res=\"actor\"' attr:poxa)\n~[[n=%sam v=\"hek\"] [n=%res v=\"actor\"]]\n~zod/try=&gt; (rash ' sam=\\'hek\" res=\"actor\"' attr:poxa)\n! {1 23}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "chrd"
        ],
        "doc": "<h1><code>++chrd</code></h1>\n<p>Parse character data</p>\n<p>Parsing rule. Parses XML character data.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++mars</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  chrd                                              ::  character data\n    %+  cook  |=(a=tape ^-(mars :/(a)))\n    (plus ;~(less soq doq ;~(pose (just `@`10) escp)))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash 'asa' chrd:poxa)\n[g=[n=%$ a=~[[n=%$ v=\"asa\"]]] c=~]\n~zod/try=&gt; (rash 'asa &amp;gt; are' chrd:poxa)\n[g=[n=%$ a=~[[n=%$ v=\"asa &gt; are\"]]] c=~]\n~zod/try=&gt; (rash 'asa &gt; are' chrd:poxa)\n! {1 6}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "comt"
        ],
        "doc": "<h1><code>++comt</code></h1>\n<p>Parses comments</p>\n<p>Parsing rule. Parses XML comment blocks.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++like</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  comt                                              ::  comments \n    =-  (ifix [(jest '&lt;!--') (jest '--&gt;')] (star -))\n    ;~  pose \n      ;~(less hep prn) \n      whit\n      ;~(less (jest '--&gt;') hep)\n    ==\n  ::\n</code></pre>\n<p>A <a href=\"\"><code>++unit</code></a> of.</p>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '&lt;!--  bye --&gt;' comt:poxa)\n\"  bye \"\n~zod/try=&gt; (rash '&lt;!--  bye  &gt;&lt;&lt;&lt;&gt;&lt; - - --&gt;' comt:poxa)\n\"  bye  &gt;&lt;&lt;&lt;&gt;&lt; - - \"\n~zod/try=&gt; (rash '&lt;!--  invalid --&gt;--&gt;' comt:poxa)\n! {1 18}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "escp"
        ],
        "doc": "<h1><code>++escp</code></h1>\n<p>Parse (possibly) escaped char</p>\n<p>Parsing rule. Parses a nonspecial or escaped character. Result type\n<a href=\"\"><code>++char</code></a></p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++edge</code></a> of a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  escp\n    ;~  pose\n      ;~(less gal gar pam prn)\n      (cold '&gt;' (jest '&amp;gt;'))\n      (cold '&lt;' (jest '&amp;lt;'))\n      (cold '&amp;' (jest '&amp;amp;'))\n      (cold '\"' (jest '&amp;quot;'))\n      (cold '\\'' (jest '&amp;apos;'))\n    ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash 'a' escp:poxa)\n'a'\n~zod/try=&gt; (rash 'ab' escp:poxa)\n! {1 2}\n! exit\n~zod/try=&gt; (rash '.' escp:poxa)\n'.'\n~zod/try=&gt; (rash '!' escp:poxa)\n'!'\n~zod/try=&gt; (rash '&gt;' escp:poxa)\n! {1 2}\n! exit\n~zod/try=&gt; (rash '&amp;gt;' escp:poxa)\n'&gt;'\n~zod/try=&gt; (rash '&amp;quot;' escp:poxa)\n'\"'\n</code></pre>\n"
    },
    {
        "keys": [
            "empt"
        ],
        "doc": "<h1><code>++empt</code></h1>\n<p>Parse self-closing tag</p>\n<p>Parsing rule. Parses self-closing XML tags that end in <code>/&gt;</code>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like tape)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  empt                                              ::  self-closing tag\n    %+  ifix  [gal (jest '/&gt;')]  \n    ;~(plug ;~(plug name attr) (cold ~ (star whit)))  \n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '&lt;div/&gt;' empt:poxa)\n[[%div ~] ~]\n~zod/try=&gt; (rash '&lt;pre color=\"#eeffee\" /&gt;' empt:poxa)\n[[%pre ~[[n=%color v=\"#eeffee\"]]] ~]\n~zod/try=&gt; (rash '&lt;pre color=\"#eeffee\"&gt;&lt;/pre&gt;' empt:poxa)\n! {1 21}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "head"
        ],
        "doc": "<h1><code>++head</code></h1>\n<p>Parse opening tag</p>\n<p>Parsing rule. Parses the opening tag of an XML node. Result type\n<a href=\"\"><code>++marx</code></a></p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like marx)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  head                                              ::  opening tag\n    (ifix [gal gar] ;~(plug name attr))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (rash '&lt;a&gt;' head:poxa)\n[n=%a a=~]\n~zod/try=&gt; (rash '&lt;div mal=\"tok\"&gt;' head:poxa)\n[n=%div a=~[[n=%mal v=\"tok\"]]]\n~zod/try=&gt; (rash '&lt;div mal=\"tok\" /&gt;' head:poxa)\n! {1 16}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "name"
        ],
        "doc": "<h1><code>++name</code></h1>\n<p>Parse tag name</p>\n<p>Parsing rule. Parses the name of an XML tag.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>An <a href=\"\"><code>++edge</code></a> of a <a href=\"\"><code>++mane</code></a>.</p>\n<h2>Source</h2>\n<pre><code>  ++  name                                              ::  tag name \n    %+  knee  *mane  |.  ~+\n    =+  ^=  chx\n        %+  cook  crip \n        ;~  plug \n            ;~(pose cab alf) \n            (star ;~(pose cab dot alp))\n        ==\n    ;~(pose ;~(plug ;~(sfix chx col) chx) chx)\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"ham\" name:poxa)\n%ham\n~zod/try=&gt; (scan \"ham:tor\" name:poxa)\n[%ham %tor]\n~zod/try=&gt; (scan \"ham-tor\" name:poxa)\n%ham-tor\n~zod/try=&gt; (scan \"ham tor\" name:poxa)\n! {1 4}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "tail"
        ],
        "doc": "<h1><code>++tail</code></h1>\n<p>Parse closing tag</p>\n<p>Parsing rule. Parses an XML closing tag.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like tail)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  tail  (ifix [(jest '&lt;/') gar] name)               ::  closing tag\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"&lt;/div&gt;\" tail:poxa)\n%div\n~zod/try=&gt; (scan \"&lt;/a&gt;\" tail:poxa)\n%a\n~zod/try=&gt; (scan \"&lt;/&gt;\" tail:poxa)\n! {1 3}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "whit"
        ],
        "doc": "<h1><code>++whit</code></h1>\n<p>Parse whitespace, etc.</p>\n<p>Parsing rule. Parses newlines, tabs, and spaces.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++nail</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(like char)</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  whit  (mask ~[' ' `@`0x9 `@`0xa])                 ::  whitespace\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `@`(scan \" \" whit:poxa)\n32\n~zod/try=&gt; `@`(scan \"  \" whit:poxa)\n! {1 2}\n! exit\n~zod/try=&gt; `@`(scan \"\\0a\" whit:poxa)\n10\n~zod/try=&gt; `@`(scan \"\\09\" whit:poxa)\n9\n~zod/try=&gt; `@`(scan \"\\08\" whit:poxa)\n! {1 1}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "poxo"
        ],
        "doc": "<h1><code>++poxo</code></h1>\n<p>Print XML</p>\n<p>Renders a <code>++manx</code> <code>a</code> as a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <a href=\"\"><code>++manx</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  poxo                                                ::  node to tape\n  =&lt;  |=(a=manx `tape`(apex a ~))\n  |_  unq=?                                             ::  unq\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (poxo ;div;)\n\"&lt;div&gt;&lt;/div&gt;\"\n~zod/try=&gt; (poxo ;div:(p a))\n\"&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt;\"\n~zod/try=&gt; (poxo ;div:(p:\"tree &gt; text\" a))\n\"&lt;div&gt;&lt;p&gt;tree &amp;gt; text&lt;/p&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt;\"\n</code></pre>\n"
    },
    {
        "keys": [
            "apex"
        ],
        "doc": "<h1><code>++apex</code></h1>\n<p>Inner XML printer</p>\n<p>Renders a <a href=\"\"><code>++manx</code></a> as a <a href=\"\"><code>++tape</code></a>, appending a suffix <code>rez</code>.</p>\n<p>XX is <code>rez/</code> a typo or is the <code>/</code> intentional</p>\n<h2>Accepts</h2>\n<p><code>rez</code> is a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  apex                                              ::  top level\n    |=  [mex=manx rez=tape]\n    ^-  tape\n    ?:  ?=([%$ [[%$ *] ~]] g.mex)\n      (escp v.i.a.g.mex rez)\n    =+  man=`mane`n.g.mex\n    =.  unq  |(unq =(%script man) =(%style man))\n    =+  tam=(name man)\n    =.  rez  :(weld \"&lt;/\" tam \"&gt;\" rez)\n    =+  att=`mart`a.g.mex\n    :-  '&lt;'\n    %+  welp  tam\n    =.  rez  ['&gt;' (many c.mex rez)]\n    ?~(att rez [' ' (attr att rez)])\n  ::  \n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (apex:poxo ;div; \"\")\n\"&lt;div&gt;&lt;/div&gt;\"\n~zod/try=&gt; (apex:poxo ;div:(p a) \"\").\n\"&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt;\"\n~zod/try=&gt; (apex:poxo ;div:(p a) \"--sfix\")\n\"&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt;--sfix\"\n~zod/try=&gt; (apex:poxo ;div:(p:\"tree &gt; text\" a) \"\")\n\"&lt;div&gt;&lt;p&gt;tree &amp;gt; text&lt;/p&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt;\"\n~zod/try=&gt; (~(apex poxo &amp;) ;div:(p:\"tree &gt; text\" a) \"\")\n\"&lt;div&gt;&lt;p&gt;tree &gt; text&lt;/p&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt;\"\n</code></pre>\n"
    },
    {
        "keys": [
            "attr"
        ],
        "doc": "<h1><code>++attr</code></h1>\n<p>Print attributes</p>\n<p>Render XML attributes as a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>tat</code> is a <a href=\"\"><code>++mart</code></a>.</p>\n<p><code>rez</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  attr                                              ::  attributes to tape\n    |=  [tat=mart rez=tape]\n    ^-  tape\n    ?~  tat  rez\n    =.  rez  $(tat t.tat)\n    ;:  weld \n      (name n.i.tat)\n      \"=\\\"\" \n      (escp(unq |) v.i.tat '\"' ?~(t.tat rez [' ' rez]))\n    ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (attr:poxo ~ \"\")\n\"\"\n~zod/try=&gt; (crip (attr:poxo ~[sam/\"hem\" [%tok %ns]^\"reptor\"] \"\"))\n'sam=\"hem\" tok:ns=\"reptor\"'\n~zod/try=&gt; (crip (attr:poxo ~[sam/\"hem\" [%tok %ns]^\"reptor\"] \"|appen\"))\n'sam=\"hem\" tok:ns=\"reptor\"|appen'\n</code></pre>\n"
    },
    {
        "keys": [
            "escp"
        ],
        "doc": "<h1><code>++escp</code></h1>\n<p>Escape XML</p>\n<p>Escapes the XML special characters <code>\"</code>, <code>&amp;</code>, <code>'</code>, <code>&lt;</code>, <code>&gt;</code>.</p>\n<h2>Accepts</h2>\n<p><code>tex</code>is a <a href=\"\"><code>++tape</code></a>.</p>\n<p><code>rez</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p><code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  escp                                              ::  escape for xml\n    |=  [tex=tape rez=tape]\n    ?:  unq\n      (weld tex rez)\n    =+  xet=`tape`(flop tex)\n    |-  ^-  tape\n    ?~  xet  rez\n    %=    $\n      xet  t.xet\n      rez  ?-  i.xet\n             34  ['&amp;' 'q' 'u' 'o' 't' ';' rez]\n             38  ['&amp;' 'a' 'm' 'p' ';' rez]\n             39  ['&amp;' '#' '3' '9' ';' rez]\n             60  ['&amp;' 'l' 't' ';' rez]\n             62  ['&amp;' 'g' 't' ';' rez]\n             *   [i.xet rez]\n           ==\n    ==\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (escp:poxo \"astra\" ~)\n~[~~a ~~s ~~t ~~r ~~a]\n~zod/try=&gt; `tape`(escp:poxo \"astra\" ~)\n\"astra\"\n~zod/try=&gt; `tape`(escp:poxo \"x &gt; y\" ~)\n\"x &amp;gt; y\"\n~zod/try=&gt; `tape`(~(escp poxo &amp;) \"x &gt; y\" ~)\n\"x &gt; y\"\n</code></pre>\n"
    },
    {
        "keys": [
            "name"
        ],
        "doc": "<h1><code>++name</code></h1>\n<p>Print name</p>\n<p>Renders a <a href=\"\"><code>++mane</code></a> as a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>man</code> is a <code>++mane</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  name                                              ::  name to tape\n    |=  man=mane  ^-  tape\n    ?@  man  (trip man)\n    (weld (trip -.man) `tape`[':' (trip +.man)])\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (name:poxo %$)\n\"\"\n~zod/try=&gt; (name:poxo %ham)\n\"ham\"\n~zod/try=&gt; (name:poxo %ham^%tor)\n\"ham:tor\"\n</code></pre>\n"
    },
    {
        "keys": [
            "many"
        ],
        "doc": "<h1><code>++many</code></h1>\n<p>Print node list</p>\n<p>Renders multiple XML nodes as a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>lix</code> is a <a href=\"\"><code>++list</code></a> of <a href=\"\"><code>++manx</code></a>.</p>\n<p><code>rez</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  many                                              ::  nodelist to tape\n    |=  [lix=(list manx) rez=tape]\n    |-  ^-  tape\n    ?~  lix  rez\n    (apex i.lix $(lix t.lix))\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (many:poxo ~ \"\")\n\"\"\n~zod/try=&gt; (many:poxo ;\"hare\" \"\")\n\"hare\"\n~zod/try=&gt; (many:poxo ;\"hare;{lep}ton\" \"\")\n\"hare&lt;lep&gt;&lt;/lep&gt;ton\"\n~zod/try=&gt; ;\"hare;{lep}ton\"\n[[[%~. [%~. \"hare\"] ~] ~] [[%lep ~] ~] [[%~. [%~. \"ton\"] ~] ~] ~]\n</code></pre>\n"
    },
    {
        "keys": [
            "yu"
        ],
        "doc": "<h1><code>++yu</code></h1>\n<p>UTC format constants</p>\n<h2>Source</h2>\n<pre><code>++  yu                                                  ::  UTC format constants\n  |%\n\n~zod/try=/hom&gt; yu\n&lt;4.pgn 250.tmw 41.cmo 414.rvm 101.jzo 1.ypj %164&gt;\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "mon"
        ],
        "doc": "<h1><code>++mon</code></h1>\n<p>Months</p>\n<p>Produces a list of <a href=\"\"><code>++tapes</code></a> containing the 12 months of the year.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code> of <code>++tape</code>s.</p>\n<h2>Source</h2>\n<pre><code>  ++  mon  ^-  (list tape)\n    :~  \"January\"  \"February\"  \"March\"  \"April\"  \"May\"  \"June\"  \"July\"\n        \"August\"  \"September\"  \"October\"  \"November\"  \"December\"\n    ==\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=/hom&gt; mon:yu\n&lt;&lt;\n  \"January\"\n  \"February\"\n  \"March\"\n  \"April\"\n  \"May\"\n  \"June\"\n  \"July\"\n  \"August\"\n  \"September\"\n  \"October\"\n  \"November\"\n  \"December\"\n&gt;&gt;\n~zod/try=/hom&gt; (snag 1 mon:yu)\n\"February\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "wik"
        ],
        "doc": "<h1><code>++wik</code></h1>\n<p>Weeks</p>\n<p>Produces a list of <a href=\"\">tapes</a> containing the 7 days of the week,\nbeginning with Sunday.</p>\n<h2>Source</h2>\n<pre><code>  ++  wik  ^-  (list tape)\n    :~  \"Sunday\"  \"Monday\"  \"Tuesday\"  \"Wednesday\"  \"Thursday\"\n        \"Friday\"  \"Saturday\"\n    ==\n  ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=/hom&gt; wik:yu\n&lt;&lt;\"Sunday\" \"Monday\" \"Tuesday\" \"Wednesday\" \"Thursday\" \"Friday\" \"Saturday\"&gt;&gt;\n~zod/try=/hom&gt; (snag 2 wik:yu)\n\"Tuesday\"\n~zod/try=/hom&gt; (snag (daws (yore -&lt;-)) wik:yu)\n\"Tuesday\"\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "les"
        ],
        "doc": "<h1><code>++les</code></h1>\n<p>Leap second dates</p>\n<p>Produces a <a href=\"\"><code>++list</code></a> of the (absolute) dates ([<code>@da</code>]) of the 25 leap seconds.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code> of atoms of odor <code>@da</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  les  ^-  (list ,@da)\n    :~  ~2015.7.1 ~2012.7.1  ~2009.1.1  ~2006.1.1  ~1999.1.1  ~1997.7.1\n        ~1996.1.1  ~1994.7.1  ~1993.7.1  ~1992.7.1  ~1991.1.1  ~1990.1.1\n        ~1988.1.1  ~1985.7.1  ~1983.7.1  ~1982.7.1  ~1981.7.1  ~1980.1.1\n        ~1979.1.1  ~1978.1.1  ~1977.1.1  ~1976.1.1  ~1975.1.1  ~1974.1.1\n        ~1973.1.1 ~1972.7.1\n    ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=/hom&gt; les:yu\n~[\n  ~2015.7.1\n  ~2012.7.1\n  ~2009.1.1\n  ~2006.1.1\n  ~1999.1.1\n  ~1997.7.1\n  ~1996.1.1\n  ~1994.7.1\n  ~1993.7.1\n  ~1992.7.1\n  ~1991.1.1\n  ~1990.1.1\n  ~1988.1.1\n  ~1985.7.1\n  ~1983.7.1\n  ~1982.7.1\n  ~1981.7.1\n  ~1980.1.1\n  ~1979.1.1\n  ~1978.1.1\n  ~1977.1.1\n  ~1976.1.1\n  ~1975.1.1\n  ~1974.1.1\n  ~1973.1.1\n  ~1972.7.1\n]\n~zod/try=/hom&gt; (snag 2 les:yu)\n~2006.1.1\n</code></pre>\n<hr>\n"
    },
    {
        "keys": [
            "lef"
        ],
        "doc": "<h1><code>++lef</code></h1>\n<p>Back-shifted leap second dates</p>\n<p>Produces a <a href=\"\"><code>++list</code></a> of absolute dates (<a href=\"\"><code>@da</code></a>s) that represent the Urbit\nGalactc Time equivalents of the UTC leap second dates in <a href=\"/docs/hoon/library/3bc#++les\"><code>++les</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++list</code> of atoms of odor <code>@da</code>.</p>\n<h2>Source</h2>\n<pre><code>  ++  lef  ^-  (list ,@da)\n    :~  ~2015.6.30..23.59.59   ~2012.6.30..23.59.59\n        ~2008.12.31..23.59.58  ~2005.12.31..23.59.57\n        ~1998.12.31..23.59.56  ~1997.6.30..23.59.55\n        ~1995.12.31..23.59.54  ~1994.6.30..23.59.53\n        ~1993.6.30..23.59.52   ~1992.6.30..23.59.51\n        ~1990.12.31..23.59.50  ~1989.12.31..23.59.49\n        ~1987.12.31..23.59.48  ~1985.6.30..23.59.47\n        ~1983.6.30..23.59.46   ~1982.6.30..23.59.45\n        ~1981.6.30..23.59.44   ~1979.12.31..23.59.43\n        ~1978.12.31..23.59.42  ~1977.12.31..23.59.41\n        ~1976.12.31..23.59.40  ~1975.12.31..23.59.39\n        ~1974.12.31..23.59.38  ~1973.12.31..23.59.37\n        ~1972.12.31..23.59.36  ~1972.6.30..23.59.35\n    ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=/hom&gt; lef:yu\n~[\n  ~2015.6.30..23.59.59\n  ~2012.6.30..23.59.59\n  ~2008.12.31..23.59.58\n  ~2005.12.31..23.59.57\n  ~1998.12.31..23.59.56\n  ~1997.6.30..23.59.55\n  ~1995.12.31..23.59.54\n  ~1994.6.30..23.59.53\n  ~1993.6.30..23.59.52\n  ~1992.6.30..23.59.51\n  ~1990.12.31..23.59.50\n  ~1989.12.31..23.59.49\n  ~1987.12.31..23.59.48\n  ~1985.6.30..23.59.47\n  ~1983.6.30..23.59.46\n  ~1982.6.30..23.59.45\n  ~1981.6.30..23.59.44\n  ~1979.12.31..23.59.43\n  ~1978.12.31..23.59.42\n  ~1977.12.31..23.59.41\n  ~1976.12.31..23.59.40\n  ~1975.12.31..23.59.39\n  ~1974.12.31..23.59.38\n  ~1973.12.31..23.59.37\n  ~1972.12.31..23.59.36\n  ~1972.6.30..23.59.35\n]\n~zod/try=/hom&gt; (snag 2 lef:yu)\n~2005.12.31..23.59.57\n</code></pre>\n"
    },
    {
        "keys": [
            "clan"
        ],
        "doc": "<h1><code>++clan</code></h1>\n<p>Ship class</p>\n<h2>Accepts</h2>\n<p><code>who</code> is a <a href=\"\"><code>++ship</code></a></p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>%cube</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  clan                                                ::  ship to rank\n  |=  who=ship  ^-  rank\n  =+  wid=(met 3 who)\n  ?:  (lte wid 1)   %czar\n  ?:  =(2 wid)      %king\n  ?:  (lte wid 4)   %duke\n  ?:  (lte wid 8)   %earl\n  ?&gt;  (lte wid 16)  %pawn\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (clan ~zod)\n%czar\n~zod/main=&gt; (clan ~tyr)\n%czar\n~zod/main=&gt; (clan ~doznec)\n%king\n~zod/main=&gt; (clan ~tasfyn-partyv)\n%duke\n</code></pre>\n"
    },
    {
        "keys": [
            "dawn"
        ],
        "doc": "<h1><code>++dawn</code></h1>\n<p>Weekday of Jan 1</p>\n<p>Computes which day of the week January 1st falls on for a year <code>yer</code>,\nproducing an atom. Weeks are zero-indexed beginning on Sunday.</p>\n<h2>Accepts</h2>\n<p><code>yer</code> is an unsigned decimal, <a href=\"\"><code>@ud</code></a>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  dawn                                                ::  weekday of jan 1\n  |=  yer=@ud\n  =+  yet=(sub yer 1)\n  %-  mod  :_  7\n  :(add 1 (mul 5 (mod yet 4)) (mul 4 (mod yet 100)) (mul 6 (mod yet 400)))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (dawn 2.015)\n4\n~zod/try=&gt; (dawn 1)\n1\n~zod/try=&gt; (dawn 0)\n! subtract-underflow\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "daws"
        ],
        "doc": "<h1><code>++daws</code></h1>\n<p>Weekday of date</p>\n<p>Produces the day of the week of a given date <code>yed</code> as an atom. Weeks are\nzero-indexed beginning on Sunday.</p>\n<h2>Accepts</h2>\n<p><code>yed</code> is a <a href=\"\"><code>++date</code></a>.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  daws                                                ::  weekday of date\n  |=  yed=date\n  %-  mod  :_  7\n  (add (dawn y.yed) (sub (yawn [y.yed m.yed d.t.yed]) (yawn y.yed 1 1)))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (daws [[a=%.y y=2.014] m=6 t=[d=6 h=21 m=9 s=15 f=~[0xa16]]])\n5\n~zod/try=&gt; (daws (yore -&lt;-))\n2\n</code></pre>\n<p>(second example always returns the current date).</p>\n"
    },
    {
        "keys": [
            "deal"
        ],
        "doc": "<h1><code>++deal</code></h1>\n<p>Add leap seconds</p>\n<p>Produces a <a href=\"\"><code>++date</code></a> with the 25 leap seconds added.</p>\n<h2>Accepts</h2>\n<p><code>yer</code> is an absolute date, <a href=\"\"><code>@da</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++date</code>.</p>\n<h2>Source</h2>\n<pre><code>++  deal                                                ::  to leap sec time\n  |=  yer=@da\n  =+  n=0\n  =+  yud=(yore yer)\n  |-  ^-  date\n  ?:  (gte yer (add (snag n lef:yu) ~s1))\n    (yore (year yud(s.t (add n s.t.yud))))\n  ?:  &amp;((gte yer (snag n lef:yu)) (lth yer (add (snag n lef:yu) ~s1)))\n    yud(s.t (add +(n) s.t.yud))\n  ?:  =(+(n) (lent lef:yu))\n    (yore (year yud(s.t (add +(n) s.t.yud))))\n  $(n +(n))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (yore (bex 127))\n[[a=%.y y=226] m=12 t=[d=5 h=15 m=30 s=8 f=~]]\n~zod/try=&gt; (deal `@da`(bex 127))\n[[a=%.y y=226] m=12 t=[d=5 h=15 m=30 s=33 f=~]]\n~zod/try=&gt; (yore (bex 126))\n[[a=%.n y=146.138.512.088] m=6 t=[d=19 h=7 m=45 s=4 f=~]]\n</code></pre>\n"
    },
    {
        "keys": [
            "deft"
        ],
        "doc": "<h1><code>++deft</code></h1>\n<p>Import URL path</p>\n<p>Parse the extension the from last element of url, which is delimited\neither by a <code>.</code> or a <code>/</code>.</p>\n<h2>Accepts</h2>\n<p><code>rax</code> is a <a href=\"\"><code>++list</code></a> of <a href=\"\"><code>@t</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++pork</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  deft                                                ::  import url path\n      |=  rax=(list ,@t)\n      |-  ^-  pork\n      ?~  rax\n        [~ ~]\n      ?~  t.rax\n        =+  den=(trip i.rax)\n        =+  ^=  vex\n          %-  %-  full\n              ;~(plug sym ;~(pose (stag ~ ;~(pfix dot sym)) (easy ~)))\n          [[1 1] (trip i.rax)]\n        ?~  q.vex\n          [~ [i.rax ~]]\n        [+.p.u.q.vex [-.p.u.q.vex ~]]\n      =+  pok=$(rax t.rax)\n      :-  p.pok\n      [i.rax q.pok]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (deft /foo/bar/'baz.txt')\n[p=[~ ~.txt] q=&lt;|foo bar baz|&gt;]\n~zod/try=&gt; (deft /foo/bar/baz)\n[p=~ q=&lt;|foo bar baz|&gt;]\n</code></pre>\n"
    },
    {
        "keys": [
            "dust"
        ],
        "doc": "<h1><code>++dust</code></h1>\n<p>Print UTC format</p>\n<p>Produces a <a href=\"\"><code>++tape</code></a> of the date in UTC format.</p>\n<h2>Accepts</h2>\n<p><code>yed</code> is a <a href=\"\"><code>++date</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  dust                                                ::  print UTC format\n  |=  yed=date\n  ^-  tape\n  =+  wey=(daws yed)\n  ;:  weld\n      `tape`(snag wey (turn wik:yu |=(a=tape (scag 3 a))))\n      \", \"  ~(rud at d.t.yed)  \" \"\n      `tape`(snag (dec m.yed) (turn mon:yu |=(a=tape (scag 3 a))))\n      \" \"  (scag 1 ~(rud at y.yed))  (slag 2 ~(rud at y.yed))  \" \"\n      ~(rud at h.t.yed)  \":\"  ~(rud at m.t.yed)  \":\"  ~(rud at s.t.yed)\n      \" \"  \"+0000\"\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (dust (yore -&gt;-))\n\"Tue, 21 Oct 2014 21:35:12 +0000\"\n~zod/try=&gt; (dust [[a=%.y y=2.002] m=10 t=[d=11 h=12 m=20 s=55 f=~]])\n\"Fri, 11 Oct 2002 12:20:55 +0000\"\n</code></pre>\n"
    },
    {
        "keys": [
            "earl"
        ],
        "doc": "<h1><code>++earl</code></h1>\n<p>Localize purl</p>\n<p>Prepends a ship name to the spur of a <a href=\"\"><code>++purl</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>who</code> is a <a href=\"\"><code>@p</code></a>, a ship name.</p>\n<p><code>pul</code> is a <code>++purl</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++purl</code>.</p>\n<h2>Source</h2>\n<pre><code>++  earl                                                ::  localize purl\n      |=  [who=@p pul=purl]\n      ^-  purl\n      pul(q.q [(rsh 3 1 (scot %p who)) q.q.pul])\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (need (epur 'http://123.1.1.1/me.ham'))\n[p=[p=%.n q=~ r=[%.n p=.123.1.1.1]] q=[p=[~ ~.ham] q=&lt;|me|&gt;] r=~]\n~zod/main=&gt; (earl ~zod (need (epur 'http://123.1.1.1/me.ham')))\n[p=[p=%.n q=~ r=[%.n p=.123.1.1.1]] q=[p=[~ ~.ham] q=&lt;|zod me|&gt;] r=~]\n~zod/main=&gt; (earl ~pittyp (need (epur 'http://123.1.1.1/me.ham')))\n[p=[p=%.n q=~ r=[%.n p=.123.1.1.1]] q=[p=[~ ~.ham] q=&lt;|pittyp me|&gt;] r=~]\n~zod/main=&gt; (earn (earl ~pittyp (need (epur 'http://123.1.1.1/me.ham'))))\n\"http://123.1.1.1/pittyp/me\"\n</code></pre>\n"
    },
    {
        "keys": [
            "earn"
        ],
        "doc": "<h1><code>++earn</code></h1>\n<p>Purl to tape</p>\n<p>Parses a <a href=\"\"><code>++purl</code></a> <code>pul</code> to a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>pul</code> is a <code>++purl</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  earn                                                ::  purl to tape\n      |^  |=  pul=purl\n          ^-  tape\n          :(weld (head p.pul) \"/\" (body q.pul) (tail r.pul))\n      ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (earn [| ~ [%| .127.0.0.1]] [~ ~] ~)\n\"http://127.0.0.1/\"\n~zod/main=&gt; (earn [| ~ `/com/google/www] [~ ~] ~)\n\"http://www.google.com/\"\n~zod/main=&gt; (earn [&amp; ~ `/com/google/www] [~ ~] ~)\n\"https://www.google.com/\"\n~zod/main=&gt; (earn [&amp; `200 `/com/google/www] [~ ~] ~)\n\"https://www.google.com:200/\"\n~zod/main=&gt; (earn [&amp; `200 `/com/google/www] [~ /search] ~)\n\"https://www.google.com:200/search\"\n~zod/main=&gt; (earn [&amp; ~ `/com/google/www] [`%html /search] ~)\n\"https://www.google.com/search\"\n~zod/main=&gt; (earn [&amp; ~ `/com/google/www] [~ /search] [%q 'urbit'] ~)\n\"https://www.google.com/search?q=urbit\"\n~zod/main=&gt; (earn [&amp; ~ `/com/google/www] [~ /search] [%q 'urbit escaping?'] ~)\n\"https://www.google.com/search?q=urbit%20escaping%3F\"\n</code></pre>\n"
    },
    {
        "keys": [
            "body"
        ],
        "doc": "<h1><code>++body</code></h1>\n<p>Render URL path</p>\n<p>Renders URL path <code>pok</code> as a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>pok</code> is a <a href=\"\"><code>++pork</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  body\n        |=  pok=pork  ^-  tape\n        ?~  q.pok  ~\n        |-\n        =+  seg=(trip i.q.pok)\n        ?~  t.q.pok\n          ?~(p.pok seg (welp seg '.' (trip u.p.pok)))\n        (welp seg '/' $(q.pok t.q.pok))\n      ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (body:earn ~ /foo/mol/lok)\n\"foo/mol/lok\"\n~zod/main=&gt; (body:earn `%htm /foo/mol/lok)\n\"foo/mol/lok.htm\"\n~zod/main=&gt; (body:earn `%htm /)\n\"\"\n</code></pre>\n"
    },
    {
        "keys": [
            "head"
        ],
        "doc": "<h1><code>++head</code></h1>\n<p>Render URL beginning</p>\n<p>Renders a <code>++hart</code>, usually the beginning of a URL, as the <a href=\"\"><code>++tape</code></a>\nof a traditional URL.</p>\n<h2>Accepts</h2>\n<p><code>har</code> is a <code>++heart</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  head\n        |=  har=hart\n        ^-  tape\n        ;:  weld\n          ?:(&amp;(p.har !=([&amp; /localhost] r.har)) \"https://\" \"http://\")\n        ::\n          ?-  -.r.har\n            |  (trip (rsh 3 1 (scot %if p.r.har)))\n            &amp;  =+  rit=(flop p.r.har)\n               |-  ^-  tape\n               ?~(rit ~ (weld (trip i.rit) ?~(t.rit \"\" `tape`['.' $(rit t.rit)])))\n          ==\n        ::\n          ?~(q.har ~ `tape`[':' (trip (rsh 3 2 (scot %ui u.q.har)))])\n        ==\n      ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (head:earn | ~ %| .127.0.0.1)\n\"http://127.0.0.1\"\n~zod/main=&gt; (head:earn &amp; ~ %| .127.0.0.1)\n\"https://127.0.0.1\"\n~zod/main=&gt; (head:earn &amp; [~ 8.080] %| .127.0.0.1)\n\"https://127.0.0.1:8080\"\n~zod/main=&gt; (head:earn &amp; [~ 8.080] %&amp; /com/google/www)\n\"https://www.google.com:8080\"\n</code></pre>\n"
    },
    {
        "keys": [
            "tail"
        ],
        "doc": "<h1><code>++tail</code></h1>\n<p>Render query string</p>\n<p>Renders a <a href=\"\"><code>++quay</code></a>, a query string in hoon, to the <a href=\"\"><code>++tape</code></a> of a\ntraditional query string.</p>\n<h2>Accepts</h2>\n<p><code>kay</code> is a <code>++quay</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tail\n        |=  kay=quay\n        ^-  tape\n        ?:  =(~ kay)  ~\n        :-  '?'\n        |-  ^-  tape\n        ?~  kay  ~\n        ;:  weld\n          (urle (trip p.i.kay))\n          \"=\"\n          (urle (trip q.i.kay))\n          ?~(t.kay ~ `tape`['&amp;' $(kay t.kay)])\n        ==\n      --\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (tail:earn ~)\n\"\"\n~zod/main=&gt; (tail:earn [%ask 'bid'] ~)\n\"?ask=bid\"\n~zod/main=&gt; (tail:earn [%ask 'bid'] [%make 'well'] ~)\n\"?ask=bid&amp;make=well\"\n</code></pre>\n"
    },
    {
        "keys": [
            "fain"
        ],
        "doc": "<h1><code>++fain</code></h1>\n<p>Restructure path</p>\n<p>Splits a concrete</p>\n<p><a href=\"\"><code>++spur</code></a> out of a full <a href=\"\"><code>++path</code></a>, producing a location <a href=\"\"><code>++beam</code></a> and\na remainder <a href=\"\"><code>++path</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>hom</code> is a <code>++path</code></p>\n<h2>Produces</h2>\n<pre><code>([pair]() beam path)\n</code></pre>\n<h2>Source</h2>\n<pre><code>++  fain                                                ::  path restructure\n      |=  [hom=path raw=path]\n      =+  bem=(need (tome raw))\n      =+  [mer=(flop s.bem) moh=(flop hom)]\n      |-  ^-  (pair beam path)\n      ?~  moh\n        [bem(s hom) (flop mer)]\n      ?&gt;  &amp;(?=(^ mer) =(i.mer i.moh))\n      $(mer t.mer, moh t.moh)\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (fain / %)\n[p=[[p=~zod q=%try r=[%da p=~2014.11.1..00.07.17..c835]] s=/] q=/]\n~zod/try=&gt; (fain /lok %)\n! exit\n~zod/try=&gt; (fain / %/mer/lok/tem)\n[ p=[[p=~zod q=%try r=[%da p=~2014.11.1..00.08.03..bfdf]] s=/] \n  q=/tem/lok/mer\n]\n~zod/try=&gt; (fain /mer %/mer/lok/tem)\n[p=[[p=~zod q=%try r=[%da p=~2014.11.1..00.08.15..4da0]] s=/mer] q=/tem/lok]\n~zod/try=&gt; (fain /lok/mer %/mer/lok/tem)\n[p=[[p=~zod q=%try r=[%da p=~2014.11.1..00.08.24..4d9e]] s=/lok/mer] q=/tem]\n~zod/try=&gt; (fain /lok/mer %/mer)\n! exit\n~zod/try=&gt; (fain /hook/hymn/tor %/tor/hymn/hook/'._req_1234__')\n[ p=[[p=~zod q=%try r=[%da p=~2014.11.1..00.09.25..c321]] s=/hook/hymn/tor]\n  q=/._req_1234__\n]\n</code></pre>\n"
    },
    {
        "keys": [
            "feel"
        ],
        "doc": "<h1><code>++feel</code></h1>\n<p>Generate file diff</p>\n<p>Generates a diff between a file located at <code>pax</code> and an input value\n<code>val</code>.</p>\n<h2>Accepts</h2>\n<p><code>pax</code> is a <a href=\"\"><code>++path</code></a>.</p>\n<p><code>val</code> is a value as a <a href=\"\">noun</a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++miso</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  feel                                                ::  simple file write\n      |=  [pax=path val=*]\n      ^-  miso\n      =+  dir=((hard arch) .^(%cy pax))\n      ?~  q.dir  [%ins val]\n      :-  %mut\n      ^-  udon\n      [%a %a .^(%cx pax) val]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; + %/mel 'test'\n+ /~zod/try/2/mel\n~zod/try=&gt; (feel %/mel 'tesh?')\n[%mut p=[p=%a q=[%a p=44.903.392.628 q=272.335.332.724]]]\n~zod/try=&gt; `@t`44.903.392.628\n'''\ntest\n'''\n~zod/try=&gt; `@t`272.335.332.724\n'tesh?'\n</code></pre>\n"
    },
    {
        "keys": [
            "file"
        ],
        "doc": "<h1><code>++file</code></h1>\n<p>Simple file load</p>\n<p>Reads the value of a file located at <code>pax</code> and renders it as a\n<a href=\"\"><code>++unit</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>pax</code> is a <a href=\"\"><code>++path</code></a>.</p>\n<h2>Produces</h2>\n<p>The <code>++unit</code> of a <a href=\"\"><code>++noun</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  file                                                ::  simple file load\n      |=  pax=path\n      ^-  (unit)\n      =+  dir=((hard arch) .^(%cy pax))\n      ?~(q.dir ~ [~ .^(%cx pax)])\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; %/zak\n~zod/try=/zak&gt; :ls %\n~zod/try=/zak&gt; + %/mop 20\n+ /~zod/try/3/zak/mop\n~zod/try=/zak&gt; :ls %\nmop\n~zod/try=/zak&gt; (file %/mop)\n[~ 20]\n~zod/try=/zak&gt; (file %/lak)\n~\n~zod/try=/zak&gt; (file /==2%/mop)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "foal"
        ],
        "doc": "<h1><code>++foal</code></h1>\n<p>Write high-level change</p>\n<p>Produces a <a href=\"\"><code>++toro</code></a>, a change intended for whatever file is located\nat <code>pax</code>. Handled by <code>%clay</code>.</p>\n<h2>Accepts</h2>\n<p><code>pax</code> is a <a href=\"\"><code>++path</code></a>.</p>\n<p><code>val</code> is a value as a <a href=\"\">noun</a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++toro</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  foal                                                ::  high-level write\n      |=  [pax=path val=*]\n      ^-  toro\n      ?&gt;  ?=([* * * *] pax)\n      [i.t.pax [%&amp; [*cart [[t.t.t.pax (feel pax val)] ~]]]]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; + %/mek 'a'\n+ /~zod/try/4/mek\n~zod/try=&gt; (foal %/mek 'b')\n[ p=~.try\n    q\n  [%.y q=[p=[p=0v0 q=0v0] q=~[[p=/mek q=[%mut p=[p=%a q=[%a p=97 q=98]]]]]]]\n]\n~zod/try=&gt; (feel %/mek 'b')\n[%mut p=[p=%a q=[%a p=97 q=98]]]\n</code></pre>\n"
    },
    {
        "keys": [
            "fray"
        ],
        "doc": "<h1><code>++fray</code></h1>\n<p>High-level delete</p>\n<p>Produces a deletion <a href=\"\"><code>++toro</code></a> for a file located at path <code>pax</code>.\nHandled by <code>%clay</code>.</p>\n<h2>Accepts</h2>\n<p><code>pax</code> is a <a href=\"\"><code>++path</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++toro</code>.</p>\n<h2>Source</h2>\n<pre><code>++  fray                                                ::  high-level delete\n      |=  pax=path\n      ^-  toro\n      ?&gt;  ?=([* * * *] pax)\n      [i.t.pax [%&amp; [*cart [[t.t.t.pax [%del .^(%cx pax)]] ~]]]]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; + %/mek 'a'\n+ /~zod/try/4/mek\n~zod/try=&gt; (fray %/mek)\n[p=~.try q=[%.y q=[p=[p=0v0 q=0v0] q=~[[p=/mek q=[%del p=97]]]]]]\n~zod/try=&gt; `@t`97\n'a'\n</code></pre>\n"
    },
    {
        "keys": [
            "fuel"
        ],
        "doc": "<h1><code>++fuel</code></h1>\n<p>Parse fcgi</p>\n<p>Retrieieves the %eyre FCGI, producing a <a href=\"\"><code>++epic</code></a>. Used primarily in\n<a href=\"\"><code>/hook</code></a> files. See the <a href=\"\"><code>%eyre</code></a> doc for more detail.</p>\n<h2>Accepts</h2>\n<p><code>bem</code> is a <a href=\"\"><code>++beam</code></a>.</p>\n<p><code>but</code> is a <a href=\"\"><code>++path</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++epic</code>.</p>\n<h2>Source</h2>\n<pre><code>++  fuel                                                ::  parse fcgi\n      |=  [bem=beam but=path]\n      ^-  epic\n      ?&gt;  ?=([%web @ *] but)\n      =+  dyb=(slay i.t.but)\n      ?&gt;  ?&amp;  ?=([~ %many *] dyb)\n              ?=([* * *] p.u.dyb)\n              ::  ?=([%$ %tas *] i.p.u.dyb)\n              ?=([%many *] i.p.u.dyb)\n              ?=([%blob *] i.t.p.u.dyb)\n          ==\n      =+  ced=((hard cred) p.i.t.p.u.dyb)\n      ::  =+  nep=q.p.i.p.u.dyb\n      =+  ^=  nyp  ^-  path\n          %+  turn  p.i.p.u.dyb\n          |=  a=coin  ^-  @ta\n          ?&gt;  ?=([%$ %ta @] a)\n          ?&gt;(((sane %ta) q.p.a) q.p.a)\n      =+  ^=  gut  ^-  (list ,@t)\n          %+  turn  t.t.p.u.dyb\n          |=  a=coin  ^-  @t\n          ?&gt;  ?=([%$ %t @] a)\n          ?&gt;(((sane %t) q.p.a) q.p.a)\n      =+  ^=  quy\n          |-  ^-  (list ,[p=@t q=@t])\n          ?~  gut  ~\n          ?&gt;  ?=(^ t.gut)\n          [[i.gut i.t.gut] $(gut t.t.gut)]\n      :*  (~(gas by *(map cord cord)) quy)\n          ced\n          bem\n          t.t.but\n          nyp\n      ==\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (fuel [[p=~zod q=%try r=[%ud p=2]] s=/psal] /web/'._.~-~~~~.gen~-~-_~~05vg0001v09f0n30fbh7dn6ab2jakmmspdq04nef5h70qbd5lh6atr4c5j2qrbldpp62q1df1in0sr1ding0c3qgt7kclj74qb65lm6atrkc5k2qpr5e1mmispdchin4p3fegmiqrjpdlo62p1dchsn4p39comn8pbcehgmsbbef5p7crrifr3o035dhgfrk2b5__')\n[ qix={}\n    ced\n  [ hut=[p=%.y q=[~ 8.445] r=[%.n p=.0.0.0.0]]\n    aut={[p=%$ q={'~rovryn-natlet-fidryd-dapmyn--todred-simpeg-hatwel-firfet'}]}\n    orx='laspex-harnum-fadweb-mipbyn'\n    acl=[~ 'en-US,en;q=0.8']\n    cip=[%.y p=.127.0.0.1]\n    cum={}\n  ]\n  bem=[[p=~zod q=%try r=[%ud p=2]] s=/psal]\n  but=/\n  nyp=/gen\n]\n</code></pre>\n"
    },
    {
        "keys": [
            "furl"
        ],
        "doc": "<h1><code>++furl</code></h1>\n<p>Unify changes</p>\n<p>Merge two <a href=\"\"><code>++toro</code></a>s <code>one</code> and <code>two</code> that are in the same <a href=\"\"><code>desk</code></a>\nand pointed at the same <a href=\"\"><code>++path</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>one</code> is a <code>++toro</code>.</p>\n<p><code>two</code> is a <code>++toro</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++toro</code>.</p>\n<h2>Source</h2>\n<pre><code>++  furl                                                ::  unify changes\n      |=  [one=toro two=toro]\n      ^-  toro\n      ~|  %furl\n      ?&gt;  ?&amp;  =(p.one p.two)                                ::  same path\n              &amp;(?=(&amp; -.q.one) ?=(&amp; -.q.two))                ::  both deltas\n          ==\n      [p.one [%&amp; [*cart (weld q.q.q.one q.q.q.two)]]]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; %/zak\n~zod/try=/zak&gt; :ls %\nmop\n~zod/try=/zak&gt; (furl (fray %/mop) (foal %/mok 'hi'))\n[ p=~.try\n    q\n  [ %.y\n      q\n    [ p=[p=0v0 q=0v0]\n      q=~[[p=/zak/mop q=[%del p=20]] [p=/zak/mok q=[%ins p=26.984]]]\n    ]\n  ]\n]\n</code></pre>\n"
    },
    {
        "keys": [
            "glam"
        ],
        "doc": "<h1><code>++glam</code></h1>\n<p>Galaxy names</p>\n<p>Retrieves the 'name' of a given Galaxy.</p>\n<h2>Accepts</h2>\n<p><code>zar</code> is a <code>@p</code> of one byte, the length of a Galaxy name.</p>\n<h2>Source</h2>\n<pre><code>++  glam\n  |=  zar=@pD  ^-  tape\n  %+  snag  zar\n  ^-  (list tape)\n  :~  \"Tianming\"  \"Pepin the Short\"  \"Haile Selassie\"  \"Alfred the Great\"\n      \"Tamerlane\"  \"Pericles\"  \"Talleyrand\"  \"Yongle\"  \"Seleucus\"\n      \"Uther Pendragon\"  \"Louis XVI\"  \"Ahmad Sh\u0101h Durr\u0101n\u012b\"  \"Constantine\"\n      \"Wilhelm I\"  \"Akbar\"  \"Louis XIV\"  \"Nobunaga\"  \"Alexander VI\"\n      \"Philippe II\"  \"Julius II\"  \"David\"  \"Niall No\u00edg\u00edallach\"  \"Kublai Khan\"\n      \"\u00d6z Beg Khan\"  \"Ozymandias\"  \"\u00d6gedei Khan\"  \"Jiang Jieshi\"  \"Darius\"\n      \"Shivaji\"  \"Qianlong\"  \"Boles\u0142aw I Chrobry\"  \"Tigranes\"  \"Han Wudi\"\n      \"Charles X\"  \"Naresuan\"  \"Frederick II\"  \"Simeon\"  \"Kangxi\"\n      \"Suleiman the Magnificent\"  \"Pedro II\"  \"Genghis Khan\"  \"Laozi\"\n      \"Porfirio D\u00edaz\"  \"Pakal\"  \"Wu Zetian\"  \"Garibaldi\"  \"Matthias Corvinus\"\n      \"Leopold II\"  \"Leonidas\"  \"Sitting Bull\"  \"Nebuchadnezzar II\"\n      \"Rhodes\"  \"Henry VIII\"  \"Attila\"  \"Catherine II\"  \"Chulalongkorn\"\n      \"Uthm\u0101n\"  \"Augustus\"  \"Faustin\"  \"Chongde\"  \"Justinian\"\n      \"Afonso de Albuquerque\"  \"Antoninus Pius\"  \"Cromwell\"  \"Innocent X\"\n      \"Fidel\"  \"Frederick the Great\"  \"Canute\"  \"Vytautas\"  \"Amina\"\n      \"Hammurabi\"  \"Suharto\"  \"Victoria\"  \"Hiawatha\"  \"Paul V\"  \"Shaka\"\n      \"L\u00ea Th\u00e1nh T\u00f4ng\"  \"Ivan Asen II\"  \"Tiridates\"  \"Nefertiti\"  \"Gwangmu\"\n      \"Ferdinand &amp; Isabella\"  \"Askia\"  \"Xuande\"  \"Boris Godunov\"  \"Gilgamesh\"\n      \"Maximillian I\"  \"Mao\"  \"Charlemagne\"  \"Narai\"  \"Hanno\"  \"Charles I &amp; V\"\n      \"Alexander II\"  \"Mansa Musa\"  \"Zoe Porphyrogenita\"  \"Metternich\"\n      \"Robert the Bruce\"  \"Pachacutec\"  \"Jefferson\"  \"Solomon\"  \"Nicholas I\"\n      \"Barbarossa\"  \"FDR\"  \"Pius X\"  \"Gwanggaeto\"  \"Abbas I\"  \"Julius Caesar\"\n      \"Lee Kuan Yew\"  \"Ranavalona I\"  \"Go-Daigo\"  \"Zenobia\"  \"Henry V\"\n      \"B\u1ea3o \u0110\u1ea1i\"  \"Casimir III\"  \"Cyrus\"  \"Charles the Wise\"  \"Sandrokottos\"\n      \"Agamemnon\"  \"Clement VII\"  \"Suppiluliuma\"  \"Deng Xiaoping\"\n      \"Victor Emmanuel\"  \"Ajatasatru\"  \"Jan Sobieski\"  \"Huangdi\"  \"Xuantong\"\n      \"Narmer\"  \"Cosimo de' Medici\"  \"M\u00f6ngke Khan\"  \"Stephen Du\u0161an\"  \"Henri IV\"\n      \"Mehmed Fatih\"  \"Conn C\u00e9tchathach\"  \"Francisco Franco\"  \"Leo X\"\n      \"Kammu\"  \"Krishnadevaraya\"  \"Elizabeth I\"  \"Norton I\"  \"Washington\"\n      \"Meiji\"  \"Umar\"  \"TR\"  \"Peter the Great\"  \"Agustin I\"  \"Ashoka\"\n      \"William the Conqueror\"  \"Kongolo Mwamba\"  \"Song Taizu\"\n      \"Ivan the Terrible\"  \"Yao\"  \"Vercingetorix\"  \"Geronimo\"  \"Rurik\"\n      \"Urban VIII\"  \"Alexios Komnenos\"  \"Maria I\"  \"Tamar\"  \"Bismarck\"\n      \"Arthur\"  \"Jimmu\"  \"Gustavus Adolphus\"  \"Suiko\"  \"Basil I\"  \"Montezuma\"\n      \"Santa Anna\"  \"Xerxes\"  \"Beyaz\u0131t Y\u0131ld\u0131r\u0131m\"  \"Samudragupta\"  \"James I\"\n      \"George III\"  \"Kamehameha\"  \"Francesco Sforza\"  \"Trajan\"\n      \"Rajendra Chola\"  \"Hideyoshi\"  \"Cleopatra\"  \"Alexander\"\n      \"Ashurbanipal\"  \"Paul III\"  \"Vespasian\"  \"Tecumseh\"  \"Narasimhavarman\"\n      \"Suryavarman II\"  \"Bokassa I\"  \"Charles Canning\"  \"Theodosius\"\n      \"Francis II\"  \"Zhou Wen\"  \"William Jardine\"  \"Ahmad al-Mansur\"\n      \"Lajos Nagy\"  \"Theodora\"  \"Mussolini\"  \"Samuil\"  \"Osman Gazi\"\n      \"Kim Il-sung\"  \"Maria Theresa\"  \"Lenin\"  \"Tokugawa\"  \"Marcus Aurelius\"\n      \"Nzinga Mbande\"  \"Edward III\"  \"Joseph II\"  \"Pulakesi II\"  \"Priam\"\n      \"Qin Shi Huang\"  \"Shah Jahan\"  \"Sejong\"  \"Sui Wendi\"  \"Otto I\"\n      \"Napoleon III\"  \"Prester John\"  \"Dido\"  \"Joao I\"  \"Gregory I\"\n      \"Gajah Mada\"  \"Abd-ar Rahm\u0101n III\"  \"Taizong\"  \"Franz Josef I\"\n      \"Nicholas II\"  \"Gandhi\"  \"Chandragupta II\"  \"Peter III\"\n      \"Oba Ewuare\"  \"Louis IX\"  \"Napoleon\"  \"Selim Yavuz\"  \"Shun\"\n      \"Hayam Wuruk\"  \"Jagie\u0142\u0142o\"  \"Nicaule\"  \"Sargon\"  \"Saladin\"  \"Charles II\"\n      \"Brian Boru\"  \"Da Yu\"  \"Antiochus III\"  \"Charles I\"\n      \"Jan Pieterszoon Coen\"  \"Hongwu\"  \"Mithridates\"  \"Hadrian\"  \"Ptolemy\"\n      \"Benito Juarez\"  \"Sun Yat-sen\"  \"Raja Raja Chola\"  \"Bolivar\"  \"Pius VII\"\n      \"Shapur II\"  \"Taksin\"  \"Ram Khamhaeng\"  \"Hatshepsut\"  \"Al\u012b\"  \"Matilda\"\n      \"Ataturk\"\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (glam ~zod)\n\"Tianming\"\n~zod/main=&gt; (glam ~fyr)\n\"Bolivar\"\n</code></pre>\n"
    },
    {
        "keys": [
            "glon"
        ],
        "doc": "<h1><code>++glon</code></h1>\n<p>ISO language code</p>\n<p>XX</p>\n<h2>Accepts</h2>\n<p><code>lag</code> is a <a href=\"\"><code>++lang</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  glon\n  |=  lag=lang\n  ^-  (unit tape)\n  ?+  lag  ~\n    %aa  [~ \"Afar\"]\n    %ab  [~ \"Abkhazian\"]\n    %ae  [~ \"Avestan\"]\n    %af  [~ \"Afrikaans\"]\n    %ak  [~ \"Akan\"]\n    %am  [~ \"Amharic\"]\n    %an  [~ \"Aragonese\"]\n    %ar  [~ \"Arabic\"]\n    %as  [~ \"Assamese\"]\n    %av  [~ \"Avaric\"]\n    %ay  [~ \"Aymara\"]\n    %az  [~ \"Azerbaijani\"]\n    %ba  [~ \"Bashkir\"]\n    %be  [~ \"Belarusian\"]\n    %bg  [~ \"Bulgarian\"]\n    %bh  [~ \"Bihari\"]\n    %bi  [~ \"Bislama\"]\n    %bm  [~ \"Bambara\"]\n    %bn  [~ \"Bengali\"]\n    %bo  [~ \"Tibetan\"]\n    %br  [~ \"Breton\"]\n    %bs  [~ \"Bosnian\"]\n    %ca  [~ \"Catalan\"]\n    %ce  [~ \"Chechen\"]\n    %ch  [~ \"Chamorro\"]\n    %co  [~ \"Corsican\"]\n    %cr  [~ \"Cree\"]\n    %cs  [~ \"Czech\"]\n    %cu  [~ \"Slavonic\"]\n    %cv  [~ \"Chuvash\"]\n    %cy  [~ \"Welsh\"]\n    %da  [~ \"Danish\"]\n    %de  [~ \"German\"]\n    %dv  [~ \"Maldivian\"]\n    %dz  [~ \"Dzongkha\"]\n    %ee  [~ \"Ewe\"]\n    %el  [~ \"Greek\"]\n    %en  [~ \"English\"]\n    %eo  [~ \"Esperanto\"]\n    %es  [~ \"Spanish\"]\n    %et  [~ \"Estonian\"]\n    %eu  [~ \"Basque\"]\n    %fa  [~ \"Persian\"]\n    %ff  [~ \"Fulah\"]\n    %fi  [~ \"Finnish\"]\n    %fj  [~ \"Fijian\"]\n    %fo  [~ \"Faroese\"]\n    %fr  [~ \"French\"]\n    %fy  [~ \"Frisian\"]\n    %ga  [~ \"Irish Gaelic\"]\n    %gd  [~ \"Scottish Gaelic\"]\n    %gl  [~ \"Galician\"]\n    %gn  [~ \"Guarani\"]\n    %gu  [~ \"Gujarati\"]\n    %gv  [~ \"Manx\"]\n    %ha  [~ \"Hausa\"]\n    %he  [~ \"Hebrew\"]\n    %hi  [~ \"Hindi\"]\n    %ho  [~ \"Hiri Motu\"]\n    %hr  [~ \"Croatian\"]\n    %ht  [~ \"Haitian Creole\"]\n    %hu  [~ \"Hungarian\"]\n    %hy  [~ \"Armenian\"]\n    %hz  [~ \"Herero\"]\n    %ia  [~ \"Interlingua\"]\n    %id  [~ \"Indonesian\"]\n    %ie  [~ \"Occidental\"]\n    %ig  [~ \"Igbo\"]\n    %ii  [~ \"Nuosu\"]\n    %ik  [~ \"Inupiaq\"]\n    %io  [~ \"Ido\"]\n    %is  [~ \"Icelandic\"]\n    %it  [~ \"Italian\"]\n    %iu  [~ \"Inuktitut\"]\n    %ja  [~ \"Japanese\"]\n    %jv  [~ \"Javanese\"]\n    %ka  [~ \"Georgian\"]\n    %kg  [~ \"Kongo\"]\n    %ki  [~ \"Kikuyu\"]\n    %kj  [~ \"Kwanyama\"]\n    %kk  [~ \"Kazakh\"]\n    %kl  [~ \"Kalaallisut\"]\n    %km  [~ \"Central Khmer\"]\n    %kn  [~ \"Kannada\"]\n    %ko  [~ \"Korean\"]\n    %kr  [~ \"Kanuri\"]\n    %ks  [~ \"Kashmiri\"]\n    %ku  [~ \"Kurdish\"]\n    %kv  [~ \"Komi\"]\n    %kw  [~ \"Cornish\"]\n    %ky  [~ \"Kyrgyz\"]\n    %la  [~ \"Latin\"]\n    %lb  [~ \"Luxembourgish\"]\n    %lg  [~ \"Ganda\"]\n    %li  [~ \"Limburgish\"]\n    %ln  [~ \"Lingala\"]\n    %lo  [~ \"Lao\"]\n    %lt  [~ \"Lithuanian\"]\n    %lu  [~ \"Luba-Katanga\"]\n    %lv  [~ \"Latvian\"]\n    %mg  [~ \"Malagasy\"]\n    %mh  [~ \"Marshallese\"]\n    %mi  [~ \"Maori\"]\n    %mk  [~ \"Macedonian\"]\n    %ml  [~ \"Malayalam\"]\n    %mn  [~ \"Mongolian\"]\n    %mr  [~ \"Marathi\"]\n    %ms  [~ \"Malay\"]\n    %mt  [~ \"Maltese\"]\n    %my  [~ \"Burmese\"]\n    %na  [~ \"Nauru\"]\n    %nb  [~ \"Norwegian Bokm\u00e5l\"]\n    %nd  [~ \"North Ndebele\"]\n    %ne  [~ \"Nepali\"]\n    %ng  [~ \"Ndonga\"]\n    %nl  [~ \"Dutch\"]\n    %nn  [~ \"Norwegian Nynorsk\"]\n    %no  [~ \"Norwegian\"]\n    %nr  [~ \"South Ndebele\"]\n    %nv  [~ \"Navajo\"]\n    %ny  [~ \"Chichewa\"]\n    %oc  [~ \"Occitan\"]\n    %oj  [~ \"Ojibwa\"]\n    %om  [~ \"Oromo\"]\n    %or  [~ \"Oriya\"]\n    %os  [~ \"Ossetian\"]\n    %pa  [~ \"Punjabi\"]\n    %pi  [~ \"Pali\"]\n    %pl  [~ \"Polish\"]\n    %ps  [~ \"Pashto\"]\n    %pt  [~ \"Portuguese\"]\n    %qu  [~ \"Quechua\"]\n    %rm  [~ \"Romansh\"]\n    %rn  [~ \"Rundi\"]\n    %ro  [~ \"Romanian\"]\n    %ru  [~ \"Russian\"]\n    %rw  [~ \"Kinyarwanda\"]\n    %sa  [~ \"Sanskrit\"]\n    %sc  [~ \"Sardinian\"]\n    %sd  [~ \"Sindhi\"]\n    %se  [~ \"Northern Sami\"]\n    %sg  [~ \"Sango\"]\n    %si  [~ \"Sinhala\"]\n    %sk  [~ \"Slovak\"]\n    %sl  [~ \"Slovenian\"]\n    %sm  [~ \"Samoan\"]\n    %sn  [~ \"Shona\"]\n    %so  [~ \"Somali\"]\n    %sq  [~ \"Albanian\"]\n    %sr  [~ \"Serbian\"]\n    %ss  [~ \"Swati\"]\n    %st  [~ \"Sotho\"]\n    %su  [~ \"Sundanese\"]\n    %sv  [~ \"Swedish\"]\n    %sw  [~ \"Swahili\"]\n    %ta  [~ \"Tamil\"]\n    %te  [~ \"Telugu\"]\n    %tg  [~ \"Tajik\"]\n    %th  [~ \"Thai\"]\n    %ti  [~ \"Tigrinya\"]\n    %tk  [~ \"Turkmen\"]\n    %tl  [~ \"Tagalog\"]\n    %tn  [~ \"Tswana\"]\n    %to  [~ \"Tonga\"]\n    %tr  [~ \"Turkish\"]\n    %ts  [~ \"Tsonga\"]\n    %tt  [~ \"Tatar\"]\n    %tw  [~ \"Twi\"]\n    %ty  [~ \"Tahitian\"]\n    %ug  [~ \"Uighur\"]\n    %uk  [~ \"Ukrainian\"]\n    %ur  [~ \"Urdu\"]\n    %uz  [~ \"Uzbek\"]\n    %ve  [~ \"Venda\"]\n    %vi  [~ \"Vietnamese\"]\n    %vo  [~ \"Volap\u00fck\"]\n    %wa  [~ \"Walloon\"]\n    %wo  [~ \"Wolof\"]\n    %xh  [~ \"Xhosa\"]\n    %yi  [~ \"Yiddish\"]\n    %yo  [~ \"Yoruba\"]\n    %za  [~ \"Zhuang\"]\n    %zh  [~ \"Chinese\"]\n    %zu  [~ \"Zulu\"]\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (glon %cs)\n[~ \"Czech\"]\n~zod/main=&gt; (glon %en)\n[~ \"English\"]\n~zod/main=&gt; (glon %mz)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "gnom"
        ],
        "doc": "<h1><code>++gnom</code></h1>\n<p>Display ship name</p>\n<p>Fetches a ship's display name from %ames.</p>\n<h2>Accepts</h2>\n<p><code>our</code> is a <a href=\"\"><code>@p</code></a>.</p>\n<p><code>now</code> is a <a href=\"\"><code>@da</code></a>.</p>\n<p><code>him</code> is a <a href=\"\"><code>@p</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  gnom                                                ::  ship display name\n  |=  [[our=@p now=@da] him=@p]  ^-  @t\n  =+  yow=(scot %p him)\n  =+  pax=[(scot %p our) %name (scot %da now) yow ~]\n  =+  woy=((hard ,@t) .^(%a pax))\n  ?:  =(%$ woy)  yow\n  (rap 3 yow ' ' woy ~)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (gnom [-&gt;-&lt; -&lt;-] ~zod)\n'~zod |Tianming|'\n~zod/main=&gt; (gnom [-&gt;-&lt; -&lt;-] ~doznec)\n'~doznec ~doznec'\n~zod/main=&gt; (gnom [-&gt;-&lt; -&lt;-] ~tug)\n'~tug |Go-Daigo|'\n</code></pre>\n"
    },
    {
        "keys": [
            "jape"
        ],
        "doc": "<h1><code>++jape</code></h1>\n<p><code>++json</code> string from tape</p>\n<p>Produces a <a href=\"\"><code>++json</code></a> string from a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p>A <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++json</code>.</p>\n<h2>Source</h2>\n<pre><code>++  jape                                                ::  string from tape\n  |=  a=tape\n  ^-  json\n  [%s (crip a)]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (jape ~)\n[%s p=~.]\n~zod/try=&gt; (jape \"lam\")\n[%s p=~.lam]\n~zod/try=&gt; (crip (pojo (jape \"lam\")))\n'\"lam\"'\n~zod/try=&gt; (crip (pojo (jape \"semtek som? zeplo!\")))\n'\"semtek som? zeplo!\"'\n</code></pre>\n"
    },
    {
        "keys": [
            "jesc"
        ],
        "doc": "<h1><code>++jesc</code></h1>\n<p>Escape JSON character</p>\n<p>Produces a <a href=\"\"><code>++tape</code></a> of an escaped <a href=\"/docs/hoon/library/3bi#++json\"><code>++json</code></a> character <code>a</code>.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom of odor <a href=\"\"><code>@tD</code></a>, aka a <a href=\"\"><code>++char</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  jesc\n  |=  a=@  ^-  tape\n  ?+  a  [a ~]\n    10  \"\\\\n\"\n    34  \"\\\\\\\"\"\n    92  \"\\\\\\\\\"\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (jesc 'a')\n\"a\"\n~zod/try=&gt; (jesc 'c')\n\"c\"\n~zod/try=&gt; (jesc '\\\\')\n\"\\\\\"\n~zod/try=&gt; (jesc '\"')\n\"\\\"\"\n</code></pre>\n"
    },
    {
        "keys": [
            "joba"
        ],
        "doc": "<h1><code>++joba</code></h1>\n<p><code>++json</code> from key-value pair</p>\n<p>Produces a ++json object with one key-value pair.</p>\n<h2>Accepts</h2>\n<p><code>p</code> is a <code>@t</code> key.</p>\n<p><code>q</code> is a <a href=\"\"><code>++json</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++json</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  joba                                                ::  object from k-v pair\n  |=  [p=@t q=json]\n  ^-  json\n  [%o [[p q] ~ ~]]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (joba %hi %b |)\n[%o p={[p='hi' q=[%b p=%.n]]}]\n~zod/try=&gt; (crip (pojo (joba %hi %b |)))\n'{\"hi\":false}'\n~zod/try=&gt; (joba %hi (jone 2.130))\n[%o p={[p='hi' q=[%n p=~.2130]]}]\n~zod/try=&gt; (crip (pojo (joba %hi (jone 2.130))))\n'{\"hi\":2130}'\n</code></pre>\n"
    },
    {
        "keys": [
            "jobe"
        ],
        "doc": "<h1><code>++jobe</code></h1>\n<p>Object from key-value list</p>\n<p>Produces a <code>++json</code> object from a <a href=\"\"><code>++list</code></a> <code>a</code> of key to <code>++json</code> values.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <a href=\"\"><code>++list</code></a> of <a href=\"\"><code>++cord</code></a> to <a href=\"\"><code>++json</code></a> values.</p>\n<h2>Produces</h2>\n<p>A <code>++json</code>.</p>\n<h2>Source</h2>\n<pre><code>++  jobe                                                ::  object from k-v list\n  |=  a=(list ,[p=@t q=json])\n  ^-  json\n  [%o (~(gas by *(map ,@t json)) a)]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (jobe a/n/'20' b/~ c/a/~[s/'mol'] ~)\n[%o p={[p='a' q=[%n p=~.20]] [p='c' q=[%a p=~[[%s p=~.mol]]]] [p='b' q=~]}]\n~zod/try=&gt; (crip (pojo (jobe a/n/'20' b/~ c/a/~[s/'mol'] ~)))\n'{\"b\":null,\"c\":[\"mol\"],\"a\":20}'\n</code></pre>\n"
    },
    {
        "keys": [
            "jone"
        ],
        "doc": "<h1><code>++jone</code></h1>\n<p><code>++json</code> number from unigned</p>\n<p>Produces a <code>++json</code> number from an unsigned atom.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is an atom of odor <a href=\"\"><code>@u</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++json</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  jone                                                ::  number from unsigned\n  |=  a=@u\n  ^-  json\n  :-  %n\n  ?:  =(0 a)  '0'\n  (crip (flop |-(^-(tape ?:(=(0 a) ~ [(add '0' (mod a 10)) $(a (div a 10))])))))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (jone 1)\n[%n p=~.1]\n~zod/try=&gt; (pojo (jone 1))\n\"1\"\n~zod/try=&gt; (jone 1.203.196)\n[%n p=~.1203196]\n~zod/try=&gt; (pojo (jone 1.203.196))\n\"1203196\"\n</code></pre>\n"
    },
    {
        "keys": [
            "lead"
        ],
        "doc": "<h1><code>++lead</code></h1>\n<p>Subtract leap seconds</p>\n<p>Produces an absolute date (<a href=\"\"><code>@ud</code></a>) with the 25 leap seconds\nsubtracted.</p>\n<h2>Accepts</h2>\n<p><code>ley</code> is a <a href=\"\"><code>++date</code></a>.</p>\n<h2>Produces</h2>\n<p>An atom of <a href=\"\">odor</a> <a href=\"\"><code>@da</code></a>, which represents an absolute date.</p>\n<h2>Source</h2>\n<pre><code>++  lead                                                ::  from leap sec time\n  |=  ley=date\n  =+  ler=(year ley)\n  =+  n=0\n  |-  ^-  @da\n  =+  led=(sub ler (mul n ~s1))\n  ?:  (gte ler (add (snag n les:yu) ~s1))\n    led\n  ?:  &amp;((gte ler (snag n les:yu)) (lth ler (add (snag n les:yu) ~s1)))\n    ?:  =(s.t.ley 60)\n      (sub led ~s1)\n    led\n  ?:  =(+(n) (lent les:yu))\n    (sub led ~s1)\n  $(n +(n))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (yore `@da`(bex 127))\n[[a=%.y y=226] m=12 t=[d=5 h=15 m=30 s=8 f=~]]\n~zod/try=&gt; (lead (yore `@da`(bex 127)))\n~226.12.5..15.29.43\n~zod/try=&gt; (lead (yore `@da`(bex 126)))\n~146138512088-.6.19..07.44.39\n</code></pre>\n"
    },
    {
        "keys": [
            "mang"
        ],
        "doc": "<h1><code>++mang</code></h1>\n<p>Unit: Slam gate with sample</p>\n<p>Produces a <a href=\"\"><code>++unit</code></a> computation result from slamming <code>gat</code> with\n<code>sam</code>, using <code>sky</code> to compute or block on nock 11 when applicable.\nSimilar to <a href=\"\"><code>++mong</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>gat</code> is a <a href=\"\">noun</a> that is generally a <a href=\"\"><code>gate</code></a>.</p>\n<p><code>sam</code> is a <a href=\"\"><code>sample</code></a> noun.</p>\n<p><code>sky</code> is an <a href=\"\">%iron</a> gate invoked with <a href=\"\">nock operator 11</a>.</p>\n<h2>Produces</h2>\n<p>The <code>++unit</code> of a noun.</p>\n<h2>Source</h2>\n<pre><code>++  mang\n  |=  [[gat=* sam=*] sky=$+(* (unit))]\n  ^-  (unit)\n  =+  ton=(mong [[gat sam] sky])\n  ?.(?=([0 *] ton) ~ [~ p.ton])\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (mang [|=(@ 20) ~] ,~)\n[~ 20]\n~zod/try=&gt; (mang [|=(@ !!) ~] ,~)\n~\n~zod/try=&gt; (mang [|=(a=@ (add 20 a)) ~] ,~)\n[~ 20]\n~zod/try=&gt; (mang [|=(a=[@ @] (add 20 -.a)) ~] ,~)\n~\n~zod/try=&gt; (mang [|=(a=[@ @] (add 20 -.a)) [4 6]] ,~)\n[~ 24]\n~zod/try=&gt; (mang [|=(a=@ .^(a)) ~] ,~)\n~\n~zod/try=&gt; (mang [|=(a=@ .^(a)) ~] ,[~ %42])\n[~ 42]\n~zod/try=&gt; (mang [|=(a=@ .^(a)) ~] |=(a=* [~ a 6]))\n[~ [0 6]]\n~zod/try=&gt; (mang [|=(a=@ .^(a)) 8] |=(a=* [~ a 6]))\n[~ [8 6]]\n</code></pre>\n"
    },
    {
        "keys": [
            "meat"
        ],
        "doc": "<h1><code>++meat</code></h1>\n<p>Kite to .^ path</p>\n<p>Converts a type request name to a <a href=\"\"><code>++path</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>kit</code> is a <a href=\"\"><code>++kite</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++path</code>.</p>\n<h2>Source</h2>\n<pre><code>++  meat                                                ::  kite to .^ path\n      |=  kit=kite\n      ^-  path\n      [(cat 3 'c' p.kit) (scot %p r.kit) s.kit (scot `dime`q.kit) t.kit]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>zod/try=/zop&gt; `kite`[%x ud/1 ~zod %main /sur/down/gate/hook]\n[p=%x q=[%ud p=1] r=~zod s=%main t=/sur/down/gate/hook]\n~zod/try=/zop&gt; (meat [%x ud/1 ~zod %main /sur/down/gate/hook])\n/cx/~zod/main/1/sur/down/gate/hook\n~zod/try=/zop&gt; .^((meat [%x ud/1 ~zod %main /sur/down/gate/hook]))\n8.024.240.839.827.090.233.853.057.929.619.452.695.436.878.709.611.140.677.\n745.908.646.440.925.885.935.296.374.867.974.972.908.054.571.544.099.882.490.\n677.391.983.737.511.220.072.391.888.081.664.570\n~zod/try=/zop&gt; (,@t .^((meat [%x ud/1 ~zod %main /sur/down/gate/hook])))\n'''\n::\n::::  /hoon/gate/down/sur\n::\n/?  314\n/-  *markdown\ndown\n\n'''\n</code></pre>\n"
    },
    {
        "keys": [
            "moon"
        ],
        "doc": "<h1><code>++moon</code></h1>\n<p>Mime type to <code>++cord</code></p>\n<p>Renders a <a href=\"http://en.wikipedia.org/wiki/MIME\">mime</a> type path with infix\n<code>/</code> to a <a href=\"\"><code>++cord</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>myn</code> is a ++<a href=\"\"><code>mite</code></a>, a <a href=\"\"><code>++list</code></a> of <a href=\"\"><code>@ta</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++cord</code>.</p>\n<h2>Source</h2>\n<pre><code>++  moon                                                ::  mime type to text\n  |=  myn=mite\n  %+  rap\n    3\n  |-  ^-  tape\n  ?~  myn  ~\n  ?:  =(~ t.myn)  (trip i.myn)\n  (weld (trip i.myn) `tape`['/' $(myn t.myn)])\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; `@t`(moon /image/png)\n'image/png'\n~zod/try=&gt; `@t`(moon /text/x-hoon)\n'text/x-hoon'\n~zod/try=&gt; `@t`(moon /application/x-pnacl)\n'application/x-pnacl'\n</code></pre>\n"
    },
    {
        "keys": [
            "mung"
        ],
        "doc": "<h1><code>++mung</code></h1>\n<p>Virtualize slamming gate</p>\n<p>Produces a <a href=\"\"><code>++tone</code></a> computation result from slamming <code>gat</code> with\n<code>sam</code>, using <code>sky</code> to compute or block on nock 11 when applicable.</p>\n<h2>Accepts</h2>\n<p><code>gat</code> is a <a href=\"\">noun</a> that is generally a <a href=\"\"><code>gate</code></a>.</p>\n<p><code>sam</code> is a <a href=\"\"><code>sample</code></a> noun.</p>\n<p><code>sky</code> is an <a href=\"\">%iron</a> gate invoked with <a href=\"\">nock operator 11</a>.</p>\n<h2>Produces</h2>\n<p>A <code>++tone</code>.</p>\n<h2>Source</h2>\n<pre><code>++  mung\n  |=  [[gat=* sam=*] sky=$+(* (unit))]\n  ^-  tone\n  ?.  &amp;(?=(^ gat) ?=(^ +.gat))\n    [%2 ~]\n  (mink [[-.gat [sam +&gt;.gat]] -.gat] sky)\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (mung [|=(@ 20) ~] ,~)\n[%0 p=20]\n~zod/try=&gt; (mung [|=(@ !!) ~] ,~)\n[%2 p=~]\n~zod/try=&gt; (mung [|=(a=@ (add 20 a)) ~] ,~)\n[%0 p=20]\n~zod/try=&gt; (mung [|=(a=[@ @] (add 20 -.a)) ~] ,~)\n[%2 p=~]\n~zod/try=&gt; (mung [|=(a=[@ @] (add 20 -.a)) [4 6]] ,~)\n[%0 p=24]\n~zod/try=&gt; (mung [|=(a=@ .^(a)) ~] ,~)\n[%1 p=~[0]]\n~zod/try=&gt; (mung [|=(a=@ .^(a)) ~] ,[~ %42])\n[%0 p=42]\n~zod/try=&gt; (mung [|=(a=@ .^(a)) ~] |=(a=* [~ a 6]))\n[%0 p=[0 6]]\n~zod/try=&gt; (mung [|=(a=@ .^(a)) 8] |=(a=* [~ a 6]))\n[%0 p=[8 6]]\n</code></pre>\n"
    },
    {
        "keys": [
            "perk"
        ],
        "doc": "<h1><code>++perk</code></h1>\n<p>Parse cube with fork</p>\n<p>Parser generator. Produces a parser that succeeds upon encountering one\nof the <a href=\"\"><code>++term</code></a>s in a faceless list <code>a</code>.</p>\n<p>A perk is an arm used to parse one of a finite set of options, formally\na choice between <a href=\"\"><code>++term</code></a>s: if you want to match \"true\" or \"false\", and\nnothing else, (perk ~[%true %false]) produces the relevant parser,\nwhose result type is <code>?(%true %false)</code>. For more complicated\ntransformations, a combintation of ++<a href=\"\"><code>++sear</code></a> and map ++<a href=\"\"><code>++get</code></a> is recommended,\ne.g. <code>(sear ~(get by (mo ~[[%true &amp;] [%false |]]))) sym)</code> will have a\nsimilar effect but produce <code>?(&amp; |)</code> , a <a href=\"\">boolean</a>. However, constructions\nsuch as <code>(sear (flit ~(has in (sa %true %false %other ~))) sym)</code> are\nneedlessly unwieldy.</p>\n<h2>Accepts</h2>\n<p><code>a</code> is a <a href=\"\"><code>++pole</code></a>, which is a <a href=\"\"><code>++list</code></a> without <a href=\"\"><code>%face</code></a>s.</p>\n<h2>Produces</h2>\n<p>XX</p>\n<h2>Source</h2>\n<pre><code>++  perk                                                ::  parse cube with fork\n  |*  a=(pole ,@tas)\n  ?~  a  fail\n  ;~  pose \n    (cold -.a (jest -.a))\n    $(a +.a)\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (scan \"ham\" (perk %sam %ham %lam ~))\n%ham\n~zod/try=&gt; (scan \"ram\" (perk %sam %ham %lam ~))\n! {1 1}\n! exit\n</code></pre>\n"
    },
    {
        "keys": [
            "pojo"
        ],
        "doc": "<h1><code>++pojo</code></h1>\n<p>Print JSON</p>\n<p>Renders a <a href=\"\"><code>++json</code></a> <code>val</code> as a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>val</code> is a <a href=\"\"><code>json</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  pojo                                                ::  print json\n  |=  val=json\n  ^-  tape\n  ?~  val  \"null\"\n  ?-    -.val\n      %a\n    ;:  weld\n      \"[\"\n      =|  rez=tape\n      |-  ^+  rez\n      ?~  p.val  rez\n      $(p.val t.p.val, rez :(weld rez ^$(val i.p.val) ?~(t.p.val ~ \",\")))\n      \"]\"\n    ==\n ::\n      %b  ?:(p.val \"true\" \"false\")\n      %n  (trip p.val)\n      %s\n    ;:  welp\n      \"\\\"\"\n      %+  reel\n        (turn (trip p.val) jesc)\n      |=([p=tape q=tape] (welp +&lt;))\n      \"\\\"\"\n    ==\n      %o\n    ;:  welp\n      \"\\{\"\n      =+  viz=(~(tap by p.val) ~)\n      =|  rez=tape\n      |-  ^+  rez\n      ?~  viz  rez\n      %=    $\n          viz  t.viz\n          rez\n        :(welp rez \"\\\"\" (trip p.i.viz) \"\\\":\" ^$(val q.i.viz) ?~(t.viz ~ \",\"))\n      ==\n      \"}\"\n    ==\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (pojo [%n '12.6'])\n\"12.6\"\n~zod/try=&gt; (crip (pojo %n '12.6'))\n'12.6'\n~zod/try=&gt; (crip (pojo %s 'samtel'))\n'\"samtel\"'\n~zod/try=&gt; (crip (pojo %a ~[(jone 12) (jape \"ha\")]))\n'[12,\"ha\"]'\n~zod/try=&gt; (crip (pojo %a ~[(jone 12) ~ (jape \"ha\")]))\n'[12,null,\"ha\"]'\n~zod/try=&gt; (crip (pojo %o (mo sale/(jone 12) same/b/| ~)))\n'{\"same\":false,\"sale\":12}'\n</code></pre>\n"
    },
    {
        "keys": [
            "saxo"
        ],
        "doc": "<h1><code>++saxo</code></h1>\n<p>List ancestors</p>\n<p>Lists the ancestors of <code>who</code>.</p>\n<h2>Accepts</h2>\n<p><code>who</code> is a <a href=\"\"><code>++ship</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++list</code></a> of <code>++ship</code>.</p>\n<h2>Source</h2>\n<pre><code>++  saxo                                                ::  autocanon\n  |=  who=ship\n  ^-  (list ship)\n  ?:  (lth who 256)  [who ~]\n  [who $(who (sein who))]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (saxo ~pittyp-pittyp)\n~[~pittyp-pittyp ~dalnel ~del]\n~zod/main=&gt; (saxo ~tasfyn-partyv)\n~[~tasfyn-partyv ~doznec ~zod]\n~zod/main=&gt; (saxo ~ractul-fodsug-sibryg-modsyl--difrun-mirfun-filrec-patmet)\n~[~ractul-fodsug-sibryg-modsyl--difrun-mirfun-filrec-patmet ~zod]\n</code></pre>\n"
    },
    {
        "keys": [
            "scanf` X"
        ],
        "doc": "<h1><code>++scanf</code> XX</h1>\n<p>Formatted scan</p>\n<pre><code>++  scanf                                              ::  formatted scan\n  |*  [tape (pole ,_:/(*$&amp;(_rule tape)))]\n  =&gt;  .(+&lt; [a b]=+&lt;)\n  (scan a (parsf b))\n</code></pre>\n<p>Scan with <code>;\"</code>-interpolated parsers.</p>\n<p>A- here there be monsters, monsters of my making. But the basic idea is\nyou use <code>;\"</code> (which currently is parsed by sail but shouldn't be) to mix\nliteral text and [++rule]s, and apply this to text which is a\ncorrespending mixture of aforementioned literals and sections parsable\nby the relevant rules. ++parsf is the parser form that combines a\ntape-rule mix into one big ++rule, ++norm being a parsf internal that\nwinnows the <code>;\"</code> result into a list of discriminate literals and rules,\nand ++bill doing the actual composing: ++\\$:parsf just adds a layer that\ncollapses the result list to a tuple, such that (scanf \"foo 1 2 bar\"\n;\"foo {dem} {dem} bar\") parses [1 2] and not [1 2 ~].</p>\n<pre><code>~zod/try=&gt; `[p=@ud q=@ud]`(scanf \"Score is 5 to 2\" [;\"Score is {n} to {n}\"]:n=dim:ag)\n[p=5 q=2]\n\n~zod/try=&gt; =n ;~(pfix (star (just '0')) (cook |=(@ud +&lt;) dim:ag))\n~zod/try=&gt; (scanf \"2014-08-12T23:10:58.931Z\" ;\"{n}\\-{n}\\-{n}T{n}:{n}:{n}.{n}Z\")\n[2.014 8 12 23 10 58 931]\n~zod/try=&gt; =dat (scanf \"2014-08-12T23:10:58.931Z\" ;\"{n}\\-{n}\\-{n}T{n}:{n}:{n}.{n}Z\")\n~zod/try=&gt; `@da`(year `date`dat(- [%&amp; -.dat], |6 ~[(div (mul |6.dat (bex 16)) 1.000)]))\n~2014.8.12..23.10.58..ee56\n</code></pre>\n"
    },
    {
        "keys": [
            "parsf` X"
        ],
        "doc": "<h1><code>++parsf</code> XX</h1>\n<pre><code>++  parsf                                              ::  make parser from:\n  |^  |*  a=(pole ,_:/(*$&amp;(_rule tape)))               ::  ;\"chars{rule}chars\"\n      %-  cook  :_  (bill (norm a))\n      |*  (list)\n      ?~  +&lt;  ~\n      ?~  t  i\n      [i $(+&lt; t)]\n  ::\n</code></pre>\n<p><code>parsf</code> generates a <code>_rule</code> from a tape with rules embedded in it,\nliteral sections being matched verbatim. The parsed type is a tuple of\nthe embedded rules' results.</p>\n<p>Two intermediate arms are used:</p>\n<p>#</p>\n"
    },
    {
        "keys": [
            "norm X"
        ],
        "doc": "<h1>++norm XX</h1>\n<pre><code>  ::  .=  (norm [;\"{n}, {n}\"]:n=dim:ag)  ~[[&amp; dim] [| \", \"] [&amp; dim]]:ag\n  ++  norm                                             \n    |*  (pole ,_:/(*$&amp;(_rule tape)))\n    ?~  +&lt;  ~\n    =&gt;  .(+&lt; [i=+&lt;- t=+&lt;+])\n    :_  t=$(+&lt; t)\n    =+  rul=-&gt;-&gt;.i\n    ^=  i\n    ?~  rul     [%| p=rul]\n    ?~  +.rul   [%| p=rul]\n    ?@  &amp;2.rul  [%| p=;;(tape rul)]\n    [%&amp; p=rul]\n  ::\n</code></pre>\n<p><code>norm</code> converts a <code>;\"</code> pole of <code>[[%~. [%~. ?(tape _rule)] ~] ~]</code> into a\nmore convenient list of discriminated tapes and rules.</p>\n<p>#</p>\n"
    },
    {
        "keys": [
            "bill X"
        ],
        "doc": "<h1>++bill XX</h1>\n<pre><code>  ::  .=  (bill ~[[&amp; dim] [| \", \"] [&amp; dim]]:ag)\n  ::  ;~(plug dim ;~(pfix com ace ;~(plug dim (easy)))):ag\n  ++  bill\n    |*  (list (each ,_rule tape))\n    ?~  +&lt;  (easy ~)\n    ?:  ?=(| -.i)  ;~(pfix (jest (crip p.i)) $(+&lt; t))\n    %+  cook  |*([* *] [i t]=+&lt;)\n    ;~(plug p.i $(+&lt; t))\n  --\n::\n</code></pre>\n<p><code>bill</code> builds a parser out of rules and tapes, ignoring the literal\nsections and producing a list of the rules' results.</p>\n"
    },
    {
        "keys": [
            "sein"
        ],
        "doc": "<h1><code>++sein</code></h1>\n<p>Direct parent</p>\n<p>Computes the direct parent of <code>who</code>.</p>\n<h2>Accepts</h2>\n<p><code>who</code> is a <a href=\"\"><code>++ship</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++ship</code>.</p>\n<h2>Source</h2>\n<pre><code>++  sein                                                ::  autoboss\n  |=  who=ship  ^-  ship\n  =+  mir=(clan who)\n  ?-  mir\n    %czar  who\n    %king  (end 3 1 who)\n    %duke  (end 4 1 who)\n    %earl  (end 5 1 who)\n    %pawn  `@p`0\n  ==\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (sein ~tasfyn-partyv)\n~doznec\n~zod/main=&gt; (sein ~doznec)\n~zod\n~zod/main=&gt; (sein ~zod)\n~zod\n~zod/main=&gt; (sein ~pittyp-pittyp)\n~dalnel\n~zod/main=&gt; (sein ~dalnel)\n~del\n~zod/main=&gt; (sein ~ractul-fodsug-sibryg-modsyl--difrun-mirfun-filrec-patmet)\n~zod\n\n~zod/main=&gt; (saxo ~rabdec-monfer)\n~[~rabdec-monfer ~dalnel ~del]\n~zod/main=&gt; `@rd`~rabdec-monfer\n0x5fd25\n[%rlyd 0x5.fd25]\n0b1.0000.0000.0000.0000.0000.0000.0000.0000.0000.0000.0000.0000.0000\n~zod/main=&gt; `@p`0x5.fd25\n~rabdec-monfer\n\nFor `@rd` and `@p` see the [odors](../reference/odors) reference\n</code></pre>\n"
    },
    {
        "keys": [
            "sifo"
        ],
        "doc": "<h1><code>++sifo</code></h1>\n<p>64-bit encode</p>\n<p>Encodes an atom to MIME base64, producing a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>tig</code> is an atom.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  sifo                                                ::  64-bit encode\n      |=  tig=@\n      ^-  tape\n      =+  poc=(~(dif fo 3) 0 (met 3 tig))\n      =+  pad=(lsh 3 poc (swap 3 tig))\n      =+  ^=  cha\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n      =+  ^=  sif\n          |-  ^-  tape\n          ?~  pad\n            ~\n          =+  d=(end 0 6 pad)\n          [(cut 3 [d 1] cha) $(pad (rsh 0 6 pad))]\n      (weld (flop (slag poc sif)) (trip (fil 3 poc '=')))\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (sifo 'foobar')\n\"Zm9vYmFy\"\n~zod/main=&gt; (sifo 1)\n\"Q==\"\n~zod/main=&gt; (sifo (shax %hi))\n\"j0NDRmSPa5bfid2pAcUXaxCm2Dlh3TwayItZstwyeqQ=\"\n</code></pre>\n"
    },
    {
        "keys": [
            "stud"
        ],
        "doc": "<h1><code>++stud</code></h1>\n<p>Parse UTC format</p>\n<p>Accepts a <a href=\"\"><code>++tape</code></a> containing a date in UTC format and produces the\n<a href=\"\"><code>++unit</code></a> of a <a href=\"\"><code>++date</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>cud</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>The <code>++unit</code> of a <code>++date</code>.</p>\n<h2>Source</h2>\n<pre><code>++  stud                                                ::  parse UTC format\n  |=  cud=tape\n  ^-  (unit date)\n  =-  ?~  tud  ~ \n      `[[%.y &amp;3.u.tud] &amp;2.u.tud &amp;1.u.tud &amp;4.u.tud &amp;5.u.tud &amp;6.u.tud ~]\n  ^=  tud\n  %+  rust  cud\n  ;~  plug\n    ;~(pfix (stun [5 5] next) dim:ag)\n  ::\n    %+  cook\n      |=  a=tape\n      =+  b=0\n      |-  ^-  @\n      ?:  =(a (snag b (turn mon:yu |=(a=tape (scag 3 a)))))\n          +(b)\n      $(b +(b))\n    (ifix [ace ace] (star alf))\n  ::\n    ;~(sfix dim:ag ace)  \n    ;~(sfix dim:ag col)\n    ;~(sfix dim:ag col)  \n    dim:ag  \n    (cold ~ (star next))\n  ==\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (stud \"Tue, 21 Oct 2014 21:21:55 +0000\")\n[~ [[a=%.y y=2.014] m=10 t=[d=21 h=21 m=21 s=55 f=~]]]\n~zod/try=&gt; (stud \"Wed, 11 Oct 2002 12:20:55 +0000\")\n[~ [[a=%.y y=2.002] m=10 t=[d=11 h=12 m=20 s=55 f=~]]]\n~zod/try=&gt; (stud \"Wed, 11 Oct 2002\")\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "taco"
        ],
        "doc": "<h1><code>++taco</code></h1>\n<p>Converts an atom to an octet stream <a href=\"\"><code>++octs</code></a>, which contains a length, to\nencode trailing zeroes.</p>\n<h2>Produces</h2>\n<p>An <code>++octs</code>.</p>\n<h2>Source</h2>\n<pre><code>++  taco                                                ::  atom to octstream\n  |=  tam=@  ^-  octs\n  [(met 3 tam) tam]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (taco 'abc')\n[p=3 q=6.513.249]\n~zod/try=&gt; `@t`6.513.249\n'abc'\n</code></pre>\n"
    },
    {
        "keys": [
            "tact"
        ],
        "doc": "<h1><code>++tact</code></h1>\n<p>tape to octs</p>\n<p>Converts a <code>++tape</code> to an octet stream (<a href=\"\"><code>++octs</code></a>, which contains a length\nto encode trailing zeroes.</p>\n<h2>Accepts</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>An <a href=\"\"><code>++octs</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  tact                                                ::  tape to octstream\n  |=  tep=tape  ^-  octs\n  (taco (rap 3 tep))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (tact \"abc\")\n[p=3 q=6.513.249]\n~zod/try=&gt; `@t`6.513.249\n'abc'\n</code></pre>\n"
    },
    {
        "keys": [
            "tame"
        ],
        "doc": "<h1><code>++tame</code></h1>\n<p>Parse kite path</p>\n<p>Parses a clay <a href=\"\">.\\^</a>\n<a href=\"\"><code>++path</code> </a>to request details. Produces the <a href=\"\"><code>++unit</code></a> of a <a href=\"\"><code>++kite</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>hap</code> is a <a href=\"\"><code>++path</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(unit kite)</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tame                                                ::  parse kite path\n      |=  hap=path\n      ^-  (unit kite)\n      ?.  ?=([@ @ @ @ *] hap)  ~\n      =+  :*  hyr=(slay i.hap)\n              fal=(slay i.t.hap)\n              dyc=(slay i.t.t.hap)\n              ved=(slay i.t.t.t.hap)\n              ::  ved=(slay i.t.hap)\n              ::  fal=(slay i.t.t.hap)\n              ::  dyc=(slay i.t.t.t.hap))\n              tyl=t.t.t.t.hap\n          ==\n      ?.  ?=([~ %$ %tas @] hyr)  ~\n      ?.  ?=([~ %$ %p @] fal)  ~\n      ?.  ?=([~ %$ %tas @] dyc)  ~\n      ?.  ?=([~ %$ case] ved)  ~\n      =+  his=`@p`q.p.u.fal\n      =+  [dis=(end 3 1 q.p.u.hyr) rem=(rsh 3 1 q.p.u.hyr)]\n      ?.  ?&amp;(?=(%c dis) ?=(?(%v %w %x %y %z) rem))  ~\n      [~ rem p.u.ved q.p.u.fal q.p.u.dyc tyl]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=/zop&gt; (tame /cx/~zod/main/1/sur/down/gate/hook)\n[~ [p=%x q=[%ud p=1] r=~zod s=%main t=/sur/down/gate/hook]]\n~zod/try=/zop&gt; (tame /cx/0/main/1/sur/down/gate/hook)\n~\n~zod/try=/zop&gt; (tame /~zod/main/0x12/sur/down/gate/hook)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "tell"
        ],
        "doc": "<h1><code>++tell</code></h1>\n<p>octs from wall</p>\n<p>Converts a <a href=\"\"><code>++wall</code></a> to an octet stream (<a href=\"\"><code>++octs</code></a>, which contains a length\nto encode trailing zeroes.</p>\n<h2>Accepts</h2>\n<p><code>wol</code> is a <a href=\"\"><code>++wall</code></a>.</p>\n<h2>Produces</h2>\n<p>An <code>++octs</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tell                                                ::  wall to octstream\n  |=  wol=wall  ^-  octs\n  =+  buf=(rap 3 (turn wol |=(a=tape (crip (weld a `tape`[`@`10 ~])))))\n  [(met 3 buf) buf]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (tell ~[\"abc\" \"line\" \"3\"])\n[p=11 q=12.330.290.663.108.538.769.039.969]\n~zod/try=&gt; `@t`12.330.290.663.108.538.769.039.969\n'''\nabc\nline\n3\n'''\n</code></pre>\n"
    },
    {
        "keys": [
            "tome"
        ],
        "doc": "<h1><code>++tome</code></h1>\n<p>Parse path to beam</p>\n<p>Parses a <a href=\"\"><code>++path</code></a> <code>pax</code> to a <a href=\"\">`++beam</a>, a well-typed location.</p>\n<h2>Accepts</h2>\n<p><code>pax</code> is a <a href=\"\"><code>++path</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>(unit beam)</code>.</p>\n<h2>Source</h2>\n<pre><code>++  tome                                                ::  parse path to beam\n      |=  pax=path\n      ^-  (unit beam)\n      ?.  ?=([* * * *] pax)  ~\n      %+  biff  (slaw %p i.pax)\n      |=  who=ship\n      %+  biff  (slaw %tas i.t.pax)\n      |=  dex=desk\n      %+  biff  (slay i.t.t.pax)\n      |=  cis=coin\n      ?.  ?=([%$ case] cis)  ~\n      `(unit beam)`[~ [who dex `case`p.cis] (flop t.t.t.pax)]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=/zop&gt; (tome /~fyr/try/2/for/me)\n[~ [[p=~fyr q=%try r=[%ud p=2]] s=/me/for]]\n~zod/try=/zop&gt; (tome /~zod/main/1)\n[~ [[p=~zod q=%main r=[%ud p=1]] s=/]]\n~zod/try=/zop&gt; (tome /0/main/1)\n~\n~zod/try=/zop&gt; (tome /~zod/main/0x12)\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "tope"
        ],
        "doc": "<h1><code>++tope</code></h1>\n<p>Parse beam to path</p>\n<p>Parses a <a href=\"\"><code>++beam</code></a> <code>bem</code> to a <a href=\"\"><code>++path</code></a>.</p>\n<h2>Accepts</h2>\n<p><code>bem</code> is a <code>++beam</code>.</p>\n<h2>Produces</h2>\n<p>A <code>++path</code>.</p>\n<pre><code>++tope\n    |=  bem=beam\n      ^-  path\n      [(scot %p p.bem) q.bem (scot r.bem) (flop s.bem)]\n</code></pre>\n<p>Parses a <a href=\"\"><code>++beam</code></a> to a <a href=\"/docs/hoon/library/1#++path\"><code>++path</code></a>.</p>\n<pre><code>~zod/try=/zop&gt; (tope [~zod %main ud/1] /hook/down/sur)\n/~zod/main/1/sur/down/hook\n~zod/try=/zop&gt; (tope [~fyr %try da/~2015.1.1] /txt/test)\n/~fyr/try/~2015.1.1/test/txt\n~zod/try=/zop&gt; (tope [~doznec %try da/-&lt;-] /txt/test)\n/~doznec/try/~2014.10.30..00.32.48..3ae4/test/txt\n</code></pre>\n"
    },
    {
        "keys": [
            "txml"
        ],
        "doc": "<h1><code>++txml</code></h1>\n<p>Tape to xml CDATA node</p>\n<p>Converts a <a href=\"\"><code>++tape</code></a> to an xml CDATA node XX</p>\n<h2>Accepts</h2>\n<p><code>tep</code> is a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Produces</h2>\n<p>A <a href=\"\"><code>++manx</code></a>.</p>\n<h2>Source</h2>\n<pre><code>++  txml                                                ::  string to xml\n  |=  tep=tape  ^-  manx\n  [[%$ [%$ tep] ~] ~]\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=&gt; (txml \"hi\")\n[g=[n=%$ a=~[[n=%$ v=\"hi\"]]] c=~]\n~zod/try=&gt; (txml \"larton bestok\")\n[\n</code></pre>\n"
    },
    {
        "keys": [
            "unt"
        ],
        "doc": "<h1><code>++unt</code></h1>\n<p>UGT to UTC time</p>\n<p>Transforms Urbit Galactic Time to UTC time, producing an atom.</p>\n<h2>Accepts</h2>\n<p>An atom of <a href=\"\">odor</a> <a href=\"\"><code>@da</code></a>, representing an absolute date.</p>\n<h2>Produces</h2>\n<p>An atom.</p>\n<h2>Source</h2>\n<pre><code>++  unt                                                 ::  UGT to UTC time\n  |=  a=@da\n  (div (sub a ~1970.1.1) (bex 64))\n::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/try=/hom&gt; (unt -&lt;-)\n1.413.927.704\n~zod/try=&gt; (unt ~20014.1.1)\n569.413.670.400\n~zod/try=&gt; (unt ~2014.1.1)\n1.388.534.400\n</code></pre>\n"
    },
    {
        "keys": [
            "urld"
        ],
        "doc": "<h1><code>++urld</code></h1>\n<p>Decode URL</p>\n<p>The inverse of <a href=\"\"><code>++urle</code></a>. Parses a URL escaped <a href=\"\"><code>++tape</code></a> to the\n<a href=\"\"><code>++unit</code></a> of an unescaped <code>++tape</code>.</p>\n<h2>Accepts</h2>\n<p><code>tep</code> is a <code>++tape</code>.</p>\n<h2>Produces</h2>\n<p>The <a href=\"\"><code>++unit</code></a> of a <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  urld                                                ::  URL decode\n      |=  tep=tape\n      ^-  (unit tape)\n      ?~  tep  [~ ~]\n      ?:  =('%' i.tep)\n        ?.  ?=([@ @ *] t.tep)  ~\n        =+  nag=(mix i.t.tep (lsh 3 1 i.t.t.tep))\n        =+  val=(rush nag hex:ag)\n        ?~  val  ~\n        =+  nex=$(tep t.t.t.tep)\n        ?~(nex ~ [~ [`@`u.val u.nex]])\n      =+  nex=$(tep t.tep)\n      ?~(nex ~ [~ i.tep u.nex])\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (urld \"hello\")\n[~ \"hello\"]\n~zod/main=&gt; (urld \"hello%20dear\")\n[~ \"hello dear\"]\n~zod/main=&gt; (urld \"hello-my%3F%3Dme%20%20%21\")\n[~ \"hello-my?=me  !\"]\n~zod/main=&gt; (urld \"hello-my%3F%3Dme%20%2%21\")\n~\n</code></pre>\n"
    },
    {
        "keys": [
            "urle"
        ],
        "doc": "<h1><code>++urle</code></h1>\n<p>Encode URL</p>\n<p>The inverse of <a href=\"\"><code>++urld</code></a>. Accepts a tape <code>tep</code> and replaces all\ncharacters other than alphanumerics and <code>.</code>, <code>-</code>, <code>~</code>, and <code>_</code>, with URL\nescape sequences.</p>\n<h2>Accepts</h2>\n<p><code>tep</code> is a <a href=\"\"><code>++tape</code></a>.</p>\n<h2>Produces</h2>\n<p>A <code>++tape</code>.</p>\n<h2>Source</h2>\n<pre><code>++  urle                                                ::  URL encode\n      |=  tep=tape\n      ^-  tape\n      %-  zing\n      %+  turn  tep\n      |=  tap=char\n      =+  xen=|=(tig=@ ?:((gte tig 10) (add tig 55) (add tig '0')))\n      ?:  ?|  &amp;((gte tap 'a') (lte tap 'z'))\n              &amp;((gte tap 'A') (lte tap 'Z'))\n              &amp;((gte tap '0') (lte tap '9'))\n              =('.' tap)\n              =('-' tap)\n              =('~' tap)\n              =('_' tap)\n          ==\n        [tap ~]\n      ['%' (xen (rsh 0 4 tap)) (xen (end 0 4 tap)) ~]\n    ::\n</code></pre>\n<h2>Examples</h2>\n<pre><code>~zod/main=&gt; (urle \"hello\")\n\"hello\"\n~zod/main=&gt; (urle \"hello dear\")\n\"hello%20dear\"\n~zod/main=&gt; (urle \"hello-my?=me  !\")\n\"hello-my%3F%3Dme%20%20%21\"\n</code></pre>\n"
    },
    {
        "keys": [
            "udal"
        ],
        "doc": "<h1><code>++udal</code></h1>\n<h2>Source</h2>\n<pre><code>    ++  udal                                                ::  atomic change (%b)\n</code></pre>\n<h2>Examples</h2>\n"
    },
    {
        "keys": [
            "udon"
        ],
        "doc": "<h1><code>++udon</code></h1>\n<pre><code>++  udon                                                ::  abstract delta\n          $:  p=umph                                    ::  preprocessor\n              $=  q                                     ::  patch\n              $%  [%a p=* q=*]                          ::  trivial replace\n                  [%b p=udal]                           ::  atomic indel\n                  [%c p=(urge)]                         ::  list indel\n                  [%d p=upas q=upas]                    ::  tree edit\n              ==                                        ::\n          ==                                            ::\n</code></pre>\n<p>See <code>%clay</code> doc</p>\n"
    },
    {
        "keys": [
            "umph"
        ],
        "doc": "<h1><code>++umph</code></h1>\n<pre><code>++  umph                                                ::  change filter\n          $|  $?  %a                                    ::  no filter\n                  %b                                    ::  jamfile\n                  %c                                    ::  LF text\n              ==                                        ::\n          $%  [%d p=@ud]                                ::  blocklist\n          ==                                            ::\n</code></pre>\n<p>See <code>%clay</code> doc</p>\n"
    },
    {
        "keys": [
            "unce"
        ],
        "doc": "<h1><code>++unce</code></h1>\n<pre><code>++  unce  |*  a=_,*                                     ::  change part\n          $%  [%&amp; p=@ud]                                ::  skip[copy]\n              [%| p=(list a) q=(list a)]                ::  p -&gt; q[chunk]\n          ==                                            ::  \n</code></pre>\n<p>See <code>%clay</code> doc</p>\n"
    },
    {
        "keys": [
            "upas"
        ],
        "doc": "<h1><code>++upas</code></h1>\n<pre><code>++  upas                                                ::  tree change (%d)\n          $&amp;  [p=upas q=upas]                           ::  cell\n          $%  [%0 p=axis]                               ::  copy old\n              [%1 p=*]                                  ::  insert new\n              [%2 p=axis q=udon]                        ::  mutate!\n          ==                                            ::\n</code></pre>\n<p>See <code>%clay</code> doc</p>\n"
    },
    {
        "keys": [
            "urge"
        ],
        "doc": "<h1><code>++urge</code></h1>\n<pre><code>++  urge  |*(a=_,* (list (unce a)))                     ::  list change\n</code></pre>\n<p>See <code>%clay</code> doc</p>\n"
    }
]
